<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>cpp STL: priority_queue自定义排序函数</title>
    <url>/20220225095132_3023/</url>
    <content><![CDATA[<p>priority_queue是C++的一种STL容器，实现为堆。在leetcode刷题中非常常用。有些时候我们需要塞入自定义的数据结构。这样就需要对其的排序方式做一个重新定义。<br>
假设有以下数据结构</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对比方式为只看x的大小。把x的值大的放在堆顶。<br>
则对比函数cmp写法如下：</p>
<h2 id="1-仿函数（函数对象）">1. 仿函数（函数对象）</h2>
<p>用这种方式，需要显示的定义优先队列的容器类型（vector）以及比较函数（cmp）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//函数对象类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cmp</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//重载 () 运算符</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node a = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    node b = &#123;<span class="number">0</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    node c = &#123;<span class="number">1</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    node d = &#123;<span class="number">2</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    node e = &#123;<span class="number">3</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    priority_queue&lt;node, vector&lt;node&gt;, cmp&lt;node&gt;&gt; pq; <span class="comment">// 显式指定容器类型和比较函数</span></span><br><span class="line">    pq.<span class="built_in">push</span>(a);</span><br><span class="line">    pq.<span class="built_in">push</span>(b);</span><br><span class="line">    pq.<span class="built_in">push</span>(c);</span><br><span class="line">    pq.<span class="built_in">push</span>(d);</span><br><span class="line">    pq.<span class="built_in">push</span>(e);</span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; pq.<span class="built_in">top</span>().x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; pq.<span class="built_in">top</span>().y &lt;&lt; endl;</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@└────&gt; # ./pq</span><br><span class="line">3,6</span><br><span class="line">2,5</span><br><span class="line">1,3</span><br><span class="line">1,2</span><br><span class="line">0,2</span><br></pre></td></tr></table></figure>
<h2 id="2-使用自定义类型比较关系">2. 使用自定义类型比较关系</h2>
<p>重载需要比较类型的$&lt;$符号，之后在类型直接写类型名称即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (node b) <span class="type">const</span> &#123; <span class="comment">// 这里后面的const必须加</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;x &lt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node a = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    node b = &#123;<span class="number">0</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    node c = &#123;<span class="number">1</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    node d = &#123;<span class="number">2</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    node e = &#123;<span class="number">3</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    priority_queue&lt;node&gt; pq; <span class="comment">// 只写类型名称即可</span></span><br><span class="line">    pq.<span class="built_in">push</span>(a);</span><br><span class="line">    pq.<span class="built_in">push</span>(b);</span><br><span class="line">    pq.<span class="built_in">push</span>(c);</span><br><span class="line">    pq.<span class="built_in">push</span>(d);</span><br><span class="line">    pq.<span class="built_in">push</span>(e);</span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; pq.<span class="built_in">top</span>().x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; pq.<span class="built_in">top</span>().y &lt;&lt; endl;</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@└────&gt; # ./pq</span><br><span class="line">3,6</span><br><span class="line">2,5</span><br><span class="line">1,3</span><br><span class="line">1,2</span><br><span class="line">0,2</span><br></pre></td></tr></table></figure>
<h2 id="3-使用lambda表达式">3. 使用lambda表达式</h2>
<p>使用lambda表达式需要在pq对象构造的时候，将lambda表达式作为参数传入其中。即<font color="gree">pq(cmp)</font>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cmp = [](node x, node y) &#123;</span><br><span class="line">        <span class="keyword">return</span> x.x &lt; y.x;</span><br><span class="line">    &#125;;</span><br><span class="line">    node a = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    node b = &#123;<span class="number">0</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    node c = &#123;<span class="number">1</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    node d = &#123;<span class="number">2</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    node e = &#123;<span class="number">3</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    priority_queue&lt;node, vector&lt;node&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">pq</span>(cmp); <span class="comment">// 需要在pq对象创建的时候将lambda表达式作为参数传入</span></span><br><span class="line">    <span class="comment">// priority_queue&lt;node, vector&lt;node&gt;, function&lt;bool(node, node)&gt; &gt; pq(cmp); // 和上面的效果相同，但是用function需要包含头文件functional</span></span><br><span class="line">    pq.<span class="built_in">push</span>(a);</span><br><span class="line">    pq.<span class="built_in">push</span>(b);</span><br><span class="line">    pq.<span class="built_in">push</span>(c);</span><br><span class="line">    pq.<span class="built_in">push</span>(d);</span><br><span class="line">    pq.<span class="built_in">push</span>(e);</span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; pq.<span class="built_in">top</span>().x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; pq.<span class="built_in">top</span>().y &lt;&lt; endl;</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@└────&gt; # ./pq</span><br><span class="line">3,6</span><br><span class="line">2,5</span><br><span class="line">1,3</span><br><span class="line">1,2</span><br><span class="line">0,2</span><br></pre></td></tr></table></figure>
<h2 id="4-函数指针（和上面的相比有些多余，刷题不是很实用）">4. 函数指针（和上面的相比有些多余，刷题不是很实用）</h2>
<p>这种方式和lambda表达式的方式很类似。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node x, node y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.x &lt; y.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node a = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    node b = &#123;<span class="number">0</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    node c = &#123;<span class="number">1</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    node d = &#123;<span class="number">2</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    node e = &#123;<span class="number">3</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="built_in">bool</span> (*funcp)(node x, node y) = cmp;</span><br><span class="line">    priority_queue&lt;node, vector&lt;node&gt;, <span class="keyword">decltype</span>(*funcp)&gt; <span class="built_in">pq</span>(*funcp);</span><br><span class="line">    pq.<span class="built_in">push</span>(a);</span><br><span class="line">    pq.<span class="built_in">push</span>(b);</span><br><span class="line">    pq.<span class="built_in">push</span>(c);</span><br><span class="line">    pq.<span class="built_in">push</span>(d);</span><br><span class="line">    pq.<span class="built_in">push</span>(e);</span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; pq.<span class="built_in">top</span>().x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; pq.<span class="built_in">top</span>().y &lt;&lt; endl;</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@└────&gt; # ./pq</span><br><span class="line">3,6</span><br><span class="line">2,5</span><br><span class="line">1,3</span><br><span class="line">1,2</span><br><span class="line">0,2</span><br></pre></td></tr></table></figure>
<p>reference：</p>
<p><a href="https://blog.csdn.net/Strengthennn/article/details/119078911">https://blog.csdn.net/Strengthennn/article/details/119078911</a></p>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp new和operator new的区别</title>
    <url>/20230226005931_7541/</url>
    <content><![CDATA[<h1>C++ 的 new</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">className a = <span class="keyword">new</span> className;</span><br></pre></td></tr></table></figure>
<p>new 是 C++ 的关键字，<strong>不能被重载</strong>。过程上分为两步：</p>
<ol>
<li>分配内存。这一步底层就是调用了标题中提到的另一个 operator new 来完成的。也就是说最大的区别是 operator new 只负责分配内存，而 new 调用 operator new 并且调用构造函数。如果类 className 重载了 operator new（属于类里面的运算符），那么上述代码调用的就是</li>
</ol>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">A::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>来分配内存，否则调用的是</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">::<span class="function"><span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>，由全局的 operator new 来分配。<br>
2. 调用 className 的构造函数。</p>
<h1>C++ 的operator new</h1>
<p>相信看到这里已经知道他们的区别了，那么举个例子跑一下看看就清楚了！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123; <span class="comment">//重载类的operator new 改变new的行为</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;重载的类operator new 被调用!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *ptr)</span></span>&#123; <span class="comment">//重载类的operator delete 改变new的行为</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;重载的类operator delete 被调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">free</span>(ptr); <span class="comment">//释放内存</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">static</span> <span class="type">void</span> * <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span> size) &#123; <span class="comment">//重载类的operator new[] 改变new[]的行为</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;重载的类operator new[] 被调用!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span> *ptr) &#123; <span class="comment">//重载类的operator delete[] 改变new[]的行为</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;重载的类operator delete[] 被调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">free</span>(ptr); <span class="comment">//释放内存             &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        A *a = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">        A *b = <span class="keyword">new</span> A[<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">delete</span> (a);</span><br><span class="line">        <span class="keyword">delete</span>[](b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">重载的类operator new 被调用！</span><br><span class="line">重载的类operator new[] 被调用！</span><br><span class="line">重载的类operator delete 被调用！</span><br><span class="line">重载的类operator delete[] 被调用！</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP算法</title>
    <url>/20221109222551_35921/</url>
    <content><![CDATA[<h2 id="KMP算法是什么">KMP算法是什么</h2>
<p>是用来解决字符串匹配的问题。在一个 $str$ 字符串中找到一个子字符串 $sub$，返回索引的位置。<br>
常规能想到的最简单的方式就是一个一个比对，匹配失败的话就向下挪一个位置继续匹配。这样做时间复杂度是 $O(n^2)$。<br>
KMP算法可以在 $O(n)$ 的时间复杂度内解决这个问题。</p>
<h2 id="next数组是什么">next数组是什么</h2>
<p>$next$ 数组的本质是寻找子串中“相同前后缀的长度，并且最长”。并且不能是字符串本身。举个例子而言，如下所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">C</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
<p>第 $1$位 $A$ 只有一个字符，不能是字符串本身，为 $0$；<br>
第 $2$位 $B$ 和 $A$ 比较，不相等，为 $0$；<br>
第 $3$位 $A$ 和 $A$ 比较，相等，所以相同前缀为 $1$；<br>
第 $4$位 $B$ 和前缀为 $1$ 后的 $B$ 比较，相等，和前缀组成了 $AB$ 的相同模式的串，所以相同前缀为 $2$；<br>
第 $5$ 位 $C$ 和前缀为 $2$ 后的 $A$ 比较，不相等，和前缀长度为 $0$ 的比，相同前缀为$0$；<br>
关于最长前缀的理解是，如下图所示。<br>
<img src="/20221109222551_35921/next.png" alt="next"><br>
最后一位的 $A$ 很显然可以和 $ABA$ 组成长度为 $3$ 的相同前缀，也可以自己 $A$ 组成长度为 $1$ 的相同前缀。这种情况下选择较大的那个值。</p>
<h2 id="求解next数组">求解next数组</h2>
<p>$next$ 数组求解的本质是动态规划。假设我们已经知道当前数字的共同前后缀了，如下图所示。<br>
<img src="/20221109222551_35921/1.png" alt="1"><br>
接下来求第 $i$ 位的 $next$ 数组，分为两种情况。</p>
<ol>
<li>下一位也和前缀相等<br>
那就很明显等于 $next[i - 1]$ 加上 $1$。</li>
<li>下一位和前缀不相等<br>
这里不是直接等于 $0$ 哦。如下图所示<br>
<img src="/20221109222551_35921/2.png" alt="2"><br>
虽然 $ABAB$ 和 $ABAC$ 并不相等，但是也不能直接设为 $0$。因为这个新来的 $B$ 可以和前面的 $A$ 组成 $AB$，达到 $2$ 的长度。那么这个数难道要暴力求解吗？其实不然。此时第 $i - 1$ 位的 $next$ 的可利用的值在前缀的 $next$ 数组中可以得到答案，在本图中为 $next[2]$，即是 $1$。此时修改前缀长度为 $next[2]$，则又回到了最开始的状况，匹配长度为 $1$ 并且匹配下一位，下一位 $B$ 相等，所以 $next[i]$ 为 $1 + 1 = 2$。<br>
代码如下：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">buildNext</span><span class="params">(string sub)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; next;</span><br><span class="line">    next.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> prefix_len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>; <span class="comment">// 处理的索引，不会后退，以保证时间复杂度为O(n)</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; sub.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sub[i] == sub[prefix_len]) &#123; <span class="comment">// 下一位相等，next数组数值+1</span></span><br><span class="line">            prefix_len++;</span><br><span class="line">            next.<span class="built_in">push_back</span>(prefix_len);</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 下一位不相等</span></span><br><span class="line">            <span class="keyword">if</span> (prefix_len == <span class="number">0</span>) &#123;</span><br><span class="line">                next.<span class="built_in">push_back</span>(prefix_len); <span class="comment">// 目前没有相等的，就是0了</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prefix_len = next[prefix_len - <span class="number">1</span>]; <span class="comment">// 有不为0的前缀选择，继续回到开始状况</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="next数组在KMP中的应用">next数组在KMP中的应用</h2>
<p>KMP算法在匹配失败的时候，回去看最后失败的字符前一个字符所对应的 $next$ 值。$next$ 数组中的值是什么作用呢？它代表我们可以“<strong>跳过匹配</strong>”的字符数量。<br>
<img src="/20221109222551_35921/3.png" alt="3"><br>
<img src="/20221109222551_35921/4.png" alt="4"><br>
这样就可以保证匹配的 $i$ 不向后退，达到时间复杂度 $O(n)$ 的目的。<br>
代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">kmp</span><span class="params">(string s, string sub)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; next = <span class="built_in">buildNext</span>(sub);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">// 主串指针</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>; <span class="comment">// 子串指针</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == sub[j]) &#123; <span class="comment">// 匹配，指针后移</span></span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123; <span class="comment">// 匹配失败，但是next跳过了一些字符继续匹配</span></span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 子串第一个字符就匹配失败</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == sub.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> i - j; <span class="comment">// 成功，返回初始下标</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Llama结构解析</title>
    <url>/20231206110011_1014858940/</url>
    <content><![CDATA[<h2 id="模型打印">模型打印</h2>
<p>已Llama-7B hugging face版本为例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoTokenizer, AutoModelForCausalLM</span><br><span class="line">device = torch.device(<span class="string">&quot;cuda:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(gpu))</span><br><span class="line">tokenizer = AutoTokenizer.from_pretrained(model_name, trust_remote_code = <span class="literal">True</span>)</span><br><span class="line">model = AutoModelForCausalLM.from_pretrained(model_name, trust_remote_code = <span class="literal">True</span>).half().to(device)</span><br><span class="line"><span class="built_in">print</span>(model)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">LlamaForCausalLM(</span><br><span class="line">  (model): LlamaModel(</span><br><span class="line">    (embed_tokens): Embedding(<span class="number">32000</span>, <span class="number">4096</span>)</span><br><span class="line">    (layers): ModuleList(</span><br><span class="line">      (<span class="number">0</span>-<span class="number">31</span>): <span class="number">32</span> x LlamaDecoderLayer(</span><br><span class="line">        (self_attn): LlamaFlashAttention2(</span><br><span class="line">          (q_proj): Linear(in_features=<span class="number">4096</span>, out_features=<span class="number">4096</span>, bias=<span class="literal">False</span>)</span><br><span class="line">          (k_proj): Linear(in_features=<span class="number">4096</span>, out_features=<span class="number">4096</span>, bias=<span class="literal">False</span>)</span><br><span class="line">          (v_proj): Linear(in_features=<span class="number">4096</span>, out_features=<span class="number">4096</span>, bias=<span class="literal">False</span>)</span><br><span class="line">          (o_proj): Linear(in_features=<span class="number">4096</span>, out_features=<span class="number">4096</span>, bias=<span class="literal">False</span>)</span><br><span class="line">          (rotary_emb): LlamaRotaryEmbedding()</span><br><span class="line">        )</span><br><span class="line">        (mlp): LlamaMLP(</span><br><span class="line">          (gate_proj): Linear(in_features=<span class="number">4096</span>, out_features=<span class="number">11008</span>, bias=<span class="literal">False</span>)</span><br><span class="line">          (up_proj): Linear(in_features=<span class="number">4096</span>, out_features=<span class="number">11008</span>, bias=<span class="literal">False</span>)</span><br><span class="line">          (down_proj): Linear(in_features=<span class="number">11008</span>, out_features=<span class="number">4096</span>, bias=<span class="literal">False</span>)</span><br><span class="line">          (act_fn): SiLUActivation()</span><br><span class="line">        )</span><br><span class="line">        (input_layernorm): LlamaRMSNorm()</span><br><span class="line">        (post_attention_layernorm): LlamaRMSNorm()</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">    (norm): LlamaRMSNorm()</span><br><span class="line">  )</span><br><span class="line">  (lm_head): Linear(in_features=<span class="number">4096</span>, out_features=<span class="number">32000</span>, bias=<span class="literal">False</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>从结构可以看出来，模型参数量为 $32,000 * 4,096 + 32 * (4,096 * 4,096 * 4 + 4,096 * 11,008 * 3) + 4,096 * 32,000 = 6,738,149,376$。所以约为$7B$。</p>
<h2 id="模型图解">模型图解</h2>
<p>以输入为 10 个 token 为例：<br>
<img src="/20231206110011_1014858940/1.png" alt="1"></p>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>LLM</tag>
      </tags>
  </entry>
  <entry>
    <title>callgrind和kcachegrind查看调用时间和调用图</title>
    <url>/20230418010134_2667555321/</url>
    <content><![CDATA[<h1>callgrind</h1>
<p>callgrind 是 valgrind 套件中的一个工具，使用方式为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">valgrind --tool=callgrind ./your_program your_program_args1 your_program_args2</span><br></pre></td></tr></table></figure>
<p>运行之后，可以生成一份 callgrind.out.pid 的文件，在当前目录下。这份文件记录了运行时的一些数据，以及函数调用关系。</p>
<h1>kcachegrind</h1>
<p>kcachegrind 可以分析上述产生的 callgrind.out.pid 的文件，并且点击下方 call graph 可以看到调用关系图，帮助我们分析代码结构。</p>
<p><a href="https://sourceforge.net/projects/precompiledbin/files/?source=navbar" title="工具下载">点击下载windows版kcachegrind</a></p>
<h1>示例</h1>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">accumulate</span><span class="params">(<span class="type">int</span> begin, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = begin; i &lt; end; i++) &#123;</span><br><span class="line">        result += i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">accumulate0_100000</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">accumulate</span>(<span class="number">0</span>, <span class="number">100000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">accumulate0_200000</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">accumulate</span>(<span class="number">0</span>, <span class="number">200000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">accumulate0_100000</span>();</span><br><span class="line">    <span class="built_in">accumulate0_200000</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">valgrind --tool=callgrind --dump-instr=yes --trace-jump=yes ./a.out</span><br></pre></td></tr></table></figure>
<h2 id="kcachegrind分析">kcachegrind分析</h2>
<p>生成文件后，使用 kcachegrind 工具打开这个分析文件。</p>
<p><img src="/20230418010134_2667555321/1.png" alt="1"></p>
<p>可以从图中看到函数执行时间，百分比等功能。</p>
<h2 id="gprof2dot分析">gprof2dot分析</h2>
<p>使用 gprof2dot 工具，需要安装 python 和 graphviz。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install graphviz</span><br><span class="line">pip3 install gprof2dot</span><br></pre></td></tr></table></figure>
<p>之后使用上述工具对其进行分析，生成调用图。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gprof2dot -f callgrind -n0 -e0 ./callgrind.out.2328 &gt; callgrind.2328.dot</span><br><span class="line">dot callgrind.2328.dot -Tsvg -o callgrind.2328.dot.svg</span><br></pre></td></tr></table></figure>
<p>其中 -f 指定输出格式为 callgrin d格式，-nX 指定生成的文件忽略小于 X 个 node 的函数，例如 -n10，代表函数节点小于 10 个的，在最终文件中不生成其相关信息，-eX 代表边缘阈值，与 -n 类似。</p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>cgi简单服务器</title>
    <url>/20220504214132_17671/</url>
    <content><![CDATA[<p>CGI 是Web 服务器运行时外部程序的规范,按CGI 编写的程序可以扩展服务器功能。<br>
CGI(Common Gateway Interface) 是WWW技术中最重要的技术之一，有着不可替代的重要地位。CGI是外部应用程序（CGI程序）与WEB服务器之间的接口标准，是在CGI程序和Web服务器之间传递信息的过程。<br>
CGI规范允许Web服务器执行外部程序，并将它们的输出发送给Web浏览器，CGI将Web的一组简单的静态超媒体文档变成一个完整的新的交互式媒体。</p>
<h2 id="CGI的处理步骤：">CGI的处理步骤：</h2>
<ol>
<li>通过Internet把用户请求送到web服务器。</li>
<li>web服务器接收用户请求并交给CGI程序处理。</li>
<li>CGI程序把处理结果传送给web服务器。</li>
<li>web服务器把结果送回到用户。</li>
</ol>
<h2 id="示例代码：">示例代码：</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;processpool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于处理客户cgi请求的类，他可以作为processpool类的模板参数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cgi_conn</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">cgi_conn</span>()&#123;&#125;;</span><br><span class="line">  ~<span class="built_in">cgi_conn</span>()&#123;&#125;;</span><br><span class="line">  <span class="comment">// 初始化客户连接，清空读缓冲区</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> epollfd, <span class="type">int</span> sockfd, <span class="type">const</span> sockaddr_in&amp; client_addr)</span> </span>&#123;</span><br><span class="line">    m_epollfd = epollfd;</span><br><span class="line">    m_sockfd = sockfd;</span><br><span class="line">    m_address = client_addr;</span><br><span class="line">    <span class="built_in">memset</span>(m_buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE);</span><br><span class="line">    m_read_idx = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 循环读取和分析客户数据</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      idx = m_read_idx;</span><br><span class="line">      ret = <span class="built_in">recv</span>(m_sockfd, m_buf + idx, BUFFER_SIZE - <span class="number">1</span> - idx, <span class="number">0</span>);</span><br><span class="line">      <span class="comment">// 如果读操作发生错误，则关闭客户连接，如果是暂时无数据可读，则退出循环</span></span><br><span class="line">      <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">          <span class="built_in">removefd</span>(m_epollfd, m_sockfd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果对方关闭连接，服务器也关闭连接</span></span><br><span class="line">        <span class="built_in">removefd</span>(m_epollfd, m_sockfd);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        m_read_idx += ret;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;user content is: %s\n&quot;</span>, m_buf);</span><br><span class="line">        <span class="keyword">for</span> (; idx &lt; m_read_idx; ++idx) &#123;</span><br><span class="line">          <span class="keyword">if</span> ((idx &gt;= <span class="number">1</span>) &amp;&amp; (m_buf[idx - <span class="number">1</span>] == <span class="string">&#x27;\r&#x27;</span>) &amp;&amp; (m_buf[idx] == <span class="string">&#x27;\n&#x27;</span>)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有遇到字符\r\n 则需要读取更多客户数据</span></span><br><span class="line">        <span class="keyword">if</span> (idx == m_read_idx) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m_buf[idx - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>* filename = m_buf;</span><br><span class="line">        <span class="comment">// 判断客户要运行的cgi程序是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">access</span>(filename, F_OK) == <span class="number">-1</span>) &#123;</span><br><span class="line">          <span class="built_in">removefd</span>(m_epollfd, m_sockfd);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建子进程来执行cgi程序</span></span><br><span class="line">        ret = fork();</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">          <span class="built_in">removefd</span>(m_epollfd, m_sockfd);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123; <span class="comment">// 父进程</span></span><br><span class="line">          <span class="comment">// 父进程只需要关闭连接</span></span><br><span class="line">          <span class="built_in">removefd</span>(m_epollfd, m_sockfd);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 子进程需要将标准输出定向到 m_sockfd,并执行cgi程序</span></span><br><span class="line">          <span class="built_in">close</span>(STDOUT_FILENO);</span><br><span class="line">          <span class="built_in">dup</span>(m_sockfd); <span class="comment">// 把m_sockfd重定向到标准输出</span></span><br><span class="line">          <span class="built_in">execl</span>(m_buf, m_buf, <span class="number">0</span>);</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="comment">// 读数据end</span></span><br><span class="line">    &#125; <span class="comment">// while end</span></span><br><span class="line"></span><br><span class="line">  &#125; <span class="comment">// process end</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> BUFFER_SIZE = <span class="number">1024</span>;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> m_epollfd;</span><br><span class="line">  <span class="type">int</span> m_sockfd;</span><br><span class="line">  sockaddr_in m_address;</span><br><span class="line">  <span class="type">char</span> m_buf[BUFFER_SIZE];</span><br><span class="line">  <span class="type">int</span> m_read_idx; <span class="comment">// 读的光标位置</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cgi_conn::m_epollfd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="built_in">basename</span>(argv[<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">  <span class="type">int</span> port = <span class="built_in">atoi</span>(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> listenfd = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">assert</span>(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;</span><br><span class="line">  <span class="built_in">bzero</span>(&amp;address, <span class="built_in">sizeof</span>(address));</span><br><span class="line">  address.sin_family = AF_INET;</span><br><span class="line">  <span class="built_in">inet_pton</span>(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">  address.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line"></span><br><span class="line">  ret = <span class="built_in">bind</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="built_in">sizeof</span>(address));</span><br><span class="line">  <span class="built_in">assert</span>(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  ret = <span class="built_in">listen</span>(listenfd, <span class="number">5</span>);</span><br><span class="line">  <span class="built_in">assert</span>(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  processpool&lt;cgi_conn&gt;* pool = processpool&lt;cgi_conn&gt;::<span class="built_in">create</span>(listenfd); <span class="comment">// 创建唯一进程池实例</span></span><br><span class="line">  <span class="keyword">if</span> (pool) &#123;</span><br><span class="line">    pool-&gt;<span class="built_in">run</span>();</span><br><span class="line">    <span class="keyword">delete</span> pool;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">close</span>(listenfd); <span class="comment">// 正如前文提到的，main函数创建了文件描述符listenfd，那么就由它亲自关闭之</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本程序需要配合上一节的线程池头文件processpool.h。<br>
运行结果如下：</p>
<h2 id="服务器">服务器</h2>
<p><img src="/20220504214132_17671/1.png" alt="在这里插入图片描述"></p>
<hr>
<h2 id="客户端：">客户端：</h2>
<p><img src="/20220504214132_17671/2.png" alt="在这里插入图片描述"></p>
<hr>
<p>这里只是简单模拟，由于服务器是将信息作为文件名去访问服务器文件，而客户端随意发送信息，所以判断信息不存在就直接退出了。</p>
<hr>
<p>reference：linux高性能服务器编程——游双</p>
]]></content>
      <categories>
        <category>socket-programming</category>
        <category>concurrent-programming</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>socket</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp attribute 之 visibility</title>
    <url>/20231110175028_3334074855/</url>
    <content><![CDATA[<h2 id="attribute-visibility-“”"><strong>attribute</strong> ((visibility(“”)))</h2>
<p>是 gcc 的编译器指令，用于设置在 shared object 中所修饰的符号对外的可见性。该修饰对 .a 文件不生效，只对 .so 库生效。</p>
<h2 id="attribute-visibility-“default”"><strong>attribute</strong> ((visibility(“default”)))</h2>
<p>该修饰用于修饰符号的可见性为默认对外<strong>可见</strong>。意思是通过该符号修饰的函数可以在 so 文件外访问到。</p>
<p>func.cpp:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">__attribute__ ((<span class="built_in">visibility</span>(<span class="string">&quot;default&quot;</span>))) <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main.cpp:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func1</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@└────&gt; g++ func.cpp --shared -fPIC -o libfunc.so</span><br><span class="line">@└────&gt; g++ main.cpp -L./ -lfunc</span><br></pre></td></tr></table></figure>
<p>之后发现是可以编译成功的。因为该符号是可见的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@└────&gt; nm libfunc.so | grep func</span><br><span class="line">0000000000001179 T _Z5func1i</span><br></pre></td></tr></table></figure>
<p>大写的 T 表示定义在 text 段，并且可被外部引用。如果你是通过编译 .o 文件再链接为 .so 文件的，还可以使用 readelf -s 查看 .o 文件的可见性.</p>
<h2 id="attribute-visibility-“hidden”"><strong>attribute</strong> ((visibility(“hidden”)))</h2>
<p>该修饰用于修饰符号的可见性为默认对外<strong>不可见</strong>。意思是通过该符号修饰的函数不可以在 so 文件外访问到,只能在 so 文件内部访问到。</p>
<p>func.cpp:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">__attribute__ ((<span class="built_in">visibility</span>(<span class="string">&quot;hidden&quot;</span>))) <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main.cpp:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func2</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@└────&gt; g++ func.cpp --shared -fPIC -o libfunc.so</span><br><span class="line">@└────&gt; g++ main.cpp -L./ -lfunc</span><br><span class="line">/usr/bin/ld: /tmp/cc7GABC5.o: <span class="keyword">in</span> <span class="keyword">function</span> `main<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">fstream.cpp:(.text+0xe): undefined reference to `func2(int)&#x27;</span></span><br><span class="line">collect2: error: ld returned 1 <span class="built_in">exit</span> status</span><br></pre></td></tr></table></figure>
<p>之后发现是可以编译失败,因为符号不可见.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@└────&gt; nm libfunc.so | grep func</span><br><span class="line">00000000000011ef T _Z5func2i</span><br></pre></td></tr></table></figure>
<h2 id="其他">其他</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__attribute__ ((visibility(&quot;internal&quot;)))</span><br><span class="line">__attribute__ ((visibility(&quot;protected&quot;)))</span><br></pre></td></tr></table></figure>
<p>上述两种一样是用于修饰符号, internal 对外不可见，而 protected 对外可见。<br>
此外，在编译 so 文件时可以通过指定 <code>-fvisibility=xxx</code> 来指定默认的没有给出修饰的符号属性。<br>
如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@└────&gt; gcc -fPIC -shared -o libtest.so -fvisibility=hidden test.c</span><br></pre></td></tr></table></figure>
<p>这样在 test.c 中没用经过修饰的符号对外都不可见，而修饰为 default 的依旧对外可见。</p>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp vector.push_back()时间复杂度证明</title>
    <url>/20230425104700_472535379/</url>
    <content><![CDATA[<p>vector 是 cpp 中常用的一种容器，是一种可以动态扩容的数组。他在每次插入的时候，当它的 capacity 不满足要求的时候，会重新申请一块两倍的内存，把之前的内容复制过来。在这种情况下，复制的时间复杂度为 $O(n)$。如果不涉及扩容，那么它只修改一个元素的内存，时间复杂度为 $O(1)$。</p>
<p>也就是说，它扩容的时机为，容器大小达到以下时：</p>
<blockquote>
<p>1 2 4 8 16 32 64 128 256 512 1024 2048 4096 8192 16384 32768 65536 …</p>
</blockquote>
<p>则每次插入代价设为 $c_i$，则<br>
$$<br>
c_i = \begin{cases}<br>
i    &amp; i 为 2 的幂\<br>
1     &amp; others \<br>
\end{cases}<br>
$$<br>
那么则有：<br>
$$<br>
\begin{aligned}<br>
\sum_{i = 0}^nc_i &amp;\le n + \sum_{j = 0}^{\lfloor log_2n \rfloor}2^j \<br>
&amp;\le n + 2n\<br>
&amp;\le 3n<br>
\end{aligned}<br>
$$<br>
因为共有 $n$ 次插入，所以总时间复杂度为 $O(3n)$，均摊下来平均时间复杂度为 $O(3)$。</p>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp11简单线程池</title>
    <url>/20230503112818_1492199803/</url>
    <content><![CDATA[<h2 id="线程池">线程池</h2>
<p>为什么需要线程池？因为频繁的创建和销毁线程，都涉及系统调用。频繁的系统调用涉及到用户态和内核态之间的切换，开销大。线程池的作用就是先把线程创建好，有活干就让线程去干活，没活线程就阻塞着。这样不需要频繁创建销毁线程，提升效率。除此之外，还可以防止过分调度。</p>
<h2 id="图解">图解</h2>
<ol>
<li>空闲时</li>
</ol>
<p><img src="/20230503112818_1492199803/1.png" alt="1"></p>
<ol start="2">
<li>有空闲线程时来任务，将任务加入到任务队列中，并唤醒一个线程。唤醒后线程拿到任务，把任务从任务队列中移出，并执行。</li>
</ol>
<p><img src="/20230503112818_1492199803/2.png" alt="2"></p>
<ol start="3">
<li>在没有空闲线程时来任务，任务排队。</li>
</ol>
<p><img src="/20230503112818_1492199803/3.png" alt="3"></p>
<h2 id="代码">代码</h2>
<p><a href="http://main.cc">main.cc</a>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;thread_pool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex g_screen_mutex; <span class="comment">// 向终端打印信息的锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(g_screen_mutex)</span></span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;===============================================================&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;|       testFunc() at thread [ &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;] output [&quot;</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&quot;]    |&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;===============================================================&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  thread_pool thread_pool;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span> ; i++) &#123; <span class="comment">// 往里面插入 5 个任务</span></span><br><span class="line">    thread_pool.<span class="built_in">add_task</span>(testFunc);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">getchar</span>(); <span class="comment">// 等待，不要让主进程退出</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>thread_pool.h:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _THREAD_POOL_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _THREAD_POOL_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">thread_pool</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 定义为一个函数类型，返回值为 void，没有入参</span></span><br><span class="line">  <span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>()&gt; <span class="type">task_t</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">thread_pool</span>(<span class="type">int</span> init_size = <span class="number">3</span>);</span><br><span class="line">  ~<span class="built_in">thread_pool</span>();</span><br><span class="line">  <span class="comment">// 停止线程池</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// 向线程池加入任务</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add_task</span><span class="params">(<span class="type">const</span> <span class="type">task_t</span>&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">thread_pool</span>(<span class="type">const</span> thread_pool&amp;) = <span class="keyword">delete</span>; <span class="comment">// 禁止复制拷贝</span></span><br><span class="line">  <span class="type">const</span> thread_pool&amp; <span class="keyword">operator</span>=(<span class="type">const</span> thread_pool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="comment">// 线程池启动函数</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// 每个线程的循环函数</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">thread_loop</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// 从线程池里拿一个线程</span></span><br><span class="line">  <span class="function"><span class="type">task_t</span> <span class="title">take</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> init_threads_size_; <span class="comment">// 初始线程数量</span></span><br><span class="line">  std::vector&lt;std::thread*&gt; threads_; <span class="comment">// 已经创建的线程列表</span></span><br><span class="line">  std::queue&lt;<span class="type">task_t</span>&gt; tasks_; <span class="comment">// 待执行任务列表</span></span><br><span class="line">  std::mutex mutex_; <span class="comment">// 操作线程池共有变量之前先上锁</span></span><br><span class="line">  std::condition_variable wake_cond_; <span class="comment">// 唤醒线程的条件</span></span><br><span class="line">  <span class="type">bool</span> is_started_; <span class="comment">// 线程池是否已经启动</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>thread_pool.cc:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;thread_pool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">thread_pool::<span class="built_in">thread_pool</span>(<span class="type">int</span> init_size)</span><br><span class="line">    : <span class="built_in">init_threads_size_</span>(init_size), <span class="built_in">mutex_</span>(), <span class="built_in">wake_cond_</span>(), <span class="built_in">is_started_</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">  <span class="built_in">start</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">thread_pool::~<span class="built_in">thread_pool</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (is_started_) &#123;</span><br><span class="line">    <span class="built_in">stop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_pool::start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(threads_.<span class="built_in">empty</span>());</span><br><span class="line">  is_started_ = <span class="literal">true</span>;</span><br><span class="line">  threads_.<span class="built_in">reserve</span>(init_threads_size_);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; init_threads_size_; ++i) &#123;</span><br><span class="line">    <span class="comment">// 非静态成员函数则需要传递 this 指针作为第一个参数</span></span><br><span class="line">    threads_.<span class="built_in">push_back</span>(<span class="keyword">new</span> std::<span class="built_in">thread</span>(std::<span class="built_in">bind</span>(&amp;thread_pool::thread_loop, <span class="keyword">this</span>)));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_pool::stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;thread_pool::stop() stop.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>; <span class="comment">// 只有 unique_lock 才能和 condition_variable 配合使用</span></span><br><span class="line">    is_started_ = <span class="literal">false</span>;</span><br><span class="line">    wake_cond_.<span class="built_in">notify_all</span>(); <span class="comment">// 销毁前唤醒所有线程</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;thread_pool::stop() notifyAll().&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> thread : threads_) &#123;</span><br><span class="line">    thread-&gt;<span class="built_in">join</span>(); <span class="comment">// 销毁之前需要等待所有线程完成</span></span><br><span class="line">    <span class="keyword">delete</span> thread;</span><br><span class="line">  &#125;</span><br><span class="line">  threads_.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_pool::thread_loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;thread_pool::threadLoop() tid : &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; start.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">while</span> (is_started_) &#123;</span><br><span class="line">    <span class="type">task_t</span> task = <span class="built_in">take</span>(); <span class="comment">// 如果没有拿到会阻塞在这里</span></span><br><span class="line">    <span class="keyword">if</span> (task) &#123;</span><br><span class="line">      <span class="built_in">task</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;thread_pool::threadLoop() tid : &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; exit.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_pool::add_task</span><span class="params">(<span class="type">const</span> <span class="type">task_t</span>&amp; task)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">  tasks_.<span class="built_in">push</span>(task);</span><br><span class="line">  wake_cond_.<span class="built_in">notify_one</span>(); <span class="comment">// 只唤醒一个线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">thread_pool::<span class="type">task_t</span> <span class="title">thread_pool::take</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">  <span class="comment">// 使用 while 循环，防止假唤醒</span></span><br><span class="line">  <span class="keyword">while</span> (tasks_.<span class="built_in">empty</span>() &amp;&amp; is_started_) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;thread_pool::take() tid : &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; wait.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    wake_cond_.<span class="built_in">wait</span>(lock); <span class="comment">// 如果没任务的话线程会阻塞在这里</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;thread_pool::take() tid : &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; wakeup.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="type">task_t</span> task;</span><br><span class="line">  <span class="type">size_t</span> size = tasks_.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (!tasks_.<span class="built_in">empty</span>() &amp;&amp; is_started_) &#123;</span><br><span class="line">    task = tasks_.<span class="built_in">front</span>(); <span class="comment">// 拿出队列中第一个任务</span></span><br><span class="line">    tasks_.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="built_in">assert</span>(size - <span class="number">1</span> == tasks_.<span class="built_in">size</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (task != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;thread_pool::take() tid : &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; took a task!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@└────&gt; # g++ main.cc thread_pool.cc -lpthread</span><br><span class="line"></span><br><span class="line">@└────&gt; # ./a.out </span><br><span class="line">thread_pool::threadLoop() tid : 139841310938880 start.</span><br><span class="line">thread_pool::take() tid : 139841310938880 wakeup.</span><br><span class="line">thread_pool::take() tid : 139841310938880 took a task!</span><br><span class="line">thread_pool::threadLoop() tid : 139841302546176 start.</span><br><span class="line">thread_pool::take() tid : 139841302546176 wakeup.</span><br><span class="line">thread_pool::take() tid : 139841302546176 took a task!</span><br><span class="line">thread_pool::threadLoop() tid : 139841294153472 start.</span><br><span class="line">thread_pool::take() tid : 139841294153472 wakeup.</span><br><span class="line">thread_pool::take() tid : 139841294153472 took a task!</span><br><span class="line">===============================================================</span><br><span class="line">|       testFunc() at thread [ 139841310938880] output [0]    |</span><br><span class="line">===============================================================</span><br><span class="line">thread_pool::take() tid : 139841310938880 wakeup.</span><br><span class="line">thread_pool::take() tid : 139841310938880 took a task!</span><br><span class="line">===============================================================</span><br><span class="line">|       testFunc() at thread [ 139841302546176] output [0]    |</span><br><span class="line">===============================================================</span><br><span class="line">thread_pool::take() tid : 139841302546176 wakeup.</span><br><span class="line">thread_pool::take() tid : 139841302546176 took a task!</span><br><span class="line">===============================================================</span><br><span class="line">|       testFunc() at thread [ 139841294153472] output [0]    |</span><br><span class="line">===============================================================</span><br><span class="line">thread_pool::take() tid : 139841294153472 wait.</span><br><span class="line">===============================================================</span><br><span class="line">|       testFunc() at thread [ 139841310938880] output [0]    |</span><br><span class="line">===============================================================</span><br><span class="line">thread_pool::take() tid : 139841310938880 wait.</span><br><span class="line">===============================================================</span><br><span class="line">|       testFunc() at thread [ 139841302546176] output [0]    |</span><br><span class="line">===============================================================</span><br><span class="line">thread_pool::take() tid : 139841302546176 wait.</span><br><span class="line">(键入回车)</span><br><span class="line">thread_pool::stop() stop.</span><br><span class="line">thread_pool::stop() notifyAll().</span><br><span class="line">thread_pool::take() tid : 139841294153472 wakeup.</span><br><span class="line">thread_pool::threadLoop() tid : 139841294153472 exit.</span><br><span class="line">thread_pool::take() tid : 139841310938880 wakeup.</span><br><span class="line">thread_pool::threadLoop() tid : 139841310938880 exit.</span><br><span class="line">thread_pool::take() tid : 139841302546176 wakeup.</span><br><span class="line">thread_pool::threadLoop() tid : 139841302546176 exit.</span><br></pre></td></tr></table></figure>
<p>从结果可以看出，确实是三个线程在执行 5 个任务，并且线程执行完成后并没有销毁。这里的函数都是 void() 类型，即返回值为 void，并且没有参数，不具备泛用性。如果需要线程执行其他类型函数则需要包装函数类。</p>
<p>通用线程池请见：<a href="/20230504192009_3746130536/" title="cpp11通用线程池">通用线程池</a></p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>concurrent-programming</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp11通用线程池</title>
    <url>/20230504192009_3746130536/</url>
    <content><![CDATA[<h2 id="通用线程池">通用线程池</h2>
<p>通用线程池和简单线程池的区别就是，简单线程池对交给线程的任务函数入参和返回值有类型要求，而通用的没有。在本文中，将讲述和简单线程池提交函数的区别。本文需要一定的 C++ 模板泛型基础。</p>
<h2 id="和简单线程池的区别">和简单线程池的区别</h2>
<h3 id="简单线程池">简单线程池</h3>
<p>在简单线程池中，增加任务给线程池的函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>()&gt; <span class="type">task_t</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_pool::add_task</span><span class="params">(<span class="type">const</span> <span class="type">task_t</span>&amp; task)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">  tasks_.<span class="built_in">push</span>(task);</span><br><span class="line">  wake_cond_.<span class="built_in">notify_one</span>(); <span class="comment">// 只唤醒一个线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，task_t 就是我们能向线程池提交的函数类型。它是一个 function 类型，返回值为 void，并且没有入参。那如果我们想提交一个返回值为 int，也有 int 作为入参的函数这样就行不通了。</p>
<h3 id="通用线程池-2">通用线程池</h3>
<p>于是我们将它略微改进下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向线程池加入任务</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add_task</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> -&gt; std::future&lt;<span class="title">decltype</span><span class="params">(f(args...))</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> return_type = <span class="keyword">decltype</span>(<span class="built_in">f</span>(args...));</span><br><span class="line">  <span class="keyword">auto</span> task_ptr = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">return_type</span>()&gt;&gt;( <span class="comment">// 因为 packaged_task 无法拷贝构造，所以用 make_shared</span></span><br><span class="line">      std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  std::future&lt;return_type&gt; res = task_ptr-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    tasks_.<span class="built_in">emplace</span>([task_ptr]() &#123;</span><br><span class="line">      (*task_ptr)();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  wake_cond_.<span class="built_in">notify_one</span>();</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数有两个模板参数，第一个模板参数 F 代表的是一个函数，第二个模板参数 Args 代表的是这个函数执行时的参数。该函数的返回值是一个 std::future 对象，可以通过 future.get() 来获得执行函数的返回值。具体用法可以见 <a href="/20230326005424_31584/" title="cpp多线程之std::future">future用法</a>。</p>
<p>因为不知道函数返回值是什么类型，所以需要用到 decltype，在编译时自动确定调用函数的返回值类型。届时从 future 对象中 get 到的数据类型就可以拿到了。在本函数中，先定义了一个指向 packaged_task 的智能指针（packaged_task 本质是个仿函数），之后把这个仿函数包装一层，让它变为一个<strong>返回值为 return_type，并且没有入参的函数</strong>。之所以用指针，是因为 packaged_task 无法进行拷贝构造，所以下面没法调用。之后在放入执行线程队列前，用 lambda 表达式封装它，让它变为<strong>返回值为 void 的函数</strong>，把它放到执行线程的队列中。最后该函数返回 packaged_task 对应的 future 对象，方便调用者拿到返回值。</p>
<p>值得注意的是，该函数因为是有模板参数，所以这个实现应该放在头文件中。原因详见：<a href="/20230502100634_2223083831/" title="cpp模板类定义放在头文件原因">cpp模板类定义放在头文件原因</a></p>
<h2 id="完整代码">完整代码</h2>
<p>以下代码是对 <a href="/20230503112818_1492199803/" title="cpp11简单线程池">cpp11简单线程池</a> 基础上做的改进：</p>
<p><a href="http://main.cc">main.cc</a>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;thread_pool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex g_screen_mutex; <span class="comment">// 向终端打印信息的锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">  std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(g_screen_mutex)</span></span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;test() at thread [ &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;] output [&quot;</span> &lt;&lt; a + b &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  thread_pool thread_pool;</span><br><span class="line">  std::vector&lt;std::future&lt;<span class="type">int</span>&gt;&gt; results;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span> ; i++) &#123;</span><br><span class="line">    <span class="keyword">auto</span> fu = thread_pool.<span class="built_in">add_task</span>(test, i, <span class="number">2</span>);</span><br><span class="line">    results.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(fu));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">getchar</span>(); <span class="comment">// 等待，不要让主进程退出</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    std::cout&lt;&lt; <span class="string">&quot;result of number &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; :&quot;</span> &lt;&lt; results[i].<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>thread_pool.h：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _THREAD_POOL_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _THREAD_POOL_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">thread_pool</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 定义为一个函数类型，返回值为 void，没有入参</span></span><br><span class="line">  <span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>()&gt; <span class="type">task_t</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">thread_pool</span>(<span class="type">int</span> init_size = <span class="number">3</span>);</span><br><span class="line">  ~<span class="built_in">thread_pool</span>();</span><br><span class="line">  <span class="comment">// 停止线程池</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// 向线程池加入任务</span></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">  <span class="keyword">auto</span> <span class="title">add_task</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> -&gt; std::future&lt;<span class="title">decltype</span><span class="params">(f(args...))</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> return_type = <span class="keyword">decltype</span>(<span class="built_in">f</span>(args...));</span><br><span class="line">    <span class="keyword">auto</span> task_ptr = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">return_type</span>()&gt;&gt;(</span><br><span class="line">        std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...)</span><br><span class="line">    );</span><br><span class="line">    std::future&lt;return_type&gt; res = task_ptr-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">      tasks_.<span class="built_in">emplace</span>([task_ptr]() &#123;</span><br><span class="line">        (*task_ptr)();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    wake_cond_.<span class="built_in">notify_one</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">thread_pool</span>(<span class="type">const</span> thread_pool&amp;) = <span class="keyword">delete</span>; <span class="comment">// 禁止复制拷贝</span></span><br><span class="line">  <span class="type">const</span> thread_pool&amp; <span class="keyword">operator</span>=(<span class="type">const</span> thread_pool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="comment">// 线程池启动函数</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// 每个线程的循环函数</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">thread_loop</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// 从线程池里拿一个线程</span></span><br><span class="line">  <span class="function"><span class="type">task_t</span> <span class="title">take</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> init_threads_size_; <span class="comment">// 初始线程数量</span></span><br><span class="line">  std::vector&lt;std::thread*&gt; threads_; <span class="comment">// 已经创建的线程列表</span></span><br><span class="line">  std::queue&lt;<span class="type">task_t</span>&gt; tasks_; <span class="comment">// 待执行任务列表</span></span><br><span class="line">  std::mutex mutex_; <span class="comment">// 操作线程池共有变量之前先上锁</span></span><br><span class="line">  std::condition_variable wake_cond_; <span class="comment">// 唤醒线程的条件</span></span><br><span class="line">  <span class="type">bool</span> is_started_; <span class="comment">// 线程池是否已经启动</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>thread_pool.cc：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;thread_pool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">thread_pool::<span class="built_in">thread_pool</span>(<span class="type">int</span> init_size)</span><br><span class="line">    : <span class="built_in">init_threads_size_</span>(init_size), <span class="built_in">mutex_</span>(), <span class="built_in">wake_cond_</span>(), <span class="built_in">is_started_</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">  <span class="built_in">start</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">thread_pool::~<span class="built_in">thread_pool</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (is_started_) &#123;</span><br><span class="line">    <span class="built_in">stop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_pool::start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(threads_.<span class="built_in">empty</span>());</span><br><span class="line">  is_started_ = <span class="literal">true</span>;</span><br><span class="line">  threads_.<span class="built_in">reserve</span>(init_threads_size_);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; init_threads_size_; ++i) &#123;</span><br><span class="line">    threads_.<span class="built_in">push_back</span>(<span class="keyword">new</span> std::<span class="built_in">thread</span>(std::<span class="built_in">bind</span>(&amp;thread_pool::thread_loop, <span class="keyword">this</span>)));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_pool::stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;thread_pool::stop() stop.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    is_started_ = <span class="literal">false</span>;</span><br><span class="line">    wake_cond_.<span class="built_in">notify_all</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;thread_pool::stop() notifyAll().&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> thread : threads_) &#123;</span><br><span class="line">    thread-&gt;<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">delete</span> thread;</span><br><span class="line">  &#125;</span><br><span class="line">  threads_.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_pool::thread_loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;thread_pool::threadLoop() tid : &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; start.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">while</span> (is_started_) &#123;</span><br><span class="line">    <span class="type">task_t</span> task = <span class="built_in">take</span>();</span><br><span class="line">    <span class="keyword">if</span> (task) &#123;</span><br><span class="line">      <span class="built_in">task</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;thread_pool::threadLoop() tid : &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; exit.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">thread_pool::<span class="type">task_t</span> <span class="title">thread_pool::take</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">  <span class="comment">// 使用 while 循环，防止假唤醒</span></span><br><span class="line">  <span class="keyword">while</span> (tasks_.<span class="built_in">empty</span>() &amp;&amp; is_started_) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;thread_pool::take() tid : &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; wait.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    wake_cond_.<span class="built_in">wait</span>(lock);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;thread_pool::take() tid : &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; wakeup.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="type">task_t</span> task;</span><br><span class="line">  <span class="type">size_t</span> size = tasks_.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (!tasks_.<span class="built_in">empty</span>() &amp;&amp; is_started_) &#123;</span><br><span class="line">    task = tasks_.<span class="built_in">front</span>();</span><br><span class="line">    tasks_.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="built_in">assert</span>(size - <span class="number">1</span> == tasks_.<span class="built_in">size</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (task != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;thread_pool::take() tid : &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; took a task!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@└────&gt; # ./test.out </span><br><span class="line">thread_pool::threadLoop() tid : 139812637472512 start.</span><br><span class="line">thread_pool::take() tid : 139812637472512 wakeup.</span><br><span class="line">thread_pool::take() tid : 139812637472512 took a task!</span><br><span class="line">thread_pool::threadLoop() tid : 139812629079808 start.</span><br><span class="line">thread_pool::take() tid : 139812629079808 wakeup.</span><br><span class="line">thread_pool::take() tid : 139812629079808 took a task!</span><br><span class="line">thread_pool::threadLoop() tid : 139812620687104 start.</span><br><span class="line">thread_pool::take() tid : 139812620687104 wakeup.</span><br><span class="line">thread_pool::take() tid : 139812620687104 took a task!</span><br><span class="line">test() at thread [ 139812637472512] output [2]</span><br><span class="line">thread_pool::take() tid : 139812637472512 wakeup.</span><br><span class="line">thread_pool::take() tid : 139812637472512 took a task!</span><br><span class="line">test() at thread [ 139812629079808] output [3]</span><br><span class="line">thread_pool::take() tid : 139812629079808 wakeup.</span><br><span class="line">thread_pool::take() tid : 139812629079808 took a task!</span><br><span class="line">test() at thread [ 139812620687104] output [4]</span><br><span class="line">thread_pool::take() tid : 139812620687104 wait.</span><br><span class="line">test() at thread [ 139812637472512] output [5]</span><br><span class="line">thread_pool::take() tid : 139812637472512 wait.</span><br><span class="line">test() at thread [ 139812629079808] output [6]</span><br><span class="line">thread_pool::take() tid : 139812629079808 wait.</span><br><span class="line">(键入回车)</span><br><span class="line">result of number 0 :2</span><br><span class="line">result of number 1 :3</span><br><span class="line">result of number 2 :4</span><br><span class="line">result of number 3 :5</span><br><span class="line">result of number 4 :6</span><br><span class="line">thread_pool::stop() stop.</span><br><span class="line">thread_pool::stop() notifyAll().</span><br><span class="line">thread_pool::take() tid : 139812620687104 wakeup.</span><br><span class="line">thread_pool::threadLoop() tid : 139812620687104 exit.</span><br><span class="line">thread_pool::take() tid : 139812637472512 wakeup.</span><br><span class="line">thread_pool::threadLoop() tid : 139812637472512 exit.</span><br><span class="line">thread_pool::take() tid : 139812629079808 wakeup.</span><br><span class="line">thread_pool::threadLoop() tid : 139812629079808 exit.</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cpp</category>
        <category>concurrent-programming</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp不同种类构造函数</title>
    <url>/20221118151625_3415377200/</url>
    <content><![CDATA[<h1>cpp 的构造函数种类</h1>
<ol>
<li>构造函数：生成一个新的对象。</li>
<li>拷贝构造函数：参数是 const T&amp; x，用于拷贝。</li>
<li>赋值构造函数：这个严格意义来说不是构造函数，是赋值运算符 = 的重载。初始化的时候不会调用这个函数！</li>
<li>移动构造函数：参数是 T &amp;&amp;x，用于移动构造，提升效率。</li>
</ol>
<h1>代码示例</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Integer</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* m_ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//  普通构造函数</span></span><br><span class="line">    <span class="built_in">Integer</span>(<span class="type">int</span> value) : <span class="built_in">m_ptr</span>(<span class="keyword">new</span> <span class="built_in">int</span>(value)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Integer</span>(<span class="type">const</span> Integer&amp; source) : <span class="built_in">m_ptr</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*source.m_ptr)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;copy constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  移动构造函数</span></span><br><span class="line">    <span class="built_in">Integer</span>(Integer&amp;&amp; source) : <span class="built_in">m_ptr</span>(source.m_ptr) &#123;</span><br><span class="line">        source.m_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;move constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  赋值运算符重载</span></span><br><span class="line">    Integer&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Integer&amp; source) &#123;</span><br><span class="line">        m_ptr = <span class="keyword">new</span> <span class="built_in">int</span>(*source.m_ptr);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;copy assignment constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Integer</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;destructor:&quot;</span> &lt;&lt; <span class="built_in">GetValue</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span> m_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetValue</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_ptr) &#123;</span><br><span class="line">            <span class="keyword">return</span> *m_ptr;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Integer <span class="title">getNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Integer <span class="title">a</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">Integer <span class="title">a</span><span class="params">(getNum())</span></span>; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a.<span class="built_in">GetValue</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-----------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="function">Integer <span class="title">temp</span><span class="params">(<span class="number">10000</span>)</span></span>;</span><br><span class="line">    <span class="function">Integer <span class="title">b</span><span class="params">(temp)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b=&quot;</span> &lt;&lt; b.<span class="built_in">GetValue</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-----------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Integer c = b;</span><br><span class="line">    c = a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c=&quot;</span> &lt;&lt; c.<span class="built_in">GetValue</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-----------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在编译的时候一定要指定编译选项 --no-elide-constructors，否则会被编译器优化！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@└────&gt; # ./a.out </span><br><span class="line">constructor</span><br><span class="line">move constructor</span><br><span class="line">destructor:-1</span><br><span class="line">move constructor</span><br><span class="line">destructor:-1</span><br><span class="line">a=100</span><br><span class="line">-----------------</span><br><span class="line">constructor</span><br><span class="line">copy constructor</span><br><span class="line">b=10000</span><br><span class="line">-----------------</span><br><span class="line">copy constructor</span><br><span class="line">copy assignment constructor</span><br><span class="line">c=100</span><br><span class="line">-----------------</span><br><span class="line">destructor:100</span><br><span class="line">destructor:10000</span><br><span class="line">destructor:10000</span><br><span class="line">destructor:100</span><br></pre></td></tr></table></figure>
<h1>分析</h1>
<h2 id="a">a</h2>
<ol>
<li>第一个 constructor，是在 getNum() 中首句 Integer a(100) 所打印的，调用默认的构造函数。</li>
<li>第二个 move constructor 是因为 return a 的时候，这个 a 是个右值，作为 main 函数 getNum() 的返回值，而调用的移动构造函数，将 getNum() 函数内的返回值移动构造给 main 函数接收 getNum() 的对象。</li>
<li>第三个 destructor 是析构 getNum() 中的对象 a。</li>
<li>第四个 move constructor 是因为 Integer a(右值)，所以调用移动构造函数。</li>
<li>第五个 destructor 是析构 Integer a(右值) 中的右值而显示的。</li>
</ol>
<hr>
<h2 id="b">b</h2>
<ol>
<li>第一个 constructor 是 Integer temp(10000); 调用的默认构造函数。</li>
<li>第二个 copy constructor 是 Integer b(temp); 调用的拷贝构造函数，将 temp 拷贝给 b；</li>
</ol>
<hr>
<h2 id="c">c</h2>
<ol>
<li>第一个 copy constructor 是 Integer c = b; 调用的拷贝构造函数，可以看到此处并没有调用拷贝赋值运算符，因为这是在初始化！</li>
<li>第二个 copy assignment constructor 是 c = a 调用的才是拷贝赋值运算符。</li>
</ol>
<p>可以看到，初始化的时候不会调用 拷贝赋值运算符！！！</p>
<h2 id="析构">析构</h2>
<p>最后的四个 destructor 是析构。根据规则，先构造的后析构，后调用的先析构。析构顺序：c = 100，b = 10000，temp = 10000，a = 100。</p>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp中auto和decltype区别</title>
    <url>/20230501161003_1606969208/</url>
    <content><![CDATA[<h2 id="auto">auto</h2>
<p>C++11 中，使用 auto 关键字来进行自动类型推导。语法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> name = value;</span><br></pre></td></tr></table></figure>
<p>其中，name 是变量的名字。value 是变量的初始值。其中 auto 是一个占位符，会在<strong>编译期间</strong>由编译器推导出来。而且由 auto 推导的变量必须<strong>初始化</strong>，因为是占位符的原因，不能用作声明。</p>
<p>限制：</p>
<ol>
<li>auto 不能在函数的参数中使用。</li>
</ol>
<blockquote>
<p>我们在定义函数的时候只是对参数进行了声明，指明了参数的类型，但并没有给它赋值，只有在实际调用函数的时候才会给参数赋值。而 auto 要求必须对变量进行初始化。</p>
</blockquote>
<ol start="2">
<li>auto 不能作用于类的非静态成员变量（即没有 static 关键字修饰的成员变量）中。</li>
<li>auto 关键字不能定义数组，比如下面的例子就是错误的：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> a[] = <span class="string">&quot;abcdefg&quot;</span>;  </span><br><span class="line"><span class="keyword">auto</span> b[] = a; <span class="comment">// a 为数组，所以不能使用 auto</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">error: ‘b’ declared as array of ‘auto’</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>auto 不能作用于模板参数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A&lt;<span class="type">int</span>&gt; C1;</span><br><span class="line">    A&lt;<span class="keyword">auto</span>&gt; C2 = C1;  <span class="comment">// 错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">error: invalid use of ‘auto’</span><br></pre></td></tr></table></figure>
<h2 id="decltype">decltype</h2>
<p>decltype 是 C++11 新增的一个关键字，它和 auto 的功能一样，都用来在<strong>编译时期</strong>进行自动类型推导。<br>
auto 和 decltype 关键字都可以自动推导出变量的类型，但它们的用法是有区别的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> varname = value;</span><br><span class="line"><span class="keyword">decltype</span>(exp) varname = value;</span><br><span class="line"><span class="keyword">decltype</span>(exp) varname;</span><br></pre></td></tr></table></figure>
<p>其中，varname 表示变量名，value 表示赋给变量的值，exp 表示一个表达式。</p>
<p>auto 根据<strong>等号右边的初始值 value 推导出变量的类型</strong>，而 decltype 根据 <strong>exp 表达式推导出变量的类型</strong>，跟等号右边的 value 没有关系。</p>
<p>另外，auto 要求变量必须初始化，而 decltype 不要求。auto 是根据变量的初始值来推导出变量类型的，如果不初始化，变量的类型也就无法推导了。此外，我们必须要保证 exp 的结果是有类型的，不能是 void。例如，当 exp 调用一个返回值类型为 void 的函数时，exp 的结果也是 void 类型，此时就会导致编译错误。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">error: variable or field ‘b’ declared void</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ol>
<li>如果 exp 是一个不被括号包围的表达式，或者是类成员访问表达式，或者是单独的变量，那么 decltype(exp) 的类型就和 exp 一致。</li>
<li>如果 exp 是函数调用，那么 decltype(exp) 的类型就和函数返回值的类型一致。</li>
<li>如果 exp 是一个左值，或者被括号包围，那么 decltype(exp) 的类型就是 exp 的<strong>引用</strong>。假设 exp 的类型为 T，那么 decltype(exp) 的类型就是 T&amp;。</li>
<li>decltype 如果是函数调用，因为是在编译时确定，和 sizeof 一样，不会调用一次函数。</li>
</ol>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp之lock_guard和unique_lock</title>
    <url>/20230416004015_2260001540/</url>
    <content><![CDATA[<h1>锁</h1>
<p>锁是用来防止不同线程访问同一个共享资源时发生数据竞争风险，保证访问的先后顺序而达到数据的一致性访问。本文介绍的 lock_guard 和 unique_lock，都是对 std::mutex 进行封装，实现 RAII 的效果。这两种锁本质差不多，而 unique_lock 的功能比 lock_guard 多一些。</p>
<h1>lock_guard</h1>
<p>lock_guard 用来管理一个 std::mutext 类型的对象，定义一个 lock_guard 对象同时调用构造函数，对 std::mutex 进行上锁，退出作用域时析构，从而进行解锁。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_name)</span></span>;</span><br></pre></td></tr></table></figure>
<p>特点如下：</p>
<ol>
<li>创建即加锁，退出作用域自动解锁，避免忘记解锁。</li>
<li>无需手工解锁。不能中途解锁。</li>
<li>无法复制。</li>
<li>并不管理 std::mutex 的生命周期，如果在作用域内的时候 std::mutex 被释放了，那就会出现空指针错误。</li>
</ol>
<p>使用示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> g_i = <span class="number">0</span>;</span><br><span class="line">std::mutex g_i_mutex;  </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safe_increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(g_i_mutex)</span></span>;</span><br><span class="line">    ++g_i;</span><br><span class="line">    std::cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; g_i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;start: &quot;</span> &lt;&lt; g_i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(safe_increment)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(safe_increment)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;end: &quot;</span> &lt;&lt; g_i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@└────&gt; # ./a.out </span><br><span class="line">start: 0</span><br><span class="line">140365627524864: 1</span><br><span class="line">140365619132160: 2</span><br><span class="line">end: 2</span><br></pre></td></tr></table></figure>
<h1>unique_lock</h1>
<p>虽然 lock_guard 挺好用的，但是有个很大的缺陷，在定义 lock_guard 的地方会调用构造函数加锁，在离开定义域的话 lock_guard 就会被销毁，调用析构函数解锁。这就产生了一个问题，如果这个定义域范围很大的话，那么锁的粒度就很大，很大程序上会影响效率。<br>
所以为了解决 lock_guard 锁的<strong>粒度过大</strong>的问题，unique_lock 就出现了。</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">详细说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>explicit unique_lock(mutex_type&amp; m);</code></td>
<td style="text-align:left">加锁</td>
<td style="text-align:left">新创建的 unique_lock 对象，管理 Mutex 对象 m，并尝试调用 m.lock() 对 Mutex 对象进行上锁，如果此时另外某个 unique_lock 对象已经管理了该 Mutex 对象 m，则当前线程将<strong>会被阻塞</strong>。</td>
</tr>
<tr>
<td style="text-align:left"><code>unique_lock(mutex_type&amp; m, try_to_lock_t tag);</code></td>
<td style="text-align:left">尝试加锁</td>
<td style="text-align:left">try-locking 初始化新创建的 unique_lock 对象，管理 Mutex 对象 m，并尝试调用 m.try_lock() 对 Mutex 对象进行上锁，但如果上锁不成功，并<strong>不会阻塞</strong>当前线程。</td>
</tr>
<tr>
<td style="text-align:left"><code>unique_lock(mutex_type&amp; m, defer_lock_t tag) noexcept;</code></td>
<td style="text-align:left">延迟加锁</td>
<td style="text-align:left">初始化新创建的 unique_lock 对象，管理 Mutex 对象 m，但是在初始化的时候并<strong>不锁住</strong> Mutex 对象。 m 应该是一个没有当前线程锁住的 Mutex 对象。</td>
</tr>
<tr>
<td style="text-align:left"><code>unique_lock(mutex_type&amp; m, adopt_lock_t tag);</code></td>
<td style="text-align:left">递归加锁</td>
<td style="text-align:left">初始化新创建的 unique_lock 对象管理 Mutex 对象 m， m 应该是一个<strong>已经被当前线程锁住</strong>的 Mutex 对象。(并且当前新创建的 unique_lock 对象拥有对锁(Lock)的所有权)。</td>
</tr>
</tbody>
</table>
<p>特点如下：</p>
<ol>
<li>创建时可以不锁定（通过指定第二个参数为 std::defer_lock），而在需要时再锁定。</li>
<li>可以随时加锁解锁（调用 lock 或者 unlock 成员函数）。</li>
<li>作用域规则同 lock_grard，析构的时候会判断当前锁的状态来决定是否解锁，如果当前状态已经是解锁状态了，那么就不会再次解锁，而如果当前状态是加锁状态，就会自动调用unique.unlock()来解锁。</li>
<li>不可复制，可移动</li>
<li>条件变量需要该类型的锁作为参数（此时必须使用 unique_lock）</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">condition_variable cv;</span><br><span class="line">cv.<span class="built_in">wait</span>(unique_lock);  <span class="comment">// 会做两件事1：使线程进入等待状态 2:unique_lock.unlock 把mtx给释放掉</span></span><br></pre></td></tr></table></figure>
<p>unique_lock 示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Box</span><span class="params">(<span class="type">int</span> num)</span> : num_things&#123;</span>num&#125; &#123;&#125;</span><br><span class="line">    <span class="type">int</span> num_things;</span><br><span class="line">    std::mutex m;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transfer</span><span class="params">(Box &amp;from, Box &amp;to, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(from.m, std::defer_lock)</span></span>;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock2</span><span class="params">(to.m, std::defer_lock)</span></span>;</span><br><span class="line">    std::<span class="built_in">lock</span>(lock1, lock2);</span><br><span class="line">    from.num_things -= num;</span><br><span class="line">    to.num_things += num; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Box <span class="title">box1</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="function">Box <span class="title">box2</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(transfer, std::ref(box1), std::ref(box2), <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(transfer, std::ref(box2), std::ref(box1), <span class="number">5</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;box1:&quot;</span> &lt;&lt; box1.num_things &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;box2:&quot;</span> &lt;&lt; box2.num_things &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@└────&gt; # ./a.out </span><br><span class="line">box1:95</span><br><span class="line">box2:55</span><br></pre></td></tr></table></figure>
<h1>总结</h1>
<p>unique_lock 内部会维护一个锁的状态，所以在效率上肯定会比 lock_guard 慢。所以在能使用 lock_guard 的情况下尽量优先使用 lock_guard。</p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>concurrent-programming</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp之make_shared与shared_ptr</title>
    <url>/20230414004940_59277/</url>
    <content><![CDATA[<h1>区别</h1>
<p>先来看一段代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>;</span><br><span class="line">std::shared_ptr&lt;A&gt; p1 = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line"><span class="function">std::shared_ptr&lt;A&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> A)</span></span>;</span><br></pre></td></tr></table></figure>
<p>他俩是有区别的，使用 make_shared 的方式只会申请一次内存，而使用 new 的方式要申请两次。<br>
shared_ptr 内部有一个计数器，会维护指向当前对象的指针个数。</p>
<ol>
<li>在使用 new 的方式申请的时候，先用 new 申请指向对象的内存，再申请 shared_ptr 中维护计数部分的内存，所以是两次申请。</li>
<li>用make_shared 的方式，是把指向对象部分和维护计数部分合在一起，一起申请，所以是一次申请。</li>
</ol>
<p>那这两种有什么影响呢？</p>
<h1>影响</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(std::shared_ptr&lt;Lhs&gt; &amp;lhs, std::shared_ptr&lt;Rhs&gt; &amp;rhs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">func</span>(std::<span class="built_in">shared_ptr</span>&lt;Lhs&gt;(<span class="keyword">new</span> <span class="built_in">Lhs</span>()), std::<span class="built_in">shared_ptr</span>&lt;Rhs&gt;(<span class="keyword">new</span> <span class="built_in">Rhs</span>()));</span><br></pre></td></tr></table></figure>
<p>C++ 允许在做<strong>参数运算</strong>的时候 <strong>打乱顺序</strong>，所以执行顺序可能为这样：</p>
<ol>
<li>new Lhs();</li>
<li>new Rhs();</li>
<li>shared_ptr<Lhs> 构造</Lhs></li>
<li>shared_ptr<Rhs> 构造</Rhs></li>
</ol>
<p>假设在步骤 2 中，因为内存不足抛出了异常。之后我们就丢失了 1 中申请的内存，因为 shared_ptr 还没有指向它，也就没有接受管理。有一种解决方案：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> lhs = std::<span class="built_in">shared_ptr</span>&lt;Lhs&gt;(<span class="keyword">new</span> <span class="built_in">Lhs</span>());</span><br><span class="line"><span class="keyword">auto</span> rhs = std::<span class="built_in">shared_ptr</span>&lt;Rhs&gt;(<span class="keyword">new</span> <span class="built_in">Rhs</span>());</span><br><span class="line"><span class="built_in">func</span>(lhs, rhs);</span><br></pre></td></tr></table></figure>
<p>这样不够优雅，所以诞生了 make_shared：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">func</span>(std::<span class="built_in">make_shared</span>&lt;Lhs&gt;(), std::<span class="built_in">make_shared</span>&lt;Rhs&gt;());</span><br></pre></td></tr></table></figure>
<h1>make_shared 的缺点</h1>
<p>因为 make_shared 是申请（控制块 + 数据块）一整块内存，所以也是一起释放。weak_ptr 可以无限期地保持控制块的存活。<br>
<img src="/20230414004940_59277/1.png" alt="使用 new 申请的 shared_ptr 内存分布"><br>
使用 new 申请的 shared_ptr 内存分布<br>
<img src="/20230414004940_59277/2.png" alt="使用 make_shared 申请的 shared_ptr 内存分布"><br>
使用 make_shared 申请的 shared_ptr 内存分布<br>
为什么 weak_ptr 的实例会使控制块保持活动状态？<br>
必须有一种方法让 weak_ptr 来确定托管对象是否仍然有效(例如for lock)。他们通过检查 shared_ptr 拥有托管对象的数量来实现这一点，该托管对象存储在控制块中。结果是控制块处于活动状态，直到 shared_ptr 计数和 weak_ptr 计数都达到 $0$，才会释放整个控制块和数据块。</p>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp之std::atomic</title>
    <url>/20221225154730_448578471/</url>
    <content><![CDATA[<h1>std::atomic</h1>
<p>原子类型是对数据的一种封装，可以防止数据竞争，达到同步多线程的内存访问的目的。对该变量的读写是原子的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>使用前需要包含头文件。该头文件中主要包含两个类：atomic 和 atomic_flag。本文主要讲解 std::atomic。</p>
<h2 id="构造函数和赋值">构造函数和赋值</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">atomic</span>() <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">atomic</span> <span class="params">(T val)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="built_in">atomic</span> (<span class="type">const</span> atomic&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">T <span class="keyword">operator</span>= (T val) <span class="keyword">noexcept</span>;</span><br><span class="line">T <span class="keyword">operator</span>= (T val) <span class="keyword">volatile</span> <span class="keyword">noexcept</span>;</span><br><span class="line">atomic&amp; <span class="keyword">operator</span>= (<span class="type">const</span> atomic&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">atomic&amp; <span class="keyword">operator</span>= (<span class="type">const</span> atomic&amp;) <span class="keyword">volatile</span> = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>构造一个未初始化的原子对象。</li>
<li>构造一个用 val 初始化的原子对象。</li>
<li>禁用拷贝构造函数，<strong>原子对象不可复制、移动</strong>。</li>
<li>可以赋值（val）。</li>
</ol>
<h2 id="memory-order">memory_order</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">memory_order</span> &#123;</span><br><span class="line">    memory_order_relaxed,</span><br><span class="line">    memory_order_consume,</span><br><span class="line">    memory_order_acquire,</span><br><span class="line">    memory_order_release,</span><br><span class="line">    memory_order_acq_rel,</span><br><span class="line">    memory_order_seq_cst</span><br><span class="line">&#125; memory_order;</span><br></pre></td></tr></table></figure>
<p>它们的目的是为了做线程间的同步，原理是在线程内限制变量操作的顺序：</p>
<ol>
<li>memory_order_relaxed：用于读写，不做任何限制。</li>
<li>memory_order_acquire：用于读，如果一个原子变量的 load 用了该选项，那么可以保证，<strong>在本线程内</strong>，该 load 语句<strong>之后的所有变量</strong>（不论是否原子变量）的读写语句，都实际在该 load 操作执行后执行。</li>
<li>memory_order_release：用于写，如果一个原子变量的 store 用了该选项，那么可以保证，<strong>在本线程内</strong>，该 store 语句<strong>之前的所有变量</strong>（不论是否原子变量）的读写语句，都实际在该 store 操作执行前执行。</li>
<li>memory_order_consume：用于读，如果一个原子变量的 load 用了该选项，那么可以保证，在本线程内，该 load 语句<strong>之后的所有依赖该变量的变量</strong>的读写语句，都实际在该 load 操作执行后执行。但是，它只保证与当前操作相关的数据依赖关系。从 2016 年后，所有编译器实现中，memory_order_consume 和 memory_order_acquire 完全一致。</li>
<li>memory_order_acq_rel：memory_order_acquire + memory_order_release</li>
<li>memory_order_seq_cst：sequence consistent，顺序一致，要求所有变量的读写执行顺序都和代码中的顺序一致。</li>
</ol>
<p>memory_order_acquire 和 memory_order_release 直观上就像一个栅栏：在调用处设置一个栅栏，acquire 是拦住代码中在它后边的变量读写操作，不让其跑到它前边；release则相反，不让前边的跑到后边。（cpu 提供 memory_barrier 或者 memory_fence 指令）关于为什么 cpu 会进行内存重排，请见<a href="/20230607171855_854612321/" title="内存模型与内存序">内存模型与内存序</a>。</p>
<h2 id="atomic-store">atomic::store()</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">store</span> <span class="params">(T val, memory_order sync = memory_order_seq_cst)</span> <span class="keyword">volatile</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">store</span> <span class="params">(T val, memory_order sync = memory_order_seq_cst)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>
<p>用 val 替换原子对象中的值。该操作是原子性的，通过 sync 指定内存顺序。sync 可选项见上文。</p>
<h2 id="atomic-load">atomic::load()</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">T <span class="title">load</span> <span class="params">(memory_order sync = memory_order_seq_cst)</span> <span class="type">const</span> <span class="keyword">volatile</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">T <span class="title">load</span> <span class="params">(memory_order sync = memory_order_seq_cst)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回原子对象中的值。该操作为原子性。</p>
<h2 id="atomic-exchange">atomic::exchange</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">T <span class="title">exchange</span> <span class="params">(T val, memory_order sync = memory_order_seq_cst)</span> <span class="keyword">volatile</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">T <span class="title">exchange</span> <span class="params">(T val, memory_order sync = memory_order_seq_cst)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>
<p>用 val 替换原子对象中的值，并返回替换前的值。操作为原子性。整个过程完成之前，其他线程无法访问。</p>
<h2 id="atomic-compare-exchange-weak">atomic::compare_exchange_weak</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare_exchange_weak</span> <span class="params">(T &amp;expected, T val, memory_order sync = memory_order_seq_cst)</span> <span class="keyword">volatile</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare_exchange_weak</span> <span class="params">(T &amp;expected, T val, memory_order sync = memory_order_seq_cst)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare_exchange_weak</span> <span class="params">(T &amp;expected, T val, memory_order success, memory_order failure)</span> <span class="keyword">volatile</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare_exchange_weak</span> <span class="params">(T &amp;expected, T val, memory_order success, memory_order failure)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>
<p>将原子对象的存储值和预期值比较：</p>
<ul>
<li>若为 true，用 val 替换原子对象值。</li>
<li>若为 false， 用包含的值替换预期值。</li>
</ul>
<p>整个过程是原子性的。</p>
<p>下面版本使用的内存顺序取决于比较结果：true 则使用 success; false 则使用 failure。该函数比较的是原子对象和预期值中的物理内容，这可能导致使用操作符 == 比较相等的值的在这里比较失败。</p>
<p>与 compare_exchange_strong 不同，该 weak 版本<strong>允许错误的返回 false</strong>，即使原子对象存储值与预期值相等。对于某些循环算法，这可能是可接受的行为，并且可能在某些平台上显著提高性能。对于这些虚假的失败，函数返回 false，但不修改预期的值。对于非循环算法，通常首选 compare_exchange_strong。</p>
<h2 id="atomic-compare-exchange-strong">atomic::compare_exchange_strong</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare_exchange_strong</span> <span class="params">(T &amp;expected, T val, memory_order sync = memory_order_seq_cst)</span> <span class="keyword">volatile</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare_exchange_strong</span> <span class="params">(T &amp;expected, T val, memory_order sync = memory_order_seq_cst)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare_exchange_strong</span> <span class="params">(T &amp;expected, T val, memory_order success, memory_order failure)</span> <span class="keyword">volatile</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare_exchange_strong</span> <span class="params">(T &amp;expected, T val, memory_order success, memory_order failure)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>
<p>原子操作。与 compare_exchange_week 不同，当期望值与对象存储的值相等时，这个强版本必须始终返回 true，不允许虚假的失败。但是，在某些机器上，对于某些在循环中检查这个的算法，compare_exchange_weak 可能有更高的性能表现。</p>
<h2 id="专门化计算操作">专门化计算操作</h2>
<h3 id="atomic-fetch-add-T-val-memory-order-sync-memory-order-seq-cst">atomic::fetch_add(T val, memory_order sync = memory_order_seq_cst)</h3>
<p>存储的值 + val 并返回之前的值，整个操作是原子性的。如果第二个参数使用默认值，那么这个函数相当于 atomic::operator+=。</p>
<h3 id="atomic-fetch-sub-T-val-memory-order-sync-memory-order-seq-cst">atomic::fetch_sub(T val, memory_order sync = memory_order_seq_cst)</h3>
<p>存储的值 - val 并返回之前的值，整个操作是原子性的。如果第二个参数使用默认值，那么这个函数相当于 atomic::operator-=。</p>
<h3 id="atomic-fetch-and-T-val-memory-order-sync-memory-order-seq-cst">atomic::fetch_and(T val, memory_order sync = memory_order_seq_cst)</h3>
<p>（存储的值 &amp; val）并返回之前的值，整个操作是原子性的。如果第二个参数使用默认值，那么这个函数相当于 atomic::operator&amp;=。</p>
<h3 id="atomic-fetch-or-T-val-memory-order-sync-memory-order-seq-cst">atomic::fetch_or(T val, memory_order sync = memory_order_seq_cst)</h3>
<p>（存储的值 | val）并返回之前的值，整个操作是原子性的。如果第二个参数使用默认值，那么这个函数相当于 atomic::operator|=。</p>
<h3 id="atomic-fetch-xor-T-val-memory-order-sync-memory-order-seq-cst">atomic::fetch_xor(T val, memory_order sync = memory_order_seq_cst)</h3>
<p>（存储的值 ^ val）并返回之前的值，整个操作是原子性的。如果第二个参数使用默认值，那么这个函数相当于 atomic::operator^=。</p>
<h3 id="atomic-operator">atomic::operator++ ()</h3>
<p>递增保存的值，返回递增后的值。</p>
<h3 id="atomic-operator-int">atomic::operator++ (int)</h3>
<p>递增保存的值，返回递增前的值。</p>
<h3 id="atomic-operator-2">atomic::operator-- ()</h3>
<p>递减保存的值，返回递减后的值。</p>
<h3 id="atomic-operator-int-2">atomic::operator-- (int)</h3>
<p>递减保存的值，返回递减前的值。</p>
<p>reference：<a href="https://blog.csdn.net/u014673282/article/details/89789139">https://blog.csdn.net/u014673282/article/details/89789139</a></p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>concurrent-programming</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp列表初始化</title>
    <url>/20230511162941_313443579/</url>
    <content><![CDATA[<h2 id="cpp列表初始化是什么">cpp列表初始化是什么</h2>
<p>形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> num) : <span class="built_in">a_</span>(num) &#123;</span><br><span class="line">        cout &lt;&lt; a_ &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">12</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即，在构造函数后，使用列表的方式来初始化成员变量。</p>
<h2 id="构造函数内部执行顺序">构造函数内部执行顺序</h2>
<ol>
<li>调用构造函数</li>
<li>基类构造函数</li>
<li>进入左括号前，按照成员在类内声明的顺序，调用默认构造函数初始化成员变量。这就是隐藏的列表初始化。也是列表初始化时按声明顺序调用构造函数的原因。</li>
<li>执行构造函数内部语句</li>
<li>出构造函数，构造函数完成</li>
</ol>
<p>其实，列表初始化一直都在，只是我们在代码中忽略了。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;constructor called&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">const</span> Test&amp; t) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;copy constructor called&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    Test&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Test&amp; t) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;assignment operator called&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;call base constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(Test ele) : <span class="built_in">t_</span>(ele) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;call B constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Test t_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Test t;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;==========&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="function">B <span class="title">b</span><span class="params">(t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@└────&gt; # ./a.out </span><br><span class="line">constructor called</span><br><span class="line">==========</span><br><span class="line">copy constructor called // 传参的拷贝构造</span><br><span class="line">call base constructor   // 调用基类构造函数</span><br><span class="line">copy constructor called // 列表初始化</span><br><span class="line">call B constructor      // 子类构造函数内语句</span><br></pre></td></tr></table></figure>
<h2 id="列表初始化顺序">列表初始化顺序</h2>
<p>列表初始化顺序并不取决于在构造函数中列表的顺序，而取决于该成员在类中声明的顺序。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test1</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Test1</span>(<span class="type">const</span> Test1&amp; t) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test1 copy constructor called&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test2</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Test2</span>(<span class="type">const</span> Test2&amp; t) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test2 copy constructor called&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test3</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Test3</span>(<span class="type">const</span> Test3&amp; t) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test3 copy constructor called&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(Test1 ele1, Test2 ele2, Test3 ele3) : <span class="built_in">t2_</span>(ele2), <span class="built_in">t1_</span>(ele1), <span class="built_in">t3_</span>(ele3) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Test3 t3_;</span><br><span class="line">    Test1 t1_;</span><br><span class="line">    Test2 t2_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Test1 t1;</span><br><span class="line">    Test2 t2;</span><br><span class="line">    Test3 t3;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;==========&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(t1, t2, t3)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@└────&gt; # ./a.out </span><br><span class="line">==========</span><br><span class="line">Test3 copy constructor called  // A 的构造函数中的参数复制，因为是从右边的参数开始先拷贝，所以先构造 ele3，再 ele2，最后 ele1</span><br><span class="line">Test2 copy constructor called</span><br><span class="line">Test1 copy constructor called</span><br><span class="line">Test3 copy constructor called  // 按照类中声明的顺序，先拷贝给 t3_，再 t1_，最后 t2_。</span><br><span class="line">Test1 copy constructor called</span><br><span class="line">Test2 copy constructor called</span><br></pre></td></tr></table></figure>
<h2 id="区别">区别</h2>
<ol>
<li>如上面所说，在构造函数中使用 :a_(num) 的形式，对成员变量进行初始化。而在大括号中用等号来对成员变量进行赋值，是赋值行为，并非初始化。这个可以使用下面的例子来验证：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;constructor called&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">const</span> Test&amp; t) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;copy constructor called&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    Test&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Test&amp; t) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;assignment operator called&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(Test ele) &#123;</span><br><span class="line">        t_ = ele;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Test t_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(Test ele) : <span class="built_in">t_</span>(ele) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Test t_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Test t;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;==========&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(t)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;==========&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="function">B <span class="title">b</span><span class="params">(t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@└────&gt; # ./a.out </span><br><span class="line">constructor called</span><br><span class="line">==========</span><br><span class="line">copy constructor called     // A 中 ele 的拷贝构造</span><br><span class="line">constructor called          // A 中 t_ 的构造函数</span><br><span class="line">assignment operator called  // A 中 = ele 的赋值调用</span><br><span class="line">==========</span><br><span class="line">copy constructor called     // B 中 ele 的拷贝构造</span><br><span class="line">copy constructor called     // B 中 t_ 的初始化(拷贝构造)</span><br></pre></td></tr></table></figure>
<p>可以看到上面对于 A 来说，是先调用构造函数再调用赋值函数，而对于 B 来说就是拷贝构造函数。所以<strong>列表的形式是初始化</strong>，不同于在<strong>大括号内赋值</strong>。</p>
<ol start="2">
<li>列表初始化可以为 const 变量赋初值，但是大括号内赋值不行。</li>
</ol>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp单例模式</title>
    <url>/20230420105926_1589524973/</url>
    <content><![CDATA[<h2 id="单例模式概念">单例模式概念</h2>
<h3 id="定义">定义</h3>
<p>单例模式 Singleton：该类只能实例化一个对象的设计模式。</p>
<h3 id="分类">分类</h3>
<ol>
<li>懒汉模式：延时加载，在这个唯一的对象使用时才加载。
<blockquote>
<h4 id="优点">优点</h4>
<ol>
<li>资源利用率高，使用时才创建，不存在浪费。</li>
<li>加载类速度快，不需要创捷对象。</li>
</ol>
<h4 id="缺点">缺点</h4>
<ol>
<li>存在线程安全问题，需要引入同步机制（锁、信号量）。创建唯一对象不是原子操作，判空也不是原子操作。</li>
<li>运行获取速度慢，多线程同步带来额外开销。</li>
</ol>
</blockquote>
</li>
<li>饿汉模式：贪婪加载，在类加载时就生成唯一的对象。
<blockquote>
<h4 id="优点-2">优点</h4>
<ol>
<li>线程安全的单例模式。因为在加载的时候就创建了，所以不会有竞争。</li>
<li>获取对象速度快，因为已经创建好了，只需要获取就可以。</li>
</ol>
<h4 id="缺点-2">缺点</h4>
<ol>
<li>存在资源浪费的可能。因为可能只是加载这个类却不使用他。</li>
<li>类加载速度慢，因为需要创建对象。</li>
</ol>
</blockquote>
</li>
</ol>
<h3 id="设计思想">设计思想</h3>
<h4 id="如何控制，达到只生成一个对象的目的。">如何控制，达到只生成一个对象的目的。</h4>
<ol>
<li>对生成对象进行控制，将构造函数设计为私有。这样类外就不能调用构造函数，达到控制对象生成的目的。</li>
<li>对拷贝构造函数进行控制，将其设为私有并不实现，或者进行删除（C++11）。</li>
</ol>
<h4 id="提供对外接口，生成唯一对象。">提供对外接口，生成唯一对象。</h4>
<p>这个接口需要判断是否只生成了一个对象。</p>
<ol>
<li>这个函数的返回值需要返回一个对象，分三种情况。
<blockquote>
<ol>
<li>返回对象类名，存在临时对象，会发生拷贝，不符合单例模式要求。</li>
<li>返回对象引用，没有拷贝发生。</li>
<li>返回对象的指针，没有拷贝发生。</li>
</ol>
</blockquote>
</li>
<li>修饰关键字设置，从调用角度考虑。
<blockquote>
<ol>
<li>依赖对象来调用，obj.func() 来生成。但是此时对象未生成，所以不符合要求。</li>
<li>设计为静态函数，不依赖对象调用。通过类作用域来调用 ClassName::func() 来生成。</li>
</ol>
</blockquote>
</li>
<li>有一个标识，来标识唯一的对象。
<blockquote>
<ol>
<li>为了防止这个接口被调用很多次，定义一个唯一标识对象的指针，这个指针不依赖于对象。所以还是定义为静态变量，类外初始化为 nullptr。</li>
<li>指针为空，那就说明对象还没有生成。如果不为空，就说明已经生成了。</li>
</ol>
</blockquote>
</li>
</ol>
<h2 id="懒汉模式代码">懒汉模式代码</h2>
<h3 id="单线程版本">单线程版本</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LazySingleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> LazySingleton *<span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            instance_ = <span class="keyword">new</span> <span class="built_in">LazySingleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance_;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">LazySingleton</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;create singleton object:&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LazySingleton</span>(<span class="type">const</span> LazySingleton&amp; s) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="type">static</span> LazySingleton *instance_;</span><br><span class="line">&#125;;</span><br><span class="line">LazySingleton* LazySingleton::instance_ = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LazySingleton *obj1 = LazySingleton::<span class="built_in">GetInstance</span>();</span><br><span class="line">    LazySingleton *obj2 = LazySingleton::<span class="built_in">GetInstance</span>();</span><br><span class="line">    LazySingleton *obj3 = LazySingleton::<span class="built_in">GetInstance</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;obj1:&quot;</span> &lt;&lt; obj1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;obj2:&quot;</span> &lt;&lt; obj2 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;obj3:&quot;</span> &lt;&lt; obj3 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@└────&gt; # ./a.out </span><br><span class="line">create singleton object:0x1861eb0</span><br><span class="line">obj1:0x1861eb0</span><br><span class="line">obj2:0x1861eb0</span><br><span class="line">obj3:0x1861eb0</span><br></pre></td></tr></table></figure>
<p>这种懒汉模式的单例，在单线程下是没问题的，但是多线程下有竞争就会出现问题。比如两个线程都进行完了 instance_ 的判断，并且都为空，那么他们都会调用那个构造函数。</p>
<h3 id="多线程版本">多线程版本</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LazySingleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> LazySingleton *<span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        m_.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span> (instance_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            instance_ = <span class="keyword">new</span> <span class="built_in">LazySingleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        m_.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> instance_;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">LazySingleton</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;create singleton object:&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LazySingleton</span>(<span class="type">const</span> LazySingleton&amp; s) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="type">static</span> LazySingleton *instance_;</span><br><span class="line">    <span class="type">static</span> mutex m_;</span><br><span class="line">&#125;;</span><br><span class="line">LazySingleton* LazySingleton::instance_ = <span class="literal">nullptr</span>;</span><br><span class="line">mutex LazySingleton::m_;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        cout &lt;&lt; <span class="string">&quot;thread id:&quot;</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">&quot; instance pointer:&quot;</span> &lt;&lt; LazySingleton::GetInstance() &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        cout &lt;&lt; <span class="string">&quot;thread id:&quot;</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">&quot; instance pointer:&quot;</span> &lt;&lt; LazySingleton::GetInstance() &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        cout &lt;&lt; <span class="string">&quot;thread id:&quot;</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">&quot; instance pointer:&quot;</span> &lt;&lt; LazySingleton::GetInstance() &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@└────&gt; # ./a.out </span><br><span class="line">thread id:139862718146304 instance pointer:create singleton object:0x7f344c000f70</span><br><span class="line">0x7f344c000f70</span><br><span class="line">thread id:139862709753600 instance pointer:0x7f344c000f70</span><br><span class="line">thread id:139862701360896 instance pointer:0x7f344c000f70</span><br></pre></td></tr></table></figure>
<p>加锁，保证一个线程在对临界资源进行操作时不能被其他线程打断。用互斥锁即可，但是如果每次调用都需要进行加锁解锁，在第一个对象已经生成之后，在读的层面不需要进行加锁了。加锁解锁会导致效率低下。</p>
<p>可以把上面的加锁部分套在一个 if 判断里，这样下个线程进来的时候就不用试图加锁了。</p>
<p>改进版代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LazySingleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> LazySingleton *<span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance_ == <span class="literal">nullptr</span>) &#123; <span class="comment">// 套起来</span></span><br><span class="line">            m_.<span class="built_in">lock</span>();</span><br><span class="line">            <span class="keyword">if</span> (instance_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                instance_ = <span class="keyword">new</span> <span class="built_in">LazySingleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            m_.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance_;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">LazySingleton</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;create singleton object:&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LazySingleton</span>(<span class="type">const</span> LazySingleton&amp; s) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="type">static</span> LazySingleton *instance_;</span><br><span class="line">    <span class="type">static</span> mutex m_;</span><br><span class="line">&#125;;</span><br><span class="line">LazySingleton* LazySingleton::instance_ = <span class="literal">nullptr</span>;</span><br><span class="line">mutex LazySingleton::m_;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        cout &lt;&lt; <span class="string">&quot;thread id:&quot;</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">&quot; instance pointer:&quot;</span> &lt;&lt; LazySingleton::GetInstance() &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        cout &lt;&lt; <span class="string">&quot;thread id:&quot;</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">&quot; instance pointer:&quot;</span> &lt;&lt; LazySingleton::GetInstance() &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        cout &lt;&lt; <span class="string">&quot;thread id:&quot;</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">&quot; instance pointer:&quot;</span> &lt;&lt; LazySingleton::GetInstance() &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果和上面是一样的，这里就不展示了。</p>
<h3 id="C-11-的多线程版本">C++11 的多线程版本</h3>
<p>在 C++11 中，引入了 std::call_once，可以更便捷的实现上述功能。如需使用，只需要 #include <mutex> 即可，简单来说 std:call_once 的作用，确保函数或代码片段在多线程环境下，只需要执行一次，常用的场景如 Init() 操作或一些系统参数的获取等。</mutex></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LazySingleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> LazySingleton *<span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::<span class="built_in">call_once</span>(instnace_flag_, []() &#123;</span><br><span class="line">            instance_ = <span class="keyword">new</span> <span class="built_in">LazySingleton</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> instance_;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">LazySingleton</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;create singleton object:&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LazySingleton</span>(<span class="type">const</span> LazySingleton&amp; s) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="type">static</span> LazySingleton *instance_;</span><br><span class="line">    <span class="type">static</span> once_flag instnace_flag_;</span><br><span class="line">&#125;;</span><br><span class="line">LazySingleton* LazySingleton::instance_ = <span class="literal">nullptr</span>;</span><br><span class="line">once_flag LazySingleton::instnace_flag_;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        cout &lt;&lt; <span class="string">&quot;thread id:&quot;</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">&quot; instance pointer:&quot;</span> &lt;&lt; LazySingleton::GetInstance() &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        cout &lt;&lt; <span class="string">&quot;thread id:&quot;</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">&quot; instance pointer:&quot;</span> &lt;&lt; LazySingleton::GetInstance() &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        cout &lt;&lt; <span class="string">&quot;thread id:&quot;</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">&quot; instance pointer:&quot;</span> &lt;&lt; LazySingleton::GetInstance() &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@└────&gt; # ./a.out </span><br><span class="line">thread id:140655525984000 instance pointer:create singleton object:0x7fece4000f70</span><br><span class="line">0x7fece4000f70</span><br><span class="line">thread id:140655517591296 instance pointer:0x7fece4000f70</span><br><span class="line">thread id:140655509198592 instance pointer:0x7fece4000f70</span><br></pre></td></tr></table></figure>
<h2 id="饿汉模式代码">饿汉模式代码</h2>
<p>如果我们在线程开启前，已经将唯一的对象生成，就不会出现线程不安全的问题。即唯一的对象在main函数调用前已经生成，就不会产生线程安全问题。所以：</p>
<ol>
<li>在未进入 main 函数时，就完成唯一对象的生成，那么就是在程序加载时已经完成，存放在 .data段 的数据有这样的特点，所以我们可以直接给静态成员变量生成对象。</li>
<li>接口只用返回生成好的对象指针即可。<br>
代码：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HungerSingleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> HungerSingleton *<span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance_;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">HungerSingleton</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;create singleton object:&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">HungerSingleton</span>(<span class="type">const</span> HungerSingleton&amp; s) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="type">static</span> HungerSingleton *instance_;</span><br><span class="line">&#125;;</span><br><span class="line">HungerSingleton* HungerSingleton::instance_ = <span class="keyword">new</span> <span class="built_in">HungerSingleton</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        cout &lt;&lt; <span class="string">&quot;thread id:&quot;</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">&quot; instance pointer:&quot;</span> &lt;&lt; HungerSingleton::GetInstance() &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        cout &lt;&lt; <span class="string">&quot;thread id:&quot;</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">&quot; instance pointer:&quot;</span> &lt;&lt; HungerSingleton::GetInstance() &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        cout &lt;&lt; <span class="string">&quot;thread id:&quot;</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">&quot; instance pointer:&quot;</span> &lt;&lt; HungerSingleton::GetInstance() &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">@└────&gt; # ./a.out </span><br><span class="line">create singleton object:<span class="number">0x2343eb0</span></span><br><span class="line">thread id:<span class="number">140504409663232</span> instance pointer:<span class="number">0x2343eb0</span></span><br><span class="line">thread id:<span class="number">140504401270528</span> instance pointer:<span class="number">0x2343eb0</span></span><br><span class="line">thread id:<span class="number">140504392877824</span> instance pointer:<span class="number">0x2343eb0</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>design-pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp四种cast</title>
    <url>/20230416184222_894450274/</url>
    <content><![CDATA[<h1>四种转换介绍</h1>
<p>C风格转换：转换的含义是通过改变一个变量的类型为别的类型从而改变该变量的表示方式。为了类型转换一个简单对象为另一个对象，会使用传统的类型转换操作符。比如，为了转换一个类型为 double 的浮点数的指针到整型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">double</span> d;</span><br><span class="line">i = (<span class="type">int</span>)d;</span><br><span class="line">i = <span class="type">int</span>(d);</span><br></pre></td></tr></table></figure>
<p>对于具有标准定义转换的简单类型而言很好。但是这样的转换符不能随意用于类（class）和类的指针。标准定义了四个新的转换符：reinterpret_cast, static_cast, dynamic_cast 和  const_cast，目的在于控制类之间的类型转换。</p>
<h1>reinterpret_cast</h1>
<p>reinterpret_cast 转换一个指针为其它类型的指针。它也允许从一个指针转换为整数类型。反之亦然。这个操作符能够在<em><strong>非相关的</strong></em>类型之间转换。操作结果只是简单的从一个指针到别的指针的值的二进制拷贝。在类型之间指向的内容不做任何类型的检查和转换。</p>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;&#125;;</span><br><span class="line">A *a = <span class="keyword">new</span> A;</span><br><span class="line">B *b = <span class="built_in">reinterpret_cast</span>&lt;B *&gt;(a);</span><br></pre></td></tr></table></figure>
<p>reinterpret_cast 就像传统的类型转换一样对待所有指针的类型转换。</p>
<h1>static_cast</h1>
<p>static_cast 允许执行任意的隐式转换和相反转换动作。（相关类之间转换）</p>
<p>应用到类的指针上，意思是说它允许子类类型的指针转换为父类类型的指针（这是一个有效的隐式转换），同时，也能够执行相反动作：转换父类为它的子类。</p>
<p>在这最后例子里，被转换的父类没有被检查是否与目的类型相一致。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line">Base *a = <span class="keyword">new</span> Base;</span><br><span class="line">Derived *b = <span class="built_in">static_cast</span>&lt;Derived *&gt;(a);</span><br></pre></td></tr></table></figure>
<p>static_cast 除了操作类型指针，也能用于执行类型定义的显式的转换，以及基础类型之间的标准转换:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> d = <span class="number">3.14159265</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(d);</span><br></pre></td></tr></table></figure>
<p>如果转换的类型之间没有关系的话，会报编译错误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@└────&gt; # g++ test.cc </span><br><span class="line">test.cc: In function ‘int main()’:</span><br><span class="line">test.cc:12:41: error: invalid static_cast from type ‘Base*’ to type ‘Derived*’</span><br><span class="line">     Derived *b = static_cast&lt;Derived *&gt;(a);</span><br><span class="line">                                         ^</span><br></pre></td></tr></table></figure>
<p>如果子类中有基类没有的对象，那么转换后使用则不安全。</p>
<h1>dynamic_cast</h1>
<p>dynamic_cast 只用于对象的指针和引用。当用于多态类型时，它允许<strong>任意的隐式类型转换以及相反过程</strong>。不过，与 static_cast 不同，在自上而下的转换过程中， dynamic_cast 会检查操作是否有效。也就是说，它会检查转换是否会返回一个被请求的有效的完整对象。<br>
检测在<em><strong>运行时</strong></em>进行。如果被转换的指针不是一个被请求的有效完整的对象指针，返回值为NULL.<br>
代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; <span class="function"><span class="keyword">virtual</span> <span class="title">dummy</span><span class="params">()</span> </span>&#123;&#125; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Base* b1 = <span class="keyword">new</span> Derived;</span><br><span class="line">Base* b2 = <span class="keyword">new</span> Base;</span><br><span class="line"></span><br><span class="line">Derived* d1 = <span class="built_in">dynamic_cast</span>&lt;Derived *&gt;(b1);  <span class="comment">// 成功</span></span><br><span class="line">Derived* d2 = <span class="built_in">dynamic_cast</span>&lt;Derived *&gt;(b2);  <span class="comment">// 失败，返回NULL</span></span><br></pre></td></tr></table></figure>
<p>用于安全向下转型，成本非常高昂。</p>
<h1>const_cast</h1>
<p>这个转换类型操纵传递对象的 const 属性，或者是<strong>设置</strong>或者是<strong>移除</strong>：<br>
代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;&#125;;</span><br><span class="line"><span class="type">const</span> C *a = <span class="keyword">new</span> C;</span><br><span class="line">C *b = <span class="built_in">const_cast</span>&lt;C *&gt;(a);</span><br></pre></td></tr></table></figure>
<p>其它三种操作符是不能修改一个对象的<strong>常量性</strong>的。<br>
const_cast 在调用第三方函数中的使用：<br>
在使用第三方库或API时，它们只提供了非 const 类型的参数的函数，但我们只有 const 类型的对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">third_lib_fun</span><span class="params">(<span class="type">int</span> *ptr)</span> </span>&#123;</span><br><span class="line">    *ptr = *ptr + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> (*ptr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> val = <span class="number">10</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *ptr = &amp;val;</span><br><span class="line">    <span class="type">int</span> *ptr1 = <span class="built_in">const_cast</span>&lt;<span class="type">int</span> *&gt;(ptr);</span><br><span class="line">    <span class="built_in">third_lib_fun</span>(ptr1);</span><br><span class="line">    cout &lt;&lt; val;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure>
<p>我们在使用第三方库和 API 的时候，我们只能调用，看不到其具体的实现，为了能够调用成功，需要使用 const_cast 来去除 *ptr 的 const 属性。</p>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp多线程之std::future</title>
    <url>/20230326005424_31584/</url>
    <content><![CDATA[<h1>C++多线程编程之std::future</h1>
<h2 id="1-std-future">1. std::future</h2>
<p>std::future 通常由某个 Provider 创建，你可以把 Provider 想象成一个异步任务的提供者，Provider 在某个线程中设置共享状态的值，与该共享状态相关联的 std::future 对象调用 get（通常在另外一个线程中） 获取该值。如果共享状态的标志不为 还没有被 Provider 设置，则调用 std::future::get() 会<strong>阻塞</strong>当前的调用者，直到 Provider 设置了共享状态的值，std::future::get() 返回异步<strong>任务的值</strong>或<strong>异常</strong>（如果发生了异常）。一句话概括，std::future 是为了线程间传递数据使用的。<br>
一共有三种 Provider:</p>
<ol>
<li>std::async</li>
<li>std::promise 调用 get_future() 函数</li>
<li>std::packaged_task 调用 get_future() 函数</li>
</ol>
<p>提示，std::future 独占资源，类似 unique_ptr，不可被拷贝。接下来看下三种 Provider 的用法。</p>
<h2 id="2-std-async">2. std::async</h2>
<p>先看一段代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; fu = std::<span class="built_in">async</span>([](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;thread start!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">2000</span>));</span><br><span class="line">    <span class="type">int</span> res = fu.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;res=&quot;</span> &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译的时候需要链接pthread库。<br>
运行结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">thread start!</span><br><span class="line">res=30</span><br></pre></td></tr></table></figure>
<p>运行后立刻出现&quot;thread start!&quot;的字样，过了两秒出现结果。这是因为在运行 std::async 那一行的时候，直接会新建一个线程，执行函数的工作。这里使用的是 lambda 表达式，如果要传入自定义的函数需要加上 std::ref(函数名)，传入函数引用（因为线程传入的是拷贝）。最后的 10 和 20 是运行所需的参数。之后主线程（主进程）睡眠 2000ms，阻塞在 fu.get() 上，直到线程运行完毕，最后打印结果。<br>
综上所述，async 是为了<strong>把函数返回值带出来，用future来获取</strong>的。<br>
这里注意有一个坑，如果不用 fu 来接收 std::async 的话，代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> fu = std::<span class="built_in">async</span>([](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">2000</span>));</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;thread start!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;main&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">async</span>([](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">2000</span>));</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;thread start!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;main&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两段代码运行结果有什么不同呢？<br>
第一个用 fu 来接收了 std::future，导致这个 future 对象还没有被析构。所以是<strong>先打印 main，后面再过两秒打印出 thread start</strong>，之后 future 对象才因为程序结束离开作用域被析构。<br>
第二个代码因为没有接收 future 对象，导致这个右值直接析构。所以主进程等待 future 析构完成再继续往下走，<strong>所以打印是先等待两秒，之后打印 thread start，紧接着打印 main</strong>。</p>
<h2 id="3-std-promise">3. std::promise</h2>
<p>直接上代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; pr;</span><br><span class="line">    <span class="keyword">auto</span> fu = pr.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([](std::promise&lt;<span class="type">int</span>&gt;&amp; p, <span class="type">int</span> a)&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout &lt;&lt; <span class="string">&quot;thread start!&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::this_thread::sleep_for(std::chrono::milliseconds(<span class="number">2000</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">        p.set_value(a);</span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout &lt;&lt; a &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;, std::ref(pr), <span class="number">2</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;main&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;fu.get()=&quot;</span> &lt;&lt; fu.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">main</span><br><span class="line">fu.get()=thread start!</span><br><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>首先promise返回了一个 future 对象，表示 promise 承诺要传一个数给 future。之后运行线程 t1,给他传入了 promise 和一个数。在线程中，给 promise 设置了一个值。此时外面的 future 就可以调用 get() 方法获得线程中设置的 a。至于打印为何会断开，是因为在调用 fu.get() 的时候阻塞在那里了，所以先把前半段打印出来，等待 promise 传值给 future。<br>
综上所述，promise 是用来<strong>和 future 绑定，给他传数据</strong>的。</p>
<h2 id="3-std-packaged-task">3. std::packaged_task</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>&gt; <span class="title">ta</span><span class="params">([](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout &lt;&lt; <span class="string">&quot;thread start!&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::this_thread::sleep_for(std::chrono::milliseconds(<span class="number">2000</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">return</span> a + b;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> fu = ta.<span class="built_in">get_future</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;start to create thread&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(std::ref(ta), <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;fu.get()=&quot;</span> &lt;&lt; fu.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start to create thread</span><br><span class="line">fu.get()=thread start!</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>packaged_task 和一个普通的仿函数没有区别，只是返回值可以通过 future 来接收。结果同上，会在调用 fu.get() 的时候阻塞，等待线程 t1 执行完毕。<br>
综上所述，packaged_task 是用来将一个 <strong>future 和一个函数绑定，返回函数执行结果</strong>的。和 async 的区别是它可以延迟启动，由 thread 来调用。当然你想要使用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ta</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">std::cout &lt;&lt; fu.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure>
<p>那也可以，毕竟他也是个仿函数。</p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>concurrent-programming</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp左值和右值</title>
    <url>/20221117170431_1560934576/</url>
    <content><![CDATA[<h1>何为右值</h1>
<p>任何值不是左值，就是右值。左值和右值是针对表达式定义的。</p>
<ol>
<li>右值的生存周期只到表达式结束，即语句分号后右值的生存周期就结束了。</li>
<li>左值可以取地址，右值不行。</li>
<li>左值可以放在 = 的左右，但是右值只能放在右边。</li>
</ol>
<p>为什么要引入这么复杂的概念呢？为了性能。在赋值的时候，难免会产生一些临时变量的构造和销毁，这些构造和销毁可能会引起内存的申请与释放。频繁的系统调用会有很大的性能开销。这种时候没必要重复申请内存，只要把那个将要销毁对象内部的指针指向的空间被新的对象所利用就可以了！</p>
<p><img src="/20221117170431_1560934576/1.png" alt="1"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> t = <span class="number">10</span>;  <span class="comment">// t为左值</span></span><br><span class="line">++t;         <span class="comment">// t为左值，没有拷贝，这就是为什么 ++t 比 t++ 高效</span></span><br><span class="line">t++;         <span class="comment">// t为右值，因为加之前的值是个将亡值，是个 t_copy，是个临时变量</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;r = t; <span class="comment">// 错误，右值不能绑定左值。</span></span><br></pre></td></tr></table></figure>
<h1>std::move()</h1>
<h2 id="实现代码">实现代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @brief  Convert a value to an rvalue.</span></span><br><span class="line"><span class="comment"> *  @param  __t  A thing of arbitrary type.</span></span><br><span class="line"><span class="comment"> *  @return The parameter cast to an rvalue-reference to allow moving it.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::<span class="function">type&amp;&amp;</span></span><br><span class="line"><span class="function">  <span class="title">move</span><span class="params">(_Tp&amp;&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(<span class="type">__t</span>); &#125;</span><br></pre></td></tr></table></figure>
<p>这个函数就一个作用：将左值明确的转换为右值。由于引用折叠的存在，导致返回值一定是右值。引用折叠概念见下一小节。</p>
<h2 id="示例">示例</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(string &amp;&amp;str)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;右值函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(string &amp;str)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;左值函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="built_in">func</span>(s + s);</span><br><span class="line">    <span class="built_in">func</span>(s);</span><br><span class="line">    <span class="built_in">func</span>(std::<span class="built_in">move</span>(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@└────&gt; # ./a.out </span><br><span class="line">右值函数</span><br><span class="line">左值函数</span><br><span class="line">右值函数</span><br></pre></td></tr></table></figure>
<p>可以看到，s + s 是一个右值，编译器会自动匹配调用右值对应的函数。s 是一个左值，会调用左值对应的函数。使用 std::move() 强行把左值转换为右值，就匹配右值对应的函数。此处注意，因为 s 已经变为右值了，所以在调用之后，s 会失效。</p>
<h1>std::forward()</h1>
<p>在介绍 std::forward() 之前，先介绍下引用折叠。</p>
<h2 id="引用折叠">引用折叠</h2>
<p>引用折叠是指，在左值类型和右值类型叠加时，确认叠加规则。如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WithoutPerfectForward</span><span class="params">(T &amp;&amp;t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lvalue:&quot;</span> &lt;&lt; std::is_lvalue_reference&lt;<span class="keyword">decltype</span>(t)&gt;::value &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;rvalue:&quot;</span> &lt;&lt; std::is_rvalue_reference&lt;<span class="keyword">decltype</span>(t)&gt;::value &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> c = <span class="number">1</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> d = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> &amp;e = a;</span><br><span class="line">    <span class="type">int</span> &amp;f = b;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp;g = c;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp;h = d;</span><br><span class="line">    <span class="built_in">WithoutPerfectForward</span>(a);        <span class="comment">// l + r = l</span></span><br><span class="line">    <span class="built_in">WithoutPerfectForward</span>(<span class="built_in">move</span>(b));  <span class="comment">// r + r = r</span></span><br><span class="line">    <span class="built_in">WithoutPerfectForward</span>(c);        <span class="comment">// const l + r = l</span></span><br><span class="line">    <span class="built_in">WithoutPerfectForward</span>(<span class="built_in">move</span>(d));  <span class="comment">// const r + r = r</span></span><br><span class="line">    <span class="built_in">WithoutPerfectForward</span>(e);        <span class="comment">// l ref + r = l</span></span><br><span class="line">    <span class="built_in">WithoutPerfectForward</span>(<span class="built_in">move</span>(f));  <span class="comment">// r ref + r = r</span></span><br><span class="line">    <span class="built_in">WithoutPerfectForward</span>(g);        <span class="comment">// const l ref + r = l</span></span><br><span class="line">    <span class="built_in">WithoutPerfectForward</span>(<span class="built_in">move</span>(h));  <span class="comment">// const r ref + r = r</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@└────&gt; # ./a.out </span><br><span class="line">lvalue:1</span><br><span class="line">rvalue:0</span><br><span class="line"></span><br><span class="line">lvalue:0</span><br><span class="line">rvalue:1</span><br><span class="line"></span><br><span class="line">lvalue:1</span><br><span class="line">rvalue:0</span><br><span class="line"></span><br><span class="line">lvalue:0</span><br><span class="line">rvalue:1</span><br><span class="line"></span><br><span class="line">lvalue:1</span><br><span class="line">rvalue:0</span><br><span class="line"></span><br><span class="line">lvalue:0</span><br><span class="line">rvalue:1</span><br><span class="line"></span><br><span class="line">lvalue:1</span><br><span class="line">rvalue:0</span><br><span class="line"></span><br><span class="line">lvalue:0</span><br><span class="line">rvalue:1</span><br></pre></td></tr></table></figure>
<p>可以看到，因为 T 的不同会产生不同的模版函数特化版本，如参数会变为 T&amp; &amp;&amp; 和 T&amp;&amp; &amp;&amp; 这两种形式，c++11 支持的编译器会对这种情况用 4 条规则做折叠处理，生成只有 &amp; 和 &amp;&amp; 的引用方式：</p>
<ol>
<li>&amp; + &amp; = &amp;</li>
<li>&amp; + &amp;&amp; = &amp;</li>
<li>&amp;&amp; + &amp; = &amp;</li>
<li>&amp;&amp; + &amp;&amp; = &amp;&amp;</li>
</ol>
<p>即引用折叠时只要有左值引用，就折叠为左值引用，<strong>全部是右值引用，才折叠为右值引用</strong>。</p>
<p>那么考虑如下场景：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RunCode</span><span class="params">(<span class="type">int</span> &amp;&amp; m)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int &amp;&amp; called!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RunCode</span><span class="params">(<span class="type">int</span> &amp;m)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int &amp; called!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RunCode</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;&amp; m)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;const int &amp;&amp; called!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RunCode</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp; m)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;const int &amp; called!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WithoutPerfectForward</span><span class="params">(T &amp;&amp;t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">RunCode</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> c = <span class="number">1</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> d = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> &amp;e = a;</span><br><span class="line">    <span class="type">int</span> &amp;f = b;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp;g = c;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp;h = d;</span><br><span class="line">    <span class="built_in">WithoutPerfectForward</span>(a);        <span class="comment">// l + r</span></span><br><span class="line">    <span class="built_in">WithoutPerfectForward</span>(<span class="built_in">move</span>(b));  <span class="comment">// r + r</span></span><br><span class="line">    <span class="built_in">WithoutPerfectForward</span>(c);        <span class="comment">// const l + r</span></span><br><span class="line">    <span class="built_in">WithoutPerfectForward</span>(<span class="built_in">move</span>(d));  <span class="comment">// const r + r</span></span><br><span class="line">    <span class="built_in">WithoutPerfectForward</span>(e);        <span class="comment">// l ref + r</span></span><br><span class="line">    <span class="built_in">WithoutPerfectForward</span>(<span class="built_in">move</span>(f));  <span class="comment">// r ref + r</span></span><br><span class="line">    <span class="built_in">WithoutPerfectForward</span>(g);        <span class="comment">// const l ref + r</span></span><br><span class="line">    <span class="built_in">WithoutPerfectForward</span>(<span class="built_in">move</span>(h));  <span class="comment">// const r ref + r</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@└────&gt; # ./a.out </span><br><span class="line">int &amp; called!</span><br><span class="line">int &amp; called!</span><br><span class="line">const int &amp; called!</span><br><span class="line">const int &amp; called!</span><br><span class="line">int &amp; called!</span><br><span class="line">int &amp; called!</span><br><span class="line">const int &amp; called!</span><br><span class="line">const int &amp; called!</span><br></pre></td></tr></table></figure>
<p>可以看到虽然在函数 WithoutPerfectForward 中是右值，但是传给下一个函数的时候又默认都是左值了。虽然参数 t 是右值类型的，但此时 t 在内存中已经有了位置，所以 t 其实是个左值。</p>
<h2 id="完美转发">完美转发</h2>
<p>为了实现不丢失传进来值的左右性，使用 std::forward() 就可以实现完美的转发了！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RunCode</span><span class="params">(<span class="type">int</span> &amp;&amp; m)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int &amp;&amp; called!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RunCode</span><span class="params">(<span class="type">int</span> &amp;m)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int &amp; called!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RunCode</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;&amp; m)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;const int &amp;&amp; called!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RunCode</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp; m)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;const int &amp; called!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WithoutPerfectForward</span><span class="params">(T &amp;&amp;t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">RunCode</span>(std::forward&lt;T&gt;(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> c = <span class="number">1</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> d = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> &amp;e = a;</span><br><span class="line">    <span class="type">int</span> &amp;f = b;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp;g = c;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp;h = d;</span><br><span class="line">    <span class="built_in">WithoutPerfectForward</span>(a);        <span class="comment">// l + r</span></span><br><span class="line">    <span class="built_in">WithoutPerfectForward</span>(<span class="built_in">move</span>(b));  <span class="comment">// r + r</span></span><br><span class="line">    <span class="built_in">WithoutPerfectForward</span>(c);        <span class="comment">// const l + r</span></span><br><span class="line">    <span class="built_in">WithoutPerfectForward</span>(<span class="built_in">move</span>(d));  <span class="comment">// const r + r</span></span><br><span class="line">    <span class="built_in">WithoutPerfectForward</span>(e);        <span class="comment">// l ref + r</span></span><br><span class="line">    <span class="built_in">WithoutPerfectForward</span>(<span class="built_in">move</span>(f));  <span class="comment">// r ref + r</span></span><br><span class="line">    <span class="built_in">WithoutPerfectForward</span>(g);        <span class="comment">// const l ref + r</span></span><br><span class="line">    <span class="built_in">WithoutPerfectForward</span>(<span class="built_in">move</span>(h));  <span class="comment">// const r ref + r</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@└────&gt; # ./a.out </span><br><span class="line">int &amp; called!</span><br><span class="line">int &amp;&amp; called!</span><br><span class="line">const int &amp; called!</span><br><span class="line">const int &amp;&amp; called!</span><br><span class="line">int &amp; called!</span><br><span class="line">int &amp;&amp; called!</span><br><span class="line">const int &amp; called!</span><br><span class="line">const int &amp;&amp; called!</span><br></pre></td></tr></table></figure>
<h2 id="实现代码-2">实现代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @brief  Forward an lvalue.</span></span><br><span class="line"><span class="comment"> *  @return The parameter cast to the specified type.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  This function is used to implement &quot;perfect forwarding&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span></span><br><span class="line"><span class="function">  <span class="keyword">constexpr</span> _Tp&amp;&amp;</span></span><br><span class="line"><span class="function">  <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="type">__t</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @brief  Forward an rvalue.</span></span><br><span class="line"><span class="comment"> *  @return The parameter cast to the specified type.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  This function is used to implement &quot;perfect forwarding&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span></span><br><span class="line"><span class="function">  <span class="keyword">constexpr</span> _Tp&amp;&amp;</span></span><br><span class="line"><span class="function">  <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp;&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(!std::is_lvalue_reference&lt;_Tp&gt;::value, <span class="string">&quot;template argument&quot;</span></span><br><span class="line">          <span class="string">&quot; substituting _Tp is an lvalue reference type&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="type">__t</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，std::forward() 有两个函数，会根据是左值还是右值调用不同的函数，返回不同种类出参。</p>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp智能指针</title>
    <url>/20230413001256_5003/</url>
    <content><![CDATA[<h1>什么是智能指针</h1>
<p>智能指针是一个<strong>管理指针</strong>的<strong>类</strong>。用来存储指向<strong>动态分配对象</strong>（在堆区 new 出来的）的指针。在它的生命周期结束时，它可以负责自动释放动态分配的对象，调用析构函数，以达到防止堆内存泄露的目的。</p>
<h1>智能指针发展史</h1>
<ol>
<li>C++98 引入 auto_ptr （已废弃）</li>
<li>C++11 引入 unique_ptr 和 shared_ptr</li>
</ol>
<h1>原理</h1>
<h2 id="RAII">RAII</h2>
<p>RAII 代表 resource acquisition is initialization 的缩写，意为“资源获取即初始化”。它是 C++ 之父提出的设计理念，核心是把<strong>资源和对象的生命周期绑定，对象创建获取资源，销毁释放资源</strong>。这样做有两大好处：</p>
<ol>
<li>不需要显式的释放资源。</li>
<li>对象所需资源在其生命周期始终保持有效。</li>
</ol>
<p>实现一个简单的智能指针：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">smartPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">smartPtr</span>(T* ptr = <span class="literal">nullptr</span>) : <span class="built_in">ptr_</span>(ptr) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">smartPtr</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (ptr_) &#123;</span><br><span class="line">            <span class="keyword">delete</span> ptr_;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~smartPtr called!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="function">smartPtr&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(a)</span></span>; <span class="comment">//将a 指针委托给sp对象管理</span></span><br><span class="line">    smartPtr&lt;<span class="type">int</span>&gt;<span class="built_in">sp2</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">2</span>)); <span class="comment">//直接船舰匿名对象给sp2管理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的还不足以称为智能指针，因为</p>
<ol>
<li>没有重载运算符 <strong>* 和 -&gt;</strong>。</li>
<li>如果使用了拷贝或者赋值操作，由于是浅拷贝，会有 double free 的错误。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">smartPtr&lt;Date&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> Date)</span></span>;</span><br><span class="line">    <span class="function">smartPtr&lt;Date&gt; <span class="title">sp2</span><span class="params">(sp)</span></span>; <span class="comment">// 发生浅拷贝，开辟的两个smartPtr对象指向同一个内存。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 两个都调用析构，第二次析构出现问题。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="auto-ptr">auto_ptr</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span> <span class="comment">// 智能指针定义在此</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(): <span class="built_in">year_</span>(<span class="number">0</span>), <span class="built_in">month_</span>(<span class="number">0</span>), <span class="built_in">day_</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Date</span>()&#123;&#125;</span><br><span class="line">    <span class="type">int</span> year_;</span><br><span class="line">    <span class="type">int</span> month_;</span><br><span class="line">    <span class="type">int</span> day_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">auto_ptr&lt;Date&gt; <span class="title">ap</span><span class="params">(<span class="keyword">new</span> Date)</span></span>;</span><br><span class="line">    <span class="comment">//拷贝构造</span></span><br><span class="line">    <span class="function">auto_ptr&lt;Date&gt; <span class="title">copy</span><span class="params">(ap)</span></span>;</span><br><span class="line">    ap-&gt;year_ = <span class="number">2022</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现报错了。原因是对于 <strong>auto_ptr 来说，赋值后之前的指针就被置空了</strong>。在拷贝或者赋值的过程中，auto_ptr 会传递所有权，将资源全部从源指针转移给目标指针，源指针被置空。虽然这种方法确实解决了浅拷贝的问题，但是我们使用auto_ptr的时候要注意，不要对源指针进行访问或者操作。<br>
auto_ptr 实现代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">auto_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">auto_ptr</span>(T* ptr = <span class="literal">nullptr</span>) : <span class="built_in">ptr_</span>(ptr) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">auto_ptr</span>(auto_ptr&lt;T&gt;&amp; ap) : _ptr(ap.ptr_) &#123; <span class="comment">// 拷贝构造</span></span><br><span class="line">        ap.ptr_ = <span class="literal">nullptr</span>; <span class="comment">// 源指针管理权转移</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    auto_ptr&lt;T&gt;&amp; <span class="keyword">operator</span> = (auto_ptr&lt;T&gt;&amp; ap) &#123; <span class="comment">// 赋值构造</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != *ap) &#123;</span><br><span class="line">            <span class="keyword">delete</span> ptr_;</span><br><span class="line">            ptr_ = ap.ptr_;</span><br><span class="line">            ap.ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">auto_ptr</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (ptr_) &#123;</span><br><span class="line">            <span class="keyword">delete</span> ptr_;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span> *() &#123; <span class="comment">// 重载 * 运算符</span></span><br><span class="line">        <span class="keyword">return</span> *ptr_;</span><br><span class="line">    &#125;</span><br><span class="line">    T* <span class="keyword">operator</span> -&gt;() &#123; <span class="comment">// 重载 -&gt; 运算符</span></span><br><span class="line">        <span class="keyword">return</span> ptr_;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="unique-ptr">unique_ptr</h2>
<p>相比 auto_ptr，unique_ptr <strong>得不到就毁掉</strong>，不允许别人拿到。禁用拷贝和赋值构造函数。只能采用移动。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">unique_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unique_ptr</span>(T* ptr = <span class="literal">nullptr</span>) : <span class="built_in">ptr_</span>(ptr) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">unique_ptr</span>(unique_ptr&lt;T&gt;&amp; ap) = <span class="keyword">delete</span>;</span><br><span class="line">    unique_ptr&lt;T&gt;&amp; <span class="keyword">operator</span> = (unique_ptr&lt;T&gt;&amp; ap) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">unique_ptr</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (ptr_) &#123;</span><br><span class="line">            <span class="keyword">delete</span> ptr_;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span> *() &#123; <span class="comment">// 重载 * 运算符</span></span><br><span class="line">        <span class="keyword">return</span> *ptr_;</span><br><span class="line">    &#125;</span><br><span class="line">    T* <span class="keyword">operator</span> -&gt;() &#123; <span class="comment">// 重载 -&gt; 运算符</span></span><br><span class="line">        <span class="keyword">return</span> ptr_;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="shared-ptr">shared_ptr</h2>
<p>shared_ptr 使用最为广泛，可以提供安全的拷贝构造。</p>
<h3 id="原理：">原理：</h3>
<p>对一个资源加一个计数器，让所有管理资源的 shared_ptr 共用这个计数器。如果发生拷贝，计数器 $+1$。等于 $0$ 的时候，就析构。<br>
再具体一点：</p>
<ol>
<li>shared_ptr 在其内部，给每个资源都维护了着一份计数，用来记录该份资源被几个对象共享。</li>
<li>在对象析构函数调用时，对象的引用计数减一。</li>
<li>如果引用计数是 0，就说明自己是最后一个使用该资源的对象，必须释放该资源；</li>
<li>如果不是 0，就说明除了自己还有其他对象在使用该份资源，不能释放该资源，否则其他对象就成野指针了。</li>
</ol>
<h3 id="模拟实现代码：">模拟实现代码：</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>(T* ptr =<span class="literal">nullptr</span>) : <span class="built_in">ptr_</span>(ptr), <span class="built_in">pcount_</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>)) &#123;&#125;</span><br><span class="line">    <span class="comment">//拷贝构造</span></span><br><span class="line">    <span class="built_in">shared_ptr</span>(<span class="type">const</span> T&amp; sp) <span class="built_in">ptr_</span>(sp.ptr_), <span class="built_in">pcount_</span>(sp.pcount_) &#123;</span><br><span class="line">        ++(*pcount_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 赋值拷贝1</span></span><br><span class="line">    shared_ptr&lt;T&gt;&amp; <span class="keyword">operator</span> = (shared_ptr&lt;T&gt;&amp; sp) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ptr_ != sp.ptr_) &#123; <span class="comment">// 注意：如果对自己赋值可能会误析构资源。</span></span><br><span class="line">            <span class="keyword">if</span> (--(*pcount_) == <span class="number">0</span>) &#123; <span class="comment">// 先析构自己，再赋值为别人的，以免内存泄漏</span></span><br><span class="line">                <span class="keyword">delete</span> pcount_;</span><br><span class="line">                <span class="keyword">delete</span> ptr_;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr_ = sp.ptr_;</span><br><span class="line">            pcount_ = sp.pcount_;</span><br><span class="line">            ++(*pcount_);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 赋值构造写法2</span></span><br><span class="line"><span class="comment">    shared_ptr&lt;T&gt;&amp; operator=(shared_ptr&lt;T&gt; sp) &#123;</span></span><br><span class="line"><span class="comment">            swap(_ptr, sp._ptr);</span></span><br><span class="line"><span class="comment">            swap(_pcount, sp._pcount);</span></span><br><span class="line"><span class="comment">            return *this;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span> *() &#123;</span><br><span class="line">        <span class="keyword">return</span> *ptr_;</span><br><span class="line">    &#125;</span><br><span class="line">    T* <span class="keyword">operator</span> -&gt;() &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">shared_ptr</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (--(*pcount_) == <span class="number">0</span> &amp;&amp; ptr_) &#123; <span class="comment">// 只有引用计数为 0 才释放</span></span><br><span class="line">            <span class="keyword">delete</span> pcount_;</span><br><span class="line">            <span class="keyword">delete</span> ptr_;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr_;</span><br><span class="line">    <span class="type">int</span>* pcount_; <span class="comment">// 所有指向同一块内存的share_ptr共享，所以申请在堆区</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="拷贝构造图解：">拷贝构造图解：</h3>
<p><img src="/20230413001256_5003/1.png" alt="1"></p>
<h3 id="多线程版">多线程版</h3>
<p>上述代码没有考虑多线程，下面有个带锁版本，仅供参考：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>(T* ptr = <span class="literal">nullptr</span>) : _ptr(ptr), _pcount(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>)), </span><br><span class="line">                                  _pmtx(<span class="keyword">new</span> mutex) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_ref</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        _pmtx-&gt;<span class="built_in">lock</span>();</span><br><span class="line">        ++(*_pcount);</span><br><span class="line">        _pmtx-&gt;<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">release_ref</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>; <span class="comment">// 是否释放锁的内存</span></span><br><span class="line">        _pmtx-&gt;<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span> (--(*_pcount) == <span class="number">0</span> &amp;&amp; _ptr) &#123;</span><br><span class="line">            <span class="keyword">delete</span> _pcount;</span><br><span class="line">            <span class="keyword">delete</span> _ptr;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;释放资源：&quot;</span> &lt;&lt; _ptr &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        _pmtx-&gt;<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">delete</span> _pmtx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">shared_ptr</span>(<span class="type">const</span> shared_ptr&lt;T&gt;&amp; sp) : _ptr(sp._ptr), _pcount(sp._pcount),</span><br><span class="line">                                         _pmtx(sp._pmtx) &#123;</span><br><span class="line">        <span class="built_in">add_ref</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    shared_ptr&lt;T&gt;&amp; <span class="keyword">operator</span> = (<span class="type">const</span> shared_ptr&lt;T&gt;&amp; sp) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_ptr != sp._ptr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--(*_pcount) == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">delete</span> _pcount;</span><br><span class="line">                <span class="keyword">delete</span> _ptr;</span><br><span class="line">            &#125;</span><br><span class="line">            _ptr = sp._ptr;</span><br><span class="line">            _pcount = sp._pcount;</span><br><span class="line">            <span class="built_in">add_ref</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span> *() &#123;</span><br><span class="line">        <span class="keyword">return</span> *_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T* <span class="keyword">operator</span> -&gt;() &#123;</span><br><span class="line">        <span class="keyword">return</span> _ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">use_count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *_pcount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">shared_ptr</span>() &#123;</span><br><span class="line">        <span class="built_in">release_ref</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* _ptr;</span><br><span class="line">    <span class="type">int</span>* _pcount;</span><br><span class="line">    mutex* _pmtx; <span class="comment">// 此锁用于访问 _pcount时同步用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="删除器">删除器</h3>
<p>库中的shared_ptr,我们在析构的时候默认都是 delete _ptr,如果我们托管的类型是 new T[] ,或者 malloc 出来的话，就导致类型不是匹配的，无法析构。这个时候我们要自定义删除器，如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DeleteArray</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T* ptr)</span> </span>&#123; <span class="comment">// 仿函数</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;delete functor called!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span>[] ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DeleteArray&lt;string&gt; delfunctor; <span class="comment">//使用仿函数定制</span></span><br><span class="line">    std::shared_ptr&lt;string&gt;<span class="built_in">s2</span>(<span class="keyword">new</span> string[<span class="number">10</span>], delfunctor);</span><br><span class="line">    std::shared_ptr&lt;string&gt;<span class="built_in">s3</span>((string*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="number">100</span>)), [](string* ptr) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;call free!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">free</span>(ptr);</span><br><span class="line">    &#125;); <span class="comment">//使用lamdba 定制</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@└────&gt; # ./a.out </span><br><span class="line">call free!</span><br><span class="line">delete functor called!</span><br></pre></td></tr></table></figure>
<h2 id="weak-ptr">weak_ptr</h2>
<p>有以下情形：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    shared_ptr&lt;ListNode&gt; prev_;</span><br><span class="line">    shared_ptr&lt;ListNode&gt; next_;</span><br><span class="line">    <span class="type">int</span> val_;</span><br><span class="line">    ~<span class="built_in">ListNode</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~ListNode called!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;ListNode&gt; <span class="title">n1</span><span class="params">(<span class="keyword">new</span> ListNode)</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;ListNode&gt; <span class="title">n2</span><span class="params">(<span class="keyword">new</span> ListNode)</span></span>;</span><br><span class="line">    n1-&gt;next_ = n2;</span><br><span class="line">    n2-&gt;prev_ = n1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行发现，析构函数没有被调用。<br>
<img src="/20230413001256_5003/2.png" alt="2"><br>
两边引用计数都是2，像是死锁一样，都不会析构。这时候就要用到 weak_ptr了。weak_ptr 是一个弱引用，它是为了配合shared_ptr而引入的一种智能指针，是为了解决循环引用而生的。我们只能使用 weak_ptr 或者 shared_ptr 去初始化它。<br>
我们在会产生循环引用的位置，把shared_ptr 换成 weak_ptr。 weak_ptr 不是一个 RAII 智能指针，它<strong>不参与资源的管理</strong>，他是专门用来解决引用计数的，我们可以使用一个shared_ptr 来初始化一个 weak_ptr,但是 weak_ptr 不增加引用计数，不参与管理，但是也像指针一样访问修改资源。<br>
上面代码修改为:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    weak_ptr&lt;ListNode&gt; prev_;</span><br><span class="line">    weak_ptr&lt;ListNode&gt; next_;</span><br><span class="line">    <span class="type">int</span> val_;</span><br><span class="line">    ~<span class="built_in">ListNode</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~ListNode called!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;ListNode&gt; <span class="title">n1</span><span class="params">(<span class="keyword">new</span> ListNode)</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;ListNode&gt; <span class="title">n2</span><span class="params">(<span class="keyword">new</span> ListNode)</span></span>;</span><br><span class="line">    n1-&gt;next_ = n2;</span><br><span class="line">    n2-&gt;prev_ = n1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现代码参考：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">weak_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">weak_ptr</span>() : _ptr(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="comment">// 用 shared_ptr 初始化</span></span><br><span class="line">    <span class="built_in">weak_ptr</span>(shared_ptr&lt;T&gt;&amp; sp) :_ptr(sp.<span class="built_in">get</span>()), _pcount(sp.<span class="built_in">use_count</span>()) &#123;&#125;</span><br><span class="line">    <span class="built_in">weak_ptr</span>(weak_ptr&lt;T&gt;&amp; sp) : _ptr(sp._ptr), _pcount(sp._pcount) &#123;&#125;</span><br><span class="line">    weak_ptr&amp; <span class="keyword">operator</span> = (shared_ptr&lt;T&gt;&amp; sp) &#123;</span><br><span class="line">        _ptr = sp.<span class="built_in">get</span>();</span><br><span class="line">        _pcount = sp.<span class="built_in">use_count</span>();</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    weak_ptr&amp; <span class="keyword">operator</span> = (weak_ptr&lt;T&gt;&amp; sp) &#123;</span><br><span class="line">        _ptr = sp._ptr;</span><br><span class="line">        _pcount = sp._pcount;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() &#123;</span><br><span class="line">        <span class="keyword">return</span> *_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() &#123;</span><br><span class="line">        <span class="keyword">return</span> _ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">use_count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *_pcount;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* _ptr;</span><br><span class="line">    <span class="type">int</span>* _pcount; <span class="comment">// 只记录 share_ptr 引用个数，weak_ptr的观测不会增加它</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp模板类定义放在头文件原因</title>
    <url>/20230502100634_2223083831/</url>
    <content><![CDATA[<h2 id="编译单元">编译单元</h2>
<p>编译单元是指一个源文件（.c/.cpp）文件和包含展开的头文件，之后编译器会将该文件编译成一个 object 文件（在 linux 中是 .o 文件）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc xxx.cc -c</span><br></pre></td></tr></table></figure>
<p>之后用可以看见当前目录下生成一个 xxx.o 的文件，这个文件就是 <a href="http://xxx.cc">xxx.cc</a> 编译单元生成的对应二进制。这个二进制里面有该文件所对应的符号。</p>
<h2 id="普通成员函数">普通成员函数</h2>
<p>现在有如下例子，尝试编译对应的二进制文件，不链接：</p>
<p><a href="http://main.cc">main.cc</a>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;A.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    a.<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A.h：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="http://A.cc">A.cc</a>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;A.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后可以用 nm 命令查看二进制中的符号，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@└────&gt; # g++ main.cc -c</span><br><span class="line">@└────&gt; # g++ A.cc -c</span><br><span class="line">@└────&gt; # nm main.o </span><br><span class="line">0000000000000000 T main</span><br><span class="line">                 U _ZN1A5printEv</span><br><span class="line">@└────&gt; # nm A.o </span><br><span class="line">                 U __cxa_atexit</span><br><span class="line">                 U __dso_handle</span><br><span class="line">000000000000006c t _GLOBAL__sub_I__ZN1A5printEv</span><br><span class="line">000000000000002e t _Z41__static_initialization_and_destruction_0ii</span><br><span class="line">0000000000000000 T _ZN1A5printEv</span><br><span class="line">                 U _ZNSolsEi</span><br><span class="line">                 U _ZNSolsEPFRSoS_E</span><br><span class="line">                 U _ZNSt8ios_base4InitC1Ev</span><br><span class="line">                 U _ZNSt8ios_base4InitD1Ev</span><br><span class="line">                 U _ZSt4cout</span><br><span class="line">                 U _ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_</span><br><span class="line">0000000000000000 r _ZStL19piecewise_construct</span><br><span class="line">0000000000000000 b _ZStL8__ioinit</span><br></pre></td></tr></table></figure>
<p>可以看到，在 main.o 中，有一个 _ZN1A5printEv，是对 undefined，也就是说编译器在这个编译单元中找不到这个符号。在 main.o 中，看下反汇编，调用 print 函数的时候是类似 call print 这种形式跳转函数的。因为找不到这个符号，自然也就不知道这个函数的地址，所以需要链接器链接有这个符号的 A.o，就可以运行了。常规的成员函数这样运行的，那么如果换成模板成员函数会怎么样呢？</p>
<h2 id="模板成员函数">模板成员函数</h2>
<p>修改代码如下：</p>
<p><a href="http://main.cc">main.cc</a>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;A.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    a.<span class="built_in">print</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A.h：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="http://A.cc">A.cc</a>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;A.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@└────&gt; # g++ main.cc -c</span><br><span class="line">@└────&gt; # g++ A.cc -c</span><br><span class="line">@└────&gt; # nm main.o </span><br><span class="line">0000000000000000 T main</span><br><span class="line">                 U _ZN1A5printIiEEvv</span><br><span class="line">@└────&gt; # nm A.o</span><br><span class="line">                 U __cxa_atexit</span><br><span class="line">                 U __dso_handle</span><br><span class="line">000000000000003e t _GLOBAL__sub_I_A.cc</span><br><span class="line">0000000000000000 t _Z41__static_initialization_and_destruction_0ii</span><br><span class="line">                 U _ZNSt8ios_base4InitC1Ev</span><br><span class="line">                 U _ZNSt8ios_base4InitD1Ev</span><br><span class="line">0000000000000000 r _ZStL19piecewise_construct</span><br><span class="line">0000000000000000 b _ZStL8__ioinit</span><br></pre></td></tr></table></figure>
<p>可以看到，在换成模板函数后，A.o 中根本没有 print 的符号！尽管 <a href="http://A.cc">A.cc</a> 中有定义。这是因为在 C++ 中，<strong>当一个模板不被用到的时侯它就不该被实例化出来</strong>，而在 <a href="http://A.cc">A.cc</a> 中显然这个模板没有被用到。所以编译器在编译 main.o 的时候，没找到符号，就把希望寄托于链接器。而链接器在链接的时候也懵逼了，因为这个符号在 A.o 中也没有。所以这种情况下链接器会报找不到符号的错误。</p>
<h2 id="解决方案">解决方案</h2>
<p>所以回到主题，这就是为什么对于 C++ 的模板函数来说，要把模板函数的实现放到头文件中。</p>
<p><a href="http://main.cc">main.cc</a>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;A.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    a.<span class="built_in">print</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A.h：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; m &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>编译：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@└────&gt; # g++ main.cc -c</span><br><span class="line">@└────&gt; # nm main.o </span><br><span class="line">                 U __cxa_atexit</span><br><span class="line">                 U __dso_handle</span><br><span class="line">0000000000000059 t _GLOBAL__sub_I_main</span><br><span class="line">0000000000000000 T main</span><br><span class="line">000000000000001b t _Z41__static_initialization_and_destruction_0ii</span><br><span class="line">0000000000000000 W _ZN1A5printIiEEvv</span><br><span class="line">                 U _ZNSolsEi</span><br><span class="line">                 U _ZNSolsEPFRSoS_E</span><br><span class="line">                 U _ZNSt8ios_base4InitC1Ev</span><br><span class="line">                 U _ZNSt8ios_base4InitD1Ev</span><br><span class="line">                 U _ZSt4cout</span><br><span class="line">                 U _ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_</span><br><span class="line">0000000000000000 r _ZStL19piecewise_construct</span><br><span class="line">0000000000000000 b _ZStL8__ioinit</span><br></pre></td></tr></table></figure>
<p>可以看到 main.o 中包含 print 的符号。</p>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp纯虚函数和虚继承</title>
    <url>/20221227155444_537509689/</url>
    <content><![CDATA[<h2 id="虚继承和虚基类">虚继承和虚基类</h2>
<p>为了解决继承中的二义性问题，提出的虚基类和虚继承。虚继承只能解决具备公共祖先的多继承所带来的二义性问题，不能解决没有公共祖先的多继承的问题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~A()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">B</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~B()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;C()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">C</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~C()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">D</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;D()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">D</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~D()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    D d;</span><br><span class="line">    <span class="comment">// A* a = &amp;d;</span></span><br><span class="line">    <span class="comment">// test.cc: In function ‘int main()’:</span></span><br><span class="line">    <span class="comment">// test.cc:46:13: error: ‘A’ is an ambiguous base of ‘D’</span></span><br><span class="line">    <span class="comment">//     A* a = &amp;d;</span></span><br><span class="line">    <span class="comment">//             ^</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@└────&gt; # ./a.out </span><br><span class="line">A()</span><br><span class="line">B()</span><br><span class="line">A()</span><br><span class="line">C()</span><br><span class="line">D()</span><br><span class="line">~D()</span><br><span class="line">~C()</span><br><span class="line">~A()</span><br><span class="line">~B()</span><br><span class="line">~A()</span><br></pre></td></tr></table></figure>
<p>可以看到，在以上存在多继承且为菱形继承的情况下，构造函数的调用顺序是 ABACD，这表明继承 B 和 C 的时候夹杂了两份 A 的内容。这样也有一个问题，就是在试图用基类指针指向 D 对象时，编译器不知道应该让它指向哪个 A 的内存，因为在 d 中有两个 A 的实例。虚继承就是为了解决这个问题的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~A()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123; <span class="comment">// 虚继承，A 是 B 的虚基类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">B</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~B()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123; <span class="comment">// 虚继承，A 是 C 的虚基类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;C()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">C</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~C()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">D</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;D()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">D</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~D()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    D d;</span><br><span class="line">    A* a = &amp;d;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@└────&gt; # ./a.out </span><br><span class="line">A()</span><br><span class="line">B()</span><br><span class="line">C()</span><br><span class="line">D()</span><br><span class="line">~D()</span><br><span class="line">~C()</span><br><span class="line">~B()</span><br><span class="line">~A()</span><br></pre></td></tr></table></figure>
<p>这样 D 的内存中就只有一份 A 了，并且用基类指针指向该地址也能正确进行。<strong>虚基类并不是在声明基类时声明的</strong>，而是在声明派生类时，指定继承方式时声明的。因为一个基类可以在生成一个派生类时作为虚基类，而在生成另一个派生类时不作为虚基类。</p>
<h2 id="纯虚函数">纯虚函数</h2>
<p>cpp 支持编译时多态和运行时多态，函数重载就是编译时多态，而派生类和虚函数则为运行时多态。</p>
<p>编译时多态和运行时多态的区别就是函数地址是早绑定还是晚绑定。如果函数的调用，在<strong>编译阶段</strong>就可以确定函数的调用地址，并产生代码，就是编译时多态，就是说地址是早绑定的。而如果函数的调用地址不能在编译期间确定，而需要在运行时才能决定，这这就属于运行时多态。 向上类型转换问题，对象可以作为自己的类或者作为它的基类的对象来使用。还能通过基类的地址来操作它。取一个对象的地址（指针或引用），并将其作为基类的地址来处理，这种称为向上类型转换。也就是说：父类引用或指针可以指向子类对象，通过父类指针或引用来操作子类对象。</p>
<p>Cpp 动态多态性是通过虚函数来实现的，虚函数允许派生类重新定义基类成员函数，而派生类重新定义基类虚函数的做法称为覆盖（override），或者称为重写。这部分原理可见另一篇文章。 <a href="/20230206005045_37741/" title="cpp虚函数表">cpp虚函数表</a></p>
<p>在设计时，常常希望基类仅仅作为其派生类的一个接口。这就是说，仅想对基类进行向上类型转换，使用它的接口，而不希望用户实际的创建一个基类的对象。同时创建一个纯虚函数允许接口中放置成员原函数，而不一定要提供一段可能对这个函数毫无意义的代码。做到这点，可以在基类中加入至少一个纯虚函数（pure virtual function）,使得基类称为抽象类（abstract class）。</p>
<p>纯虚函数使用关键字 virtual，并在其后面加上 = 0。如果试图去实例化一个抽象类，编译器则会阻止这种操作。当继承一个抽象类的时候，必须实现<strong>所有的纯虚函数，否则由抽象类派生的类也是一个抽象类</strong>。virtual void fun() = 0，告诉编译器在vtable中为函数保留一个位置，但在这个特定位置不放地址。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数，表明 A 已经是抽象类了，不能实例化</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~A()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; <span class="comment">// 实现该函数，否则 B 因为抽象类而不能实例化</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B::func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">B</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~B()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// A a;</span></span><br><span class="line">    <span class="comment">//test.cc:26:7: error: cannot declare variable ‘a’ to be of abstract type ‘A’</span></span><br><span class="line">        <span class="comment">// A a;</span></span><br><span class="line">        <span class="comment">// ^</span></span><br><span class="line">    B b;</span><br><span class="line">    A* a = &amp;b;</span><br><span class="line">    a-&gt;<span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@└────&gt; # ./a.out </span><br><span class="line">A()</span><br><span class="line">B()</span><br><span class="line">B::func()</span><br><span class="line">~B()</span><br><span class="line">~A()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp线程池模板</title>
    <url>/20220504213234_4709/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PROCESSPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESSPOOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">process</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">process</span>() : <span class="built_in">m_pid</span>(<span class="number">-1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">pid_t</span> m_pid;</span><br><span class="line">    <span class="type">int</span> m_pipefd[<span class="number">2</span>]; <span class="comment">// 父进程和子进程通信用管道</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 模板参数是处理逻辑任务的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">processpool</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 定义为私有，只能通过create静态函数来创建processpool实例</span></span><br><span class="line">    <span class="built_in">processpool</span>(<span class="type">int</span> listenfd, <span class="type">int</span> process_number = <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 单例模式，是程序正确处理信号的必要条件</span></span><br><span class="line">    <span class="function"><span class="type">static</span> processpool&lt;T&gt; *<span class="title">create</span><span class="params">(<span class="type">int</span> listenfd, <span class="type">int</span> process_number = <span class="number">8</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!m_instance) &#123;</span><br><span class="line">            m_instance = <span class="keyword">new</span> <span class="built_in">processpool</span>&lt;T&gt;(listenfd, process_number);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_instance;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">processpool</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_sub_process;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setup_sig_pipe</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run_parent</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run_child</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MAX_PROCESS_NUMBER = <span class="number">16</span>; <span class="comment">// 最大子进程数量</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> USER_PER_PROCESS = <span class="number">65536</span>; <span class="comment">// 每个子进程处理最大客户数量</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MAX_EVENT_NUMBER = <span class="number">10000</span>; <span class="comment">// epoll最多能处理的事件数</span></span><br><span class="line">    <span class="type">int</span> m_process_number; <span class="comment">// 进程总数</span></span><br><span class="line">    <span class="type">int</span> m_idx; <span class="comment">// 子进程在池中序号</span></span><br><span class="line">    <span class="type">int</span> m_epollfd; <span class="comment">// 每个进程有个epoll内核事件表</span></span><br><span class="line">    <span class="type">int</span> m_listenfd; <span class="comment">// 监听socket</span></span><br><span class="line">    <span class="type">int</span> m_stop; <span class="comment">// 子进程通过m_stop判断是否停止运行</span></span><br><span class="line">    process *m_sub_process; <span class="comment">// 保存所有子进程描述信息</span></span><br><span class="line">    <span class="type">static</span> processpool&lt;T&gt; *m_instance; <span class="comment">// 进程池静态实例</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">processpool&lt;T&gt; *processpool&lt;T&gt;::m_instance = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> sig_pipefd[<span class="number">2</span>]; <span class="comment">// 信号管道 统一事件源</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="type">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> old_option = <span class="built_in">fcntl</span>(fd, F_GETFL);</span><br><span class="line">    <span class="type">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">    <span class="built_in">fcntl</span>(fd, F_SETFL, new_option);</span><br><span class="line">    <span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">addfd</span><span class="params">(<span class="type">int</span> epollfd, <span class="type">int</span> fd)</span> </span>&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.events = EPOLLIN | EPOLLET;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">    <span class="built_in">setnonblocking</span>(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">removefd</span><span class="params">(<span class="type">int</span> epollfd, <span class="type">int</span> fd)</span> </span>&#123; <span class="comment">// 从epollfd表示的内核事件表中删除fd的 所有事件</span></span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_DEL, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sig_handler</span><span class="params">(<span class="type">int</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> save_errno = errno;</span><br><span class="line">    <span class="type">int</span> msg = sig;</span><br><span class="line">    <span class="built_in">send</span>(sig_pipefd[<span class="number">1</span>], (<span class="type">char</span> *)&amp;msg, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    errno = save_errno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">addsig</span><span class="params">(<span class="type">int</span> sig, <span class="type">void</span>(handler)(<span class="type">int</span>), <span class="type">bool</span> restart = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> sa;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;sa, <span class="string">&#x27;\0&#x27;</span>, <span class="built_in">sizeof</span>(sa));</span><br><span class="line">    sa.sa_handler = handler;</span><br><span class="line">    <span class="keyword">if</span> (restart)</span><br><span class="line">    &#123;</span><br><span class="line">        sa.sa_flags |= SA_RESTART;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sigfillset</span>(&amp;sa.sa_mask);</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">sigaction</span>(sig, &amp;sa, <span class="literal">NULL</span>) != <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">processpool&lt;T&gt;::<span class="built_in">processpool</span>(<span class="type">int</span> listenfd, <span class="type">int</span> process_number) <span class="comment">// 进程池构造函数，参数listenfd是监听的socket，必须在创建进程池之前被创建</span></span><br><span class="line">    : <span class="built_in">m_listenfd</span>(listenfd), <span class="built_in">m_process_number</span>(process_number), <span class="built_in">m_idx</span>(<span class="number">-1</span>), <span class="built_in">m_stop</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="built_in">assert</span>((process_number &gt; <span class="number">0</span>) &amp;&amp; (process_number &lt;= MAX_PROCESS_NUMBER));</span><br><span class="line"></span><br><span class="line">    m_sub_process = <span class="keyword">new</span> process[process_number];</span><br><span class="line">    <span class="built_in">assert</span>(m_sub_process);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; process_number; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">socketpair</span>(PF_UNIX, SOCK_STREAM, <span class="number">0</span>, m_sub_process[i].m_pipefd);</span><br><span class="line">        <span class="built_in">assert</span>(ret == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        m_sub_process[i].m_pid = fork();</span><br><span class="line">        <span class="built_in">assert</span>(m_sub_process[i].m_pid &gt;= <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (m_sub_process[i].m_pid &gt; <span class="number">0</span>) &#123; <span class="comment">// 父进程</span></span><br><span class="line">            <span class="built_in">close</span>(m_sub_process[i].m_pipefd[<span class="number">1</span>]); <span class="comment">// 只向子进程写</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 子进程</span></span><br><span class="line">            <span class="built_in">close</span>(m_sub_process[i].m_pipefd[<span class="number">0</span>]); <span class="comment">// 只从父进程读</span></span><br><span class="line">            m_idx = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> processpool&lt;T&gt;::<span class="built_in">setup_sig_pipe</span>() &#123; <span class="comment">// 统一事件源</span></span><br><span class="line">    m_epollfd = <span class="built_in">epoll_create</span>(<span class="number">5</span>); <span class="comment">// 创建epoll事件监听表和信号管道</span></span><br><span class="line">    <span class="built_in">assert</span>(m_epollfd != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">socketpair</span>(PF_UNIX, SOCK_STREAM, <span class="number">0</span>, sig_pipefd);</span><br><span class="line">    <span class="built_in">assert</span>(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setnonblocking</span>(sig_pipefd[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">addfd</span>(m_epollfd, sig_pipefd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">addsig</span>(SIGCHLD, sig_handler); <span class="comment">// 设置信号处理函数</span></span><br><span class="line">    <span class="built_in">addsig</span>(SIGTERM, sig_handler);</span><br><span class="line">    <span class="built_in">addsig</span>(SIGINT, sig_handler);</span><br><span class="line">    <span class="built_in">addsig</span>(SIGPIPE, SIG_IGN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> processpool&lt;T&gt;::<span class="built_in">run</span>() &#123; <span class="comment">// 父进程中m_idx值为 -1， 子进程中m_idx值 &gt;= 0，判断接下来运行的是父还是子进程的代码</span></span><br><span class="line">    <span class="keyword">if</span> (m_idx != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">run_child</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">run_parent</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> processpool&lt;T&gt;::<span class="built_in">run_child</span>() &#123;</span><br><span class="line">    <span class="built_in">setup_sig_pipe</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pipefd = m_sub_process[m_idx].m_pipefd[<span class="number">1</span>]; <span class="comment">// 每个子进程都通过其在进程池中的序号值m_idx找到与父进程通信的管道</span></span><br><span class="line">    <span class="built_in">addfd</span>(m_epollfd, pipefd); <span class="comment">// 子进程需要监听管道文件描述符pipefd 因为父进程将通过它通知子进程accept新连接</span></span><br><span class="line"></span><br><span class="line">    epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line">    T *users = <span class="keyword">new</span> T[USER_PER_PROCESS];</span><br><span class="line">    <span class="built_in">assert</span>(users);</span><br><span class="line">    <span class="type">int</span> number = <span class="number">0</span>; <span class="comment">// epoll事件数量</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!m_stop) &#123;</span><br><span class="line">        number = <span class="built_in">epoll_wait</span>(m_epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> ((number &lt; <span class="number">0</span>) &amp;&amp; (errno != EINTR)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123; <span class="comment">// 处理每个事件</span></span><br><span class="line">            <span class="type">int</span> sockfd = events[i].data.fd;</span><br><span class="line">            <span class="keyword">if</span> ((sockfd == pipefd) &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123; <span class="comment">// 父进程有数据给子进程</span></span><br><span class="line">                <span class="type">int</span> client = <span class="number">0</span>;</span><br><span class="line">                ret = <span class="built_in">recv</span>(sockfd, (<span class="type">char</span> *)&amp;client, <span class="built_in">sizeof</span>(client), <span class="number">0</span>); <span class="comment">// 从父子进程之间管道读取数据，结果保存client中读取成功有新客户</span></span><br><span class="line">                <span class="keyword">if</span> (((ret &lt; <span class="number">0</span>) &amp;&amp; (errno != EAGAIN)) || ret == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">struct</span> sockaddr_in client_address;</span><br><span class="line">                    <span class="type">socklen_t</span> client_addrlength = <span class="built_in">sizeof</span>(client_address);</span><br><span class="line">                    <span class="type">int</span> connfd = <span class="built_in">accept</span>(m_listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;client_address, &amp;client_addrlength);</span><br><span class="line">                    <span class="keyword">if</span> (connfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;errno is: %d\n&quot;</span>, errno);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">addfd</span>(m_epollfd, connfd); <span class="comment">// 模板类T必须实现init方法，初始化一个客户连接。我们用connfd来索引处理的逻辑对象 提高效率</span></span><br><span class="line">                    users[connfd].<span class="built_in">init</span>(m_epollfd, connfd, client_address); <span class="comment">// 实现在cgi_server.cpp中</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((sockfd == sig_pipefd[<span class="number">0</span>]) &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123; <span class="comment">// 有信号，处理信号</span></span><br><span class="line">                <span class="type">int</span> sig;</span><br><span class="line">                <span class="type">char</span> signals[<span class="number">1024</span>];</span><br><span class="line">                ret = <span class="built_in">recv</span>(sig_pipefd[<span class="number">0</span>], signals, <span class="built_in">sizeof</span>(signals), <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ret; ++i) &#123;</span><br><span class="line">                        <span class="keyword">switch</span> (signals[i]) &#123;</span><br><span class="line">                            <span class="keyword">case</span> SIGCHLD: &#123; <span class="comment">// 回收子进程资源</span></span><br><span class="line">                                <span class="type">pid_t</span> pid;</span><br><span class="line">                                <span class="type">int</span> stat;</span><br><span class="line">                                <span class="keyword">while</span> ((pid = <span class="built_in">waitpid</span>(<span class="number">-1</span>, &amp;stat, WNOHANG)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                    <span class="keyword">continue</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">case</span> SIGTERM:</span><br><span class="line">                            <span class="keyword">case</span> SIGINT: &#123;</span><br><span class="line">                                m_stop = <span class="literal">true</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">default</span>: &#123;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123; <span class="comment">// 其他数据可读 必然是客户请求到来 调用逻辑处理对象的process方法处理</span></span><br><span class="line">                users[sockfd].<span class="built_in">process</span>(); <span class="comment">// 还没实现</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] users;</span><br><span class="line">    users = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">close</span>(pipefd);</span><br><span class="line">    <span class="comment">//close( m_listenfd ); // 应该由m_listenfd的创建者来关闭，所谓的对象由哪个函数创建，就该由那个函数销毁</span></span><br><span class="line">    <span class="built_in">close</span>(m_epollfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> processpool&lt;T&gt;::<span class="built_in">run_parent</span>() &#123;</span><br><span class="line">    <span class="built_in">setup_sig_pipe</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">addfd</span>(m_epollfd, m_listenfd);</span><br><span class="line"></span><br><span class="line">    epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line">    <span class="type">int</span> sub_process_counter = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> new_conn = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!m_stop) &#123;</span><br><span class="line">        number = <span class="built_in">epoll_wait</span>(m_epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> ((number &lt; <span class="number">0</span>) &amp;&amp; (errno != EINTR)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line">            <span class="type">int</span> sockfd = events[i].data.fd;</span><br><span class="line">            <span class="keyword">if</span> (sockfd == m_listenfd) &#123;</span><br><span class="line">                <span class="type">int</span> i = sub_process_counter; <span class="comment">// 有新连接到来，就采用round robin方式将其分给一个子进程</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (m_sub_process[i].m_pid != <span class="number">-1</span>) &#123; <span class="comment">// 选出空闲进程的进程数组索引</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    i = (i + <span class="number">1</span>) % m_process_number;</span><br><span class="line">                &#125; <span class="keyword">while</span> (i != sub_process_counter);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (m_sub_process[i].m_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">                    m_stop = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sub_process_counter = (i + <span class="number">1</span>) % m_process_number;</span><br><span class="line">                <span class="comment">//send( m_sub_process[sub_process_counter++].m_pipefd[0], ( char* )&amp;new_conn, sizeof( new_conn ), 0 );</span></span><br><span class="line">                <span class="built_in">send</span>(m_sub_process[i].m_pipefd[<span class="number">0</span>], (<span class="type">char</span> *)&amp;new_conn, <span class="built_in">sizeof</span>(new_conn), <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;send request to child %d\n&quot;</span>, i);</span><br><span class="line">                <span class="comment">//sub_process_counter %= m_process_number;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((sockfd == sig_pipefd[<span class="number">0</span>]) &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123; <span class="comment">// 处理父进程收到的信号</span></span><br><span class="line">                <span class="type">int</span> sig;</span><br><span class="line">                <span class="type">char</span> signals[<span class="number">1024</span>];</span><br><span class="line">                ret = <span class="built_in">recv</span>(sig_pipefd[<span class="number">0</span>], signals, <span class="built_in">sizeof</span>(signals), <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ret; ++i) &#123;</span><br><span class="line">                        <span class="keyword">switch</span> (signals[i]) &#123;</span><br><span class="line">                            <span class="keyword">case</span> SIGCHLD: &#123;</span><br><span class="line">                                <span class="type">pid_t</span> pid;</span><br><span class="line">                                <span class="type">int</span> stat;</span><br><span class="line">                                <span class="keyword">while</span> ((pid = <span class="built_in">waitpid</span>(<span class="number">-1</span>, &amp;stat, WNOHANG)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_process_number; ++i) &#123;</span><br><span class="line">                                        <span class="comment">// 如果进程池中第i个子进程退出了，则主进程关闭对应通信管道，并设置m_pid为-1，标记子进程已经退出</span></span><br><span class="line">                                        <span class="keyword">if</span> (m_sub_process[i].m_pid == pid) &#123;</span><br><span class="line">                                            <span class="built_in">printf</span>(<span class="string">&quot;child %d join\n&quot;</span>, i);</span><br><span class="line">                                            <span class="built_in">close</span>(m_sub_process[i].m_pipefd[<span class="number">0</span>]);</span><br><span class="line">                                            m_sub_process[i].m_pid = <span class="number">-1</span>;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                                m_stop = <span class="literal">true</span>;</span><br><span class="line">                                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_process_number; ++i) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (m_sub_process[i].m_pid != <span class="number">-1</span>) &#123;</span><br><span class="line">                                        m_stop = <span class="literal">false</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">case</span> SIGTERM:</span><br><span class="line">                            <span class="keyword">case</span> SIGINT: &#123;</span><br><span class="line">                                <span class="built_in">printf</span>(<span class="string">&quot;kill all the clild now\n&quot;</span>); <span class="comment">// 杀了所有子进程</span></span><br><span class="line">                                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_process_number; ++i) &#123;</span><br><span class="line">                                    <span class="type">int</span> pid = m_sub_process[i].m_pid;</span><br><span class="line">                                    <span class="keyword">if</span> (pid != <span class="number">-1</span>) &#123;</span><br><span class="line">                                        <span class="built_in">kill</span>(pid, SIGTERM);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">default</span>: &#123;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//close( m_listenfd ); // 由创建者关闭  见后文</span></span><br><span class="line">    <span class="built_in">close</span>(m_epollfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>此头文件需要传入cgi模板类以进行实例化线程池。模板代码见下一节。</p>
<hr>
<p>reference:<br>
linux高性能服务器编程——游双</p>
]]></content>
      <categories>
        <category>concurrent-programming</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp继承详解</title>
    <url>/20220524164812_1699034744/</url>
    <content><![CDATA[<h2 id="继承目的">继承目的</h2>
<p>继承的本质是为了复用代码，派生类复用基类的代码，从而减少冗余的代码，使得创建和维护一个引用变得更加容易。继承代表的是 is-a 的关系。</p>
<h2 id="继承种类">继承种类</h2>
<h3 id="公有继承">公有继承</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) : <span class="built_in">pub</span>(a), <span class="built_in">pro</span>(b), <span class="built_in">priv</span>(c) &#123;&#125;</span><br><span class="line">    <span class="type">int</span> pub;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> pro;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> priv;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123; <span class="comment">// 公有继承</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) &#123;</span><br><span class="line">        pub = a;</span><br><span class="line">        pro = b;</span><br><span class="line">        <span class="comment">// pri = c;</span></span><br><span class="line">        <span class="comment">// test.cc:20:9: error: ‘pri’ was not declared in this scope</span></span><br><span class="line">        <span class="comment">//       pri = c;</span></span><br><span class="line">        <span class="comment">//       ^~~</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">B <span class="title">b</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b.pub:&quot;</span> &lt;&lt; b.pub &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;b.pro:&quot; &lt;&lt; b.pro &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// test.cc:31:27: error: ‘int A::pro’ is protected within this context</span></span><br><span class="line">    <span class="comment">//  cout &lt;&lt; &quot;b.pro:&quot; &lt;&lt; b.pro &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//                        ^~~</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;b.priv:&quot; &lt;&lt; b.priv &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// test.cc:32:28: error: ‘int A::priv’ is private within this context</span></span><br><span class="line">    <span class="comment">//  cout &lt;&lt; &quot;b.priv:&quot; &lt;&lt; b.priv &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//                         ^~~~</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@└────&gt; # ./a.out </span><br><span class="line">b.pub:1</span><br></pre></td></tr></table></figure>
<p>可以看到，公有继承即保留基类的成员属性，公有 =&gt; 公有，保护 =&gt; 保护，私有 =&gt; 无法访问。</p>
<h3 id="保护继承">保护继承</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) : <span class="built_in">pub</span>(a), <span class="built_in">pro</span>(b), <span class="built_in">priv</span>(c) &#123;&#125;</span><br><span class="line">    <span class="type">int</span> pub;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> pro;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> priv;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">protected</span> A &#123; <span class="comment">// 保护继承 </span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) &#123;</span><br><span class="line">        pub = a;</span><br><span class="line">        pro = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">B <span class="title">b</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b.pub:&quot;</span> &lt;&lt; b.pub &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@└────&gt; # g++ test.cc </span><br><span class="line">test.cc: In function ‘int main()’:</span><br><span class="line">test.cc:25:27: error: ‘int A::pub’ is inaccessible within this context</span><br><span class="line">     cout &lt;&lt; &quot;b.pub:&quot; &lt;&lt; b.pub &lt;&lt; endl;</span><br><span class="line">                           ^~~</span><br></pre></td></tr></table></figure>
<p>保护继承会把 公有 =&gt; 保护，保护 =&gt; 保护, 私有 =&gt; 无法访问。所以原先的公有成员也不能以公有形式访问了。</p>
<h3 id="私有继承">私有继承</h3>
<p>私有继承结果和保护一样，公有 =&gt; 私有，保护 =&gt; 私有，私有 =&gt; 无法访问。</p>
<h2 id="覆写规则">覆写规则</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A::func(int a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B::func(int a, int b)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.<span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@└────&gt; # g++ test.cc </span><br><span class="line">test.cc: In function ‘int main()’:</span><br><span class="line">test.cc:20:14: error: no matching function for call to ‘B::func(int)’</span><br><span class="line">     b.func(10);</span><br><span class="line">              ^</span><br><span class="line">test.cc:13:10: note: candidate: ‘void B::func(int, int)’</span><br><span class="line">     void func(int a, int b) &#123;</span><br><span class="line">          ^~~~</span><br><span class="line">test.cc:13:10: note:   candidate expects 2 arguments, 1 provided</span><br></pre></td></tr></table></figure>
<p>在基类中的某些函数，如果没有 virtual 关键字，函数名是 func （参数类型我们不管）。如果派生类中也声明了这个成员函数，那在派生类的作用域中，所有和这个函数同名的函数都被隐藏。</p>
<p>如果基类中的函数和派生类中有两个名字一样的函数 func 满足下面的两个条件</p>
<ol>
<li>在基类中函数声明的时候有 virtual 关键字</li>
<li>基类中的函数和派生类中的函数一模一样，包括函数名，参数，返回类型都一样。</li>
</ol>
<p>那么这就是叫做覆盖（override），这也就是虚函数，多态的性质。其他的情况，只要名字一样，不满足上面覆盖的条件，就是隐藏。</p>
<p>好多人认为，基类中的函数会继承下来和派生类中的同名不同参的函数构成重载。</p>
<blockquote>
<p>重载（overload）：<br>
必须在<strong>一个域</strong>中，函数名称相同但是函数参数不同。重载的作用就是同一个函数有不同的行为，因此不是在一个域中的函数是无法构成重载的。</p>
</blockquote>
<p>必须在一个域中，而继承是在两个类中了，所以上面的想法是不成立的。所以，相同的函数名的函数，在基类和派生类中的关系只能是覆盖或者隐藏。</p>
<blockquote>
<p>隐藏（hide）:<br>
指派生类的成员函数隐藏了基类函数的成员函数。隐藏一词可以这么理解:在调用一个类的成员函数的时候，编译器会沿着类的继承链，逐级的向上查找函数的定义，如果找到了那么就停止查找。所以如果一个派生类和一个基类都有同一个同名（暂且不论参数是否相同）的函数，而编译器最终选择了在派生类中的函数，那么这个派生类的成员函数“隐藏”了基类的成员函数，阻止了编译器继续向上查找函数的定义。</p>
</blockquote>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp虚函数</title>
    <url>/20230427093748_377756562/</url>
    <content><![CDATA[<h2 id="多态">多态</h2>
<ol>
<li>静态多态：相同对象接收到不同的消息，产生不同的结果 =&gt; 函数重载。</li>
<li>动态多态：不同对象接收到相同的消息，产生不同的结果 =&gt; 虚函数。</li>
</ol>
<p>多态的作用就是为了提供高度统一的接口，实现代码复用，提高代码的可扩展性和可维护性。</p>
<h2 id="虚函数">虚函数</h2>
<h3 id="虚函数表">虚函数表</h3>
<p>虚函数的实现原理可见另一文章：<a href="/20230206005045_37741/" title="cpp虚函数表">关于cpp虚函数表的实现原理</a>。</p>
<h3 id="使用限制">使用限制</h3>
<h4 id="0-virtual-具有继承性-父类中定义为-virtual-的函数在子类中重写的函数也自动成为虚函数。需要注意的是，只有子类的虚函数和父类的虚函数定义完全一样才被认为是虚函数。">0. virtual 具有继承性: 父类中定义为 virtual 的函数在子类中重写的函数也自动成为虚函数。需要注意的是，只有子类的虚函数和父类的虚函数<strong>定义完全一样</strong>才被认为是虚函数。</h4>
<h4 id="1-virtual-不能修饰类外的普通函数，只能修饰类中的成员函数（普通函数和析构函数）。">1. virtual 不能修饰类外的普通函数，只能修饰类中的成员函数（普通函数和析构函数）。</h4>
<p>这句话很好理解，就是 virtual 关键字不能修饰全局函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">test</span> <span class="params">()</span> </span>&#123; <span class="comment">// 不正确，不能修饰全局函数</span></span><br><span class="line">    <span class="comment">// do some thing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译报错：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">error: ‘virtual’ outside class declaration</span><br></pre></td></tr></table></figure>
<h4 id="2-virtual-不能修饰构造函数。">2. virtual 不能修饰构造函数。</h4>
<ul>
<li>从存储空间角度，虚函数的每个对象内部都有一个指向虚函数表的指针。那么虚函数表是什么时候初始化的呢？就是在调用构造函数的时候。cpp 调用 new 的步骤是，先申请所需的内存（malloc/operator new），再调用构造函数。如果构造函数是虚的，那必须通过虚函数表指针来找到虚构造函数的入口地址。然而此时申请的内存还没有初始化，不可能由虚函数表和虚函数表指针的。综上所述，构造函数不能为虚函数。</li>
<li>从使用角度，构造函数是创建对象时调用的，不可能通过父类的指针或引用去调用。创建一个对象时，总是要明确指定对象的类型。但是析构函数不一样，可以通过基类指针进行析构。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A* a = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译报错：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">error: constructors cannot be declared ‘virtual’</span><br></pre></td></tr></table></figure>
<h4 id="3-virtual-不能修饰静态成员函数。">3. virtual 不能修饰静态成员函数。</h4>
<p>虚函数的调用时经过对象内部的虚函数表指针，找到虚函数表，进而去调用对应的函数。但是静态成员函数和实例没有关系，只和类有关。所以调用时不会隐式传入 this 指针。题外话，因为没有 this 指针，静态函数也不能声明为 const 和 volatile。因为 void func() const {} 会被转换为 void func(const A *this) {};</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;print&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A* a = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">    a-&gt;<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译报错：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">error: member ‘print’ cannot be declared both ‘virtual’ and ‘static’</span><br></pre></td></tr></table></figure>
<h4 id="4-virtual-不能修饰内联函数。">4. virtual 不能修饰内联函数。</h4>
<p>内联函数关键字 inline 是对编译器的一个建议：如果可能，请把此函数变为内联函数。虚函数是由虚函数表实现的，因为表中需要存放函数的地址。被内联展开的函数没有具体的地址，所以无法被 virtual 修饰。但是以下写法也不会报编译错误。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;print&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因为内联函数的建议编译器没有采纳，就和没有加 inline 关键字效果一样。</p>
<h4 id="5-virtual-不能修饰友元函数。">5. virtual 不能修饰友元函数。</h4>
<p>友元函数是可以访问类内私有成员的<strong>非成员函数</strong>，是定义在类外的<strong>普通函数</strong>。它不属于某个类，所以自然无法被 virtual 修饰。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">friend</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;print&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A* a = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译报错：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">error: virtual functions cannot be friends</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp虚函数表</title>
    <url>/20230206005045_37741/</url>
    <content><![CDATA[<h1>1. 单继承虚函数表</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span>  a;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;A::f()&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;A::g()&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;B::f()&quot;</span>&lt;&lt;endl;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;B::g1()&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;B::h()&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*fun)</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">    fun pFun;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义了两个对象，B继承自A。 B重写了A的f()函数，并新增了一个虚成员函数g1()和一个普通的成员函数h()。那么对象a，b的内存布局应该如下图所示：<br>
<img src="/20230206005045_37741/1.png" alt="1"></p>
<p>口说无凭，我们用gdb打印一下看看。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ gdb a.<span class="function">exe</span></span><br><span class="line"><span class="function">GNU <span class="title">gdb</span> <span class="params">(GDB)</span> 7.6.1</span></span><br><span class="line"><span class="function"><span class="title">Copyright</span> <span class="params">(C)</span> 2013 Free Software Foundation, Inc.</span></span><br><span class="line"><span class="function">License GPLv3+: GNU GPL version <span class="number">3</span> or later &lt;http://gnu.org/licenses/gpl.html&gt;</span></span><br><span class="line"><span class="function">This is free software: you are free to change and redistribute it.</span></span><br><span class="line"><span class="function">There is NO WARRANTY, to the extent permitted by law.  Type <span class="string">&quot;show copying&quot;</span></span></span><br><span class="line"><span class="function">and <span class="string">&quot;show warranty&quot;</span> for details.</span></span><br><span class="line"><span class="function">This GDB was configured as <span class="string">&quot;mingw32&quot;</span>.</span></span><br><span class="line"><span class="function">For bug reporting instructions, please see:</span></span><br><span class="line"><span class="function">&lt;http://www.gnu.org/software/gdb/bugs/&gt;...</span></span><br><span class="line"><span class="function">Reading symbols from F:\zkangHUST\C++\a.exe...done.</span></span><br><span class="line"><span class="function">(gdb) start</span></span><br><span class="line"><span class="function">Temporary breakpoint <span class="number">1</span> at <span class="number">0x40146e</span>: file test3.cpp, line <span class="number">32.</span></span></span><br><span class="line"><span class="function">Starting program: F:\zkangHUST\C++/a.exe</span></span><br><span class="line"><span class="function">[New Thread <span class="number">10860.0</span>x2e0c]</span></span><br><span class="line"><span class="function">[New Thread <span class="number">10860.0</span>x3e64]</span></span><br><span class="line"><span class="function">[New Thread <span class="number">10860.0</span>x3e94]</span></span><br><span class="line"><span class="function">[New Thread <span class="number">10860.0</span>x8]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Temporary breakpoint <span class="number">1</span>, main () at test3.cpp:<span class="number">32</span></span></span><br><span class="line"><span class="function"><span class="number">32</span>          A a;</span></span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">33</span>          B b;</span><br><span class="line">(gdb)</span><br><span class="line"><span class="number">51</span>          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">(gdb) p a</span><br><span class="line">$<span class="number">1</span> = &#123;_vptr.A = <span class="number">0x405178</span> &lt;vtable <span class="keyword">for</span> A+<span class="number">8</span>&gt;, a = <span class="number">4194432</span>&#125;</span><br><span class="line">(gdb) <span class="built_in">p</span> (<span class="type">int</span>*)*((<span class="type">int</span>*)<span class="number">0x405178</span>)</span><br><span class="line">$<span class="number">2</span> = (<span class="type">int</span> *) <span class="number">0x403c08</span> &lt;A::<span class="built_in">f</span>()&gt;</span><br><span class="line">(gdb) <span class="built_in">p</span> (<span class="type">int</span>*)*((<span class="type">int</span>*)<span class="number">0x405178</span> + <span class="number">1</span>)</span><br><span class="line">$<span class="number">3</span> = (<span class="type">int</span> *) <span class="number">0x403c3c</span> &lt;A::<span class="built_in">g</span>()&gt;</span><br><span class="line">(gdb) <span class="built_in">p</span> (<span class="type">int</span>*)*((<span class="type">int</span>*)<span class="number">0x405178</span> + <span class="number">2</span>)</span><br><span class="line">$<span class="number">4</span> = (<span class="type">int</span> *) <span class="number">0x0</span></span><br><span class="line">(gdb) p b</span><br><span class="line">$<span class="number">5</span> = &#123;&lt;A&gt; = &#123;_vptr.A = <span class="number">0x405188</span> &lt;vtable <span class="keyword">for</span> B+<span class="number">8</span>&gt;, a = <span class="number">4200896</span>&#125;, b = <span class="number">0</span>&#125;</span><br><span class="line">(gdb) <span class="built_in">p</span> (<span class="type">int</span>*)*((<span class="type">int</span>*)<span class="number">0x405188</span>)</span><br><span class="line">$<span class="number">6</span> = (<span class="type">int</span> *) <span class="number">0x403ca0</span> &lt;B::<span class="built_in">f</span>()&gt;</span><br><span class="line">(gdb) <span class="built_in">p</span> (<span class="type">int</span>*)*((<span class="type">int</span>*)<span class="number">0x405188</span>+<span class="number">1</span>)</span><br><span class="line">$<span class="number">7</span> = (<span class="type">int</span> *) <span class="number">0x403c3c</span> &lt;A::<span class="built_in">g</span>()&gt;</span><br><span class="line">(gdb) <span class="built_in">p</span> (<span class="type">int</span>*)*((<span class="type">int</span>*)<span class="number">0x405188</span>+<span class="number">2</span>)</span><br><span class="line">$<span class="number">8</span> = (<span class="type">int</span> *) <span class="number">0x403cd4</span> &lt;B::<span class="built_in">g1</span>()&gt;</span><br><span class="line">(gdb) <span class="built_in">p</span> (<span class="type">int</span>*)*((<span class="type">int</span>*)<span class="number">0x405188</span>+<span class="number">3</span>)</span><br><span class="line">$<span class="number">9</span> = (<span class="type">int</span> *) <span class="number">0x3a434347</span></span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure>
<p>a的虚函数表地址是0x405178，把这个地址强制转换成int指针,对改指针取值即是虚函数表第一个函数的地址，可以转换成int指针，打印出来。可以看到，虚函数表跟我们分析的是一样的。这里有一个问题，可以看到A的虚函数表是以空地址结束的，B的虚函数结束的位置是一个随机值，可见虚函数表并不一定是以空地址结束。另外，B类新增的h()函数没有加入到虚函数表中，因为它不是一个虚函数，这个函数怎么调用已经在程序编译的过程中确定了(即所谓静态联编，也叫早期联编)。<br>
同理，如果有第三个类C像下面这样继承类B。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:<span class="keyword">public</span> B &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> c;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;C::f()&quot;</span>&lt;&lt;endl;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;C::g1()&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">k</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;C::k()&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>那么C对象的内存应该如下图:<br>
<img src="/20230206005045_37741/2.png" alt="2"><br>
gdb打印结果如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(gdb) p c</span><br><span class="line">$<span class="number">1</span> = &#123;&lt;B&gt; = &#123;&lt;A&gt; = &#123;_vptr.A = <span class="number">0x4051c0</span> &lt;vtable <span class="keyword">for</span> C+<span class="number">8</span>&gt;, a = <span class="number">1948871853</span>&#125;, b = <span class="number">4200912</span>&#125;, c = <span class="number">6422368</span>&#125;</span><br><span class="line">(gdb) <span class="built_in">p</span> (<span class="type">int</span>*)*((<span class="type">int</span>*)<span class="number">0x4051c0</span>)</span><br><span class="line">$<span class="number">2</span> = (<span class="type">int</span> *) <span class="number">0x403d58</span> &lt;C::<span class="built_in">f</span>()&gt;</span><br><span class="line">(gdb) <span class="built_in">p</span> (<span class="type">int</span>*)*((<span class="type">int</span>*)<span class="number">0x4051c0</span> + <span class="number">1</span>)</span><br><span class="line">$<span class="number">3</span> = (<span class="type">int</span> *) <span class="number">0x403c4c</span> &lt;A::<span class="built_in">g</span>()&gt;</span><br><span class="line">(gdb) <span class="built_in">p</span> (<span class="type">int</span>*)*((<span class="type">int</span>*)<span class="number">0x4051c0</span> + <span class="number">2</span>)</span><br><span class="line">$<span class="number">4</span> = (<span class="type">int</span> *) <span class="number">0x403dc0</span> &lt;C::<span class="built_in">g1</span>()&gt;</span><br><span class="line">(gdb) <span class="built_in">p</span> (<span class="type">int</span>*)*((<span class="type">int</span>*)<span class="number">0x4051c0</span> + <span class="number">3</span>)</span><br><span class="line">$<span class="number">5</span> = (<span class="type">int</span> *) <span class="number">0x403d8c</span> &lt;C::<span class="built_in">k</span>()&gt;</span><br><span class="line">(gdb) <span class="built_in">p</span> (<span class="type">int</span>*)*((<span class="type">int</span>*)<span class="number">0x4051c0</span> + <span class="number">4</span>)</span><br><span class="line">$<span class="number">6</span> = (<span class="type">int</span> *) <span class="number">0x3a434347</span></span><br></pre></td></tr></table></figure>
<h1>2. 多继承（无虚函数覆盖）</h1>
<p>单继承的虚函数表比较简单，现在来看下多继承的虚函数表是什么样的。首先看多继承无虚函数覆盖的情况。假设有四个类A,B,C,D。继承关系如下图。<br>
<img src="/20230206005045_37741/3.png" alt="3"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span>  a;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;A::f()&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;A::g()&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;B::f()&quot;</span>&lt;&lt;endl;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;B::g()&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;C::f()&quot;</span>&lt;&lt;endl;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;C::g1()&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>:<span class="keyword">public</span> A,<span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">       <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           cout&lt;&lt;<span class="string">&quot;D::h()&quot;</span>&lt;&lt;endl;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>子类继承了多个父类，在内存中会维持多张虚函数表，有几个父类就有几张虚函数表。同时，自己新加的虚函数会附加到第一个父类的虚函数表后面。类D的内存布局如图：<br>
<img src="/20230206005045_37741/4.png" alt="4"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    D d;</span><br><span class="line">    A* a = (A*)&amp;d;</span><br><span class="line">    B* b = (B*)&amp;d;</span><br><span class="line">    C* c = (C*)&amp;d;</span><br><span class="line">    a-&gt;<span class="built_in">f</span>();</span><br><span class="line">    b-&gt;<span class="built_in">f</span>();</span><br><span class="line">    c-&gt;<span class="built_in">f</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(gdb) p d</span><br><span class="line">$<span class="number">1</span> = &#123;&lt;A&gt; = &#123;_vptr.A = <span class="number">0x4051f0</span> &lt;vtable <span class="keyword">for</span> D+<span class="number">8</span>&gt;, a = <span class="number">6422368</span>&#125;, &lt;B&gt; = &#123;_vptr.B = <span class="number">0x405204</span> &lt;vtable <span class="keyword">for</span> D+<span class="number">28</span>&gt;, a = <span class="number">4200896</span>&#125;, &lt;C&gt; = &#123;</span><br><span class="line">    _vptr.C = <span class="number">0x405214</span> &lt;vtable <span class="keyword">for</span> D+<span class="number">44</span>&gt;, a = <span class="number">3981312</span>&#125;, a = <span class="number">4194432</span>&#125;</span><br><span class="line">(gdb) <span class="built_in">p</span> (<span class="type">int</span>*)*((<span class="type">int</span>*)<span class="number">0x4051f0</span>)</span><br><span class="line">$<span class="number">2</span> = (<span class="type">int</span> *) <span class="number">0x403c08</span> &lt;A::<span class="built_in">f</span>()&gt;</span><br><span class="line">(gdb) <span class="built_in">p</span> (<span class="type">int</span>*)*((<span class="type">int</span>*)<span class="number">0x4051f0</span> + <span class="number">1</span>)</span><br><span class="line">$<span class="number">3</span> = (<span class="type">int</span> *) <span class="number">0x403c3c</span> &lt;A::<span class="built_in">g</span>()&gt;</span><br><span class="line">(gdb) <span class="built_in">p</span> (<span class="type">int</span>*)*((<span class="type">int</span>*)<span class="number">0x4051f0</span> + <span class="number">2</span>)</span><br><span class="line">$<span class="number">4</span> = (<span class="type">int</span> *) <span class="number">0x403d88</span> &lt;D::<span class="built_in">h</span>()&gt;</span><br><span class="line">(gdb) <span class="built_in">p</span> (<span class="type">int</span>*)*((<span class="type">int</span>*)<span class="number">0x4051f0</span> + <span class="number">3</span>)</span><br><span class="line">$<span class="number">5</span> = (<span class="type">int</span> *) <span class="number">0xfffffff8</span></span><br><span class="line">(gdb) <span class="built_in">p</span> (<span class="type">int</span>*)*((<span class="type">int</span>*)<span class="number">0x405204</span>)</span><br><span class="line">$<span class="number">6</span> = (<span class="type">int</span> *) <span class="number">0x403c88</span> &lt;B::<span class="built_in">f</span>()&gt;</span><br><span class="line">(gdb) <span class="built_in">p</span> (<span class="type">int</span>*)*((<span class="type">int</span>*)<span class="number">0x405204</span> + <span class="number">1</span>)</span><br><span class="line">$<span class="number">7</span> = (<span class="type">int</span> *) <span class="number">0x403cbc</span> &lt;B::<span class="built_in">g</span>()&gt;</span><br><span class="line">(gdb) <span class="built_in">p</span> (<span class="type">int</span>*)*((<span class="type">int</span>*)<span class="number">0x405204</span> + <span class="number">2</span>)</span><br><span class="line">$<span class="number">8</span> = (<span class="type">int</span> *) <span class="number">0xfffffff0</span></span><br><span class="line">(gdb) <span class="built_in">p</span> (<span class="type">int</span>*)*((<span class="type">int</span>*)<span class="number">0x405214</span>)</span><br><span class="line">$<span class="number">9</span> = (<span class="type">int</span> *) <span class="number">0x403d08</span> &lt;C::<span class="built_in">f</span>()&gt;</span><br><span class="line">(gdb) <span class="built_in">p</span> (<span class="type">int</span>*)*((<span class="type">int</span>*)<span class="number">0x405214</span> + <span class="number">1</span>)</span><br><span class="line">$<span class="number">10</span> = (<span class="type">int</span> *) <span class="number">0x403d3c</span> &lt;C::<span class="built_in">g</span>()&gt;</span><br><span class="line">(gdb) <span class="built_in">p</span> (<span class="type">int</span>*)*((<span class="type">int</span>*)<span class="number">0x405214</span> + <span class="number">2</span>)</span><br><span class="line">$<span class="number">11</span> = (<span class="type">int</span> *) <span class="number">0x3a434347</span></span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
<p>可见结构跟我们能分析得到的虚函数表图是一致的。做类型强制转换之后，a指针指向D类中第一个虚函数表，b指针指向第二张虚函数表，c指针指向第三张虚函数表。<br>
不过，从打印结果来看，a指向的地址与b指向的地址相差8,b指向的地址和c指向的地址也相差8。但是在32位系统中，一个指针所占用的字节数应该是4，为什么会是a,b,c之间会相差8呢？多出来的4字节其实是成员变量a所占用的字节。<br>
我们的内存布局图应该是这样：<br>
<img src="/20230206005045_37741/5.png" alt="5"><br>
A类占用8字节，B类占用8字节，C类占用8字节，D类占用28字节((4+4)*3+4)以上就是多继承无虚函数覆盖的虚函数表和对象内存布局情况。下面看一下有虚函数覆盖的情况。</p>
<h1>3. 多继承(有虚函数覆盖)</h1>
<p>上例的继承关系保存不变，在D类中重写f()方法，修改类D的定义为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>:<span class="keyword">public</span> A,<span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;D::f()&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;D::h()&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/20230206005045_37741/6.png" alt="6"><br>
也就是把A，B，C类虚函数表中各自的f()函数地址替换为D类重写的f()函数地址。</p>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>cuda性能分析工具nsys使用</title>
    <url>/20240519171831_2854729219/</url>
    <content><![CDATA[<h1>cuda性能分析工具nsys使用</h1>
<h2 id="安装-nsys-命令行工具">安装 nsys 命令行工具</h2>
<p>一般这个工具是随着 cuda toolkit 一起安装的。如果没有安装，可以查看网站：<a href="https://docs.nvidia.com/nsight-systems/InstallationGuide/index.html">https://docs.nvidia.com/nsight-systems/InstallationGuide/index.html</a> 。<br>
ubuntu可以用如下安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install -y --no-install-recommends gnupg</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb http://developer.download.nvidia.com/devtools/repos/ubuntu<span class="subst">$(source /etc/lsb-release; echo <span class="string">&quot;<span class="variable">$DISTRIB_RELEASE</span>&quot;</span> | tr -d .)</span>/<span class="subst">$(dpkg --print-architecture)</span> /&quot;</span> | <span class="built_in">tee</span> /etc/apt/sources.list.d/nvidia-devtools.list</span><br><span class="line">apt-key adv --fetch-keys http://developer.download.nvidia.com/compute/cuda/repos/ubuntu1804/x86_64/7fa2af80.pub</span><br><span class="line">apt update</span><br><span class="line">apt install nsight-systems-cli</span><br></pre></td></tr></table></figure>
<p>安装后可以尝试查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@└────&gt; <span class="comment"># nsys status -e</span></span><br><span class="line">Timestamp counter supported: Yes</span><br><span class="line"></span><br><span class="line">CPU Profiling Environment Check</span><br><span class="line">Root privilege: disabled</span><br><span class="line">Linux Kernel Paranoid Level = 4</span><br><span class="line">Linux Distribution = Ubuntu</span><br><span class="line">Linux Kernel Version = 5.15.0-105-generic: OK</span><br><span class="line">Linux perf_event_open syscall available: Fail</span><br><span class="line">Sampling trigger event available: Fail</span><br><span class="line">Intel(c) Last Branch Record support: Not Available</span><br><span class="line">CPU Profiling Environment (process-tree): Fail</span><br><span class="line">CPU Profiling Environment (system-wide): Fail</span><br><span class="line"></span><br><span class="line">See the product documentation at https://docs.nvidia.com/nsight-systems <span class="keyword">for</span> more information,</span><br><span class="line">including information on how to <span class="built_in">set</span> the Linux Kernel Paranoid Level.</span><br></pre></td></tr></table></figure>
<p>在可以使用 nsys 工具后，可以使用 nsys 来查看一些 kernel 的性能。<br>
举个例子，我们有以下 cuda 代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cuda.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cuda_runtime.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;device_launch_parameters.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_PER_BLOCK 256</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// baseline</span></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">reduce0</span><span class="params">(<span class="type">float</span>* d_in, <span class="type">float</span>* d_out)</span> </span>&#123;</span><br><span class="line">    __shared__ <span class="type">float</span> sdata[THREAD_PER_BLOCK];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// each thread loads one element from global to shared mem</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tid = threadIdx.x;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line">    sdata[tid] = d_in[i];</span><br><span class="line">    __syncthreads();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do reduction in shared mem</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> s = <span class="number">1</span>; s &lt; blockDim.x; s *= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tid % (<span class="number">2</span> * s) == <span class="number">0</span>) &#123;</span><br><span class="line">            sdata[tid] += sdata[tid + s];</span><br><span class="line">        &#125;</span><br><span class="line">        __syncthreads();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write result for this block to global mem</span></span><br><span class="line">    <span class="keyword">if</span> (tid == <span class="number">0</span>) &#123;</span><br><span class="line">        d_out[blockIdx.x] = sdata[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bank conflict</span></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">reduce1</span><span class="params">(<span class="type">float</span>* d_in, <span class="type">float</span>* d_out)</span> </span>&#123;</span><br><span class="line">    __shared__ <span class="type">float</span> sdata[THREAD_PER_BLOCK];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// each thread loads one element from global to shared mem</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tid = threadIdx.x;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line">    sdata[tid] = d_in[i];</span><br><span class="line">    __syncthreads();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do reduction in shared mem</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> s = <span class="number">1</span>; s &lt; blockDim.x; s *= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="number">2</span> * s * tid;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; blockDim.x) &#123;</span><br><span class="line">            sdata[index] += sdata[index + s];</span><br><span class="line">        &#125;</span><br><span class="line">        __syncthreads();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write result for this block to global mem</span></span><br><span class="line">    <span class="keyword">if</span> (tid == <span class="number">0</span>) &#123;</span><br><span class="line">        d_out[blockIdx.x] = sdata[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">float</span>* out, <span class="type">float</span>* res, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (out[i] != res[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> N = <span class="number">32</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="type">float</span>* a = (<span class="type">float</span>*)<span class="built_in">malloc</span>(N * <span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">    <span class="type">float</span>* d_a;</span><br><span class="line">    <span class="built_in">cudaMalloc</span>((<span class="type">void</span>**)&amp;d_a, N * <span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> block_num = N / THREAD_PER_BLOCK;</span><br><span class="line">    <span class="type">float</span>* out = (<span class="type">float</span>*)<span class="built_in">malloc</span>((N / THREAD_PER_BLOCK) * <span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">    <span class="type">float</span>* d_out;</span><br><span class="line">    <span class="built_in">cudaMalloc</span>((<span class="type">void</span>**)&amp;d_out, (N / THREAD_PER_BLOCK) * <span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">    <span class="type">float</span>* res = (<span class="type">float</span>*)<span class="built_in">malloc</span>((N / THREAD_PER_BLOCK) * <span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        a[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; block_num; i++) &#123;</span><br><span class="line">        <span class="type">float</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; THREAD_PER_BLOCK; j++) &#123;</span><br><span class="line">            cur += a[i * THREAD_PER_BLOCK + j];</span><br><span class="line">        &#125;</span><br><span class="line">        res[i] = cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cudaMemcpy</span>(d_a, a, N * <span class="built_in">sizeof</span>(<span class="type">float</span>), cudaMemcpyHostToDevice);</span><br><span class="line"></span><br><span class="line">    <span class="function">dim3 <span class="title">Grid</span><span class="params">(N / THREAD_PER_BLOCK, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">dim3 <span class="title">Block</span><span class="params">(THREAD_PER_BLOCK, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    reduce0&lt;&lt;&lt;Grid, Block&gt;&gt;&gt;(d_a, d_out);</span><br><span class="line">    <span class="built_in">cudaMemcpy</span>(out, d_out, block_num * <span class="built_in">sizeof</span>(<span class="type">float</span>), cudaMemcpyDeviceToHost);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>(out, res, block_num)) &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;the ans is right\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;the ans is wrong\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; block_num; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lf &quot;</span>, out[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reduce1&lt;&lt;&lt;Grid, Block&gt;&gt;&gt;(d_a, d_out);</span><br><span class="line">    <span class="built_in">cudaMemcpy</span>(out, d_out, block_num * <span class="built_in">sizeof</span>(<span class="type">float</span>), cudaMemcpyDeviceToHost);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>(out, res, block_num)) &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;the ans is right\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;the ans is wrong\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; block_num; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lf &quot;</span>, out[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cudaFree</span>(d_a);</span><br><span class="line">    <span class="built_in">cudaFree</span>(d_out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是一个 reduce_sum 的例子，有两个性能不同的核函数 reduce0 和 reduce1。可以使用命令行工具来看这两个工具的性能。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一个过渡方式，沿用之前 nvprof 的用法。</span></span><br><span class="line">@└────&gt; <span class="comment"># nsys nvprof ./a.out</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 后续支持的方式</span></span><br><span class="line">@└────&gt; <span class="comment"># nsys profile --stats=true ./a.out</span></span><br><span class="line">...</span><br><span class="line">[4/8] Executing <span class="string">&#x27;osrtsum&#x27;</span> stats report</span><br><span class="line"></span><br><span class="line"> Time (%)  Total Time (ns)  Num Calls    Avg (ns)       Med (ns)     Min (ns)     Max (ns)      StdDev (ns)            Name         </span><br><span class="line"> --------  ---------------  ---------  -------------  -------------  ---------  -------------  -------------  ----------------------</span><br><span class="line">     49.8    6,560,704,940         41  160,017,193.7  100,127,248.0      2,946  3,656,490,088  561,147,066.6  poll                  </span><br><span class="line">     40.5    5,331,726,596      1,591    3,351,179.5       34,054.0      1,200    405,442,288   30,016,785.5  ioctl                 </span><br><span class="line">      4.7      614,593,088         60   10,243,218.1   10,295,123.0  1,532,148     14,425,405    2,880,533.4  waitpid               </span><br><span class="line">      2.6      341,072,143         60    5,684,535.7    5,470,557.0    576,832     10,285,481    1,599,344.7  fork                  </span><br><span class="line">      2.4      312,589,312        113    2,766,277.1       14,265.0      4,724    267,144,344   25,109,089.4  open64                </span><br><span class="line">      0.0        5,684,320        144       39,474.4       11,704.5      1,108      3,826,795      317,952.4  fopen                 </span><br><span class="line">      0.0        2,034,643         38       53,543.2       10,234.5      3,945      1,236,239      198,417.6  mmap64                </span><br><span class="line">      0.0          607,662         10       60,766.2       56,248.0     42,036        112,182       19,745.1  sem_timedwait         </span><br><span class="line">      0.0          405,925        123        3,300.2        2,289.0      1,006         77,642        7,014.0  fclose                </span><br><span class="line">      0.0          391,343          4       97,835.8       80,675.0     58,047        171,946       53,486.5  pthread_create        </span><br><span class="line">      0.0          154,726         19        8,143.5        4,985.0      1,004         47,713       10,904.9  mmap                  </span><br><span class="line">      0.0           82,936          1       82,936.0       82,936.0     82,936         82,936            0.0  pthread_cond_wait     </span><br><span class="line">      0.0           78,328          8        9,791.0        4,877.5      2,074         40,677       12,827.6  munmap                </span><br><span class="line">      0.0           71,358          7       10,194.0        9,879.0      3,968         14,551        3,520.2  open                  </span><br><span class="line">      0.0           51,719          3       17,239.7       13,793.0      3,372         34,554       15,874.2  fread                 </span><br><span class="line">      0.0           42,644         29        1,470.5        1,295.0      1,000          5,372          801.5  fcntl                 </span><br><span class="line">      0.0           41,205          1       41,205.0       41,205.0     41,205         41,205            0.0  fgets                 </span><br><span class="line">      0.0           36,755         15        2,450.3        2,072.0      1,083          7,000        1,497.0  <span class="built_in">read</span>                  </span><br><span class="line">      0.0           33,701         12        2,808.4        2,360.0      1,384          6,014        1,224.1  write                 </span><br><span class="line">      0.0           30,013          3       10,004.3       11,976.0      5,640         12,397        3,785.5  pipe2                 </span><br><span class="line">      0.0           26,410          2       13,205.0       13,205.0     10,057         16,353        4,451.9  socket                </span><br><span class="line">      0.0           12,546          2        6,273.0        6,273.0      5,777          6,769          701.4  fwrite                </span><br><span class="line">      0.0           10,654          2        5,327.0        5,327.0      4,160          6,494        1,650.4  pthread_cond_broadcast</span><br><span class="line">      0.0           10,412          1       10,412.0       10,412.0     10,412         10,412            0.0  pthread_mutex_trylock </span><br><span class="line">      0.0            9,158          1        9,158.0        9,158.0      9,158          9,158            0.0  connect               </span><br><span class="line">      0.0            5,650          1        5,650.0        5,650.0      5,650          5,650            0.0  <span class="built_in">bind</span>                  </span><br><span class="line">      0.0            3,085          1        3,085.0        3,085.0      3,085          3,085            0.0  listen                </span><br><span class="line"></span><br><span class="line">[5/8] Executing <span class="string">&#x27;cudaapisum&#x27;</span> stats report</span><br><span class="line"></span><br><span class="line"> Time (%)  Total Time (ns)  Num Calls    Avg (ns)       Med (ns)      Min (ns)      Max (ns)      StdDev (ns)            Name         </span><br><span class="line"> --------  ---------------  ---------  -------------  -------------  -----------  -------------  -------------  ----------------------</span><br><span class="line">     77.1    1,961,601,754          2  980,800,877.0  980,800,877.0  674,626,715  1,286,975,039  432,995,652.3  cudaMalloc            </span><br><span class="line">     22.2      564,147,432          2  282,073,716.0  282,073,716.0  275,230,367    288,917,065    9,677,957.0  cudaFree              </span><br><span class="line">      0.7       17,105,648          3    5,701,882.7      657,298.0      434,348     16,014,002    8,931,253.0  cudaMemcpy            </span><br><span class="line">      0.0          415,480          2      207,740.0      207,740.0       42,497        372,983      233,688.9  cudaLaunchKernel      </span><br><span class="line">      0.0            1,368          1        1,368.0        1,368.0        1,368          1,368            0.0  cuModuleGetLoadingMode</span><br><span class="line"></span><br><span class="line">[6/8] Executing <span class="string">&#x27;gpukernsum&#x27;</span> stats report</span><br><span class="line"></span><br><span class="line"> Time (%)  Total Time (ns)  Instances  Avg (ns)   Med (ns)   Min (ns)  Max (ns)  StdDev (ns)      GridXYZ          BlockXYZ               Name           </span><br><span class="line"> --------  ---------------  ---------  ---------  ---------  --------  --------  -----------  ----------------  --------------  -------------------------</span><br><span class="line">     62.5          556,575          1  556,575.0  556,575.0   556,575   556,575          0.0  131072    1    1   256    1    1  reduce0(<span class="built_in">float</span> *, <span class="built_in">float</span> *)</span><br><span class="line">     37.5          334,111          1  334,111.0  334,111.0   334,111   334,111          0.0  131072    1    1   256    1    1  reduce1(<span class="built_in">float</span> *, <span class="built_in">float</span> *)</span><br><span class="line"></span><br><span class="line">[7/8] Executing <span class="string">&#x27;gpumemtimesum&#x27;</span> stats report</span><br><span class="line"></span><br><span class="line"> Time (%)  Total Time (ns)  Count    Avg (ns)      Med (ns)     Min (ns)    Max (ns)   StdDev (ns)      Operation     </span><br><span class="line"> --------  ---------------  -----  ------------  ------------  ----------  ----------  -----------  ------------------</span><br><span class="line">     99.7       15,820,690      1  15,820,690.0  15,820,690.0  15,820,690  15,820,690          0.0  [CUDA memcpy HtoD]</span><br><span class="line">      0.3           46,176      2      23,088.0      23,088.0      23,040      23,136         67.9  [CUDA memcpy DtoH]</span><br><span class="line"></span><br><span class="line">[8/8] Executing <span class="string">&#x27;gpumemsizesum&#x27;</span> stats report</span><br><span class="line"></span><br><span class="line"> Total (MB)  Count  Avg (MB)  Med (MB)  Min (MB)  Max (MB)  StdDev (MB)      Operation     </span><br><span class="line"> ----------  -----  --------  --------  --------  --------  -----------  ------------------</span><br><span class="line">    134.218      1   134.218   134.218   134.218   134.218        0.000  [CUDA memcpy HtoD]</span><br><span class="line">      1.049      2     0.524     0.524     0.524     0.524        0.000  [CUDA memcpy DtoH]</span><br></pre></td></tr></table></figure>
<p>可以看见，步骤 4 中调用的是 osrtsum（OS Runtime Summary），关注操作系统层面的性能数据。而如果在命令行中加入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@└────&gt; <span class="comment"># nsys profile --stats=true --trace=cuda,nvtx,cudnn,cublas ./a.out</span></span><br><span class="line">...</span><br><span class="line">[4/7] Executing <span class="string">&#x27;cudaapisum&#x27;</span> stats report</span><br><span class="line"></span><br><span class="line"> Time (%)  Total Time (ns)  Num Calls    Avg (ns)       Med (ns)     Min (ns)   Max (ns)     StdDev (ns)            Name         </span><br><span class="line"> --------  ---------------  ---------  -------------  -------------  --------  -----------  -------------  ----------------------</span><br><span class="line">     94.6      282,480,873          2  141,240,436.5  141,240,436.5   269,662  282,211,211  199,362,781.2  cudaMalloc            </span><br><span class="line">      5.2       15,504,039          3    5,168,013.0      826,866.0   541,742   14,135,431    7,767,320.2  cudaMemcpy            </span><br><span class="line">      0.1          392,989          2      196,494.5      196,494.5    96,115      296,874      141,958.1  cudaFree              </span><br><span class="line">      0.1          318,607          2      159,303.5      159,303.5    28,009      290,598      185,678.5  cudaLaunchKernel      </span><br><span class="line">      0.0            1,184          1        1,184.0        1,184.0     1,184        1,184            0.0  cuModuleGetLoadingMode</span><br></pre></td></tr></table></figure>
<p>则使用的是 cudaapisum（CUDA API Summary），关注的是 CUDA API 层面的性能数据。<br>
除此之外，可以看到 gpukernsum 中核函数执行时间。reduce1 函数性能优于 reduce0，他们的执行次数，执行时间最大值最小值和平均值。</p>
<p>若算子是用 pybind 绑定，用 python 调用的，可以使用 torch 的函数来只监控该算子。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="comment"># warmup</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    _ = torch.matmul(x, y) <span class="comment"># x 和 y 是矩阵，这里就不展开了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># start profiling</span></span><br><span class="line">torch.cuda.cudart().cudaProfilerStart()</span><br><span class="line"></span><br><span class="line"><span class="comment">### benchmarking</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>): <span class="comment"># 测试 100 次</span></span><br><span class="line">    torch.cuda.nvtx.range_push(<span class="string">&quot;your_ops_name&quot;</span>)</span><br><span class="line">    _ = your_ops(x, y)</span><br><span class="line">    torch.cuda.nvtx.range_pop()</span><br><span class="line">torch.cuda.synchronize()</span><br><span class="line"></span><br><span class="line"><span class="comment"># stop profiling</span></span><br><span class="line">torch.cuda.cudart().cudaProfilerStop()</span><br></pre></td></tr></table></figure>
<h2 id="安装-Nsight-Systems-可视化工具">安装 <a href="https://developer.nvidia.cn/nsight-systems">Nsight Systems 可视化工具</a></h2>
<p>在进行完命令行分析后，会生成一个报告文件，结尾是 .nsys-rep。这个文件可以下载下来，丢进 nsight-system 可视化软件，在软件中可以看到更加详细的数据以及程序执行的时间线。<br>
<img src="/20240519171831_2854729219/1.png" alt="1">从上图可以看出 cuda hardware 的函数执行时间情况和 cpu 侧的执行时间情况。下面是核函数的发射时间，上面 device 侧是核函数实际执行时间，和 gpukernsum 统计的时间一致。<br>
<img src="/20240519171831_2854729219/2.png" alt="2">上图是在软件中可以看见的较为详细的统计数据，和命令行结果一致。</p>
]]></content>
      <categories>
        <category>gpu</category>
      </categories>
      <tags>
        <tag>gpu</tag>
      </tags>
  </entry>
  <entry>
    <title>cuda编程</title>
    <url>/20220523191254_3964297908/</url>
    <content><![CDATA[<h1>CUDA 编程</h1>
<h2 id="CUDA-一种异构计算平台">CUDA 一种异构计算平台</h2>
<p>CUDA 是 NVIDIA 推出的用于自家 GPU 的并行计算框架，也就是说 CUDA 只能在 NVIDIA 的 GPU 上运行，而且只有当要解决的计算问题是可以大量并行计算的时候才能发挥 CUDA 的作用。CUDA 的主要作用是连接 GPU 和 应用程序，方便用户通过 CUDA 的 API 调度 GPU 进行计算。</p>
<p>一个CUDA应用通常可以分解为两部分，</p>
<ol>
<li>CPU 主机端代码</li>
<li>GPU 设备端代码</li>
</ol>
<p>CUDA nvcc 编译器会自动分离你代码里面的不同部分，host 代码用 cpp 写成，使用本地的 g++ 编译器编译，设备端代码，也就是核函数，用 CUDA C 编写，通过 nvcc 编译，链接阶段，在内核程序调用或者明显的 GPU 设备操作时，添加运行时库。</p>
<p><img src="/20220523191254_3964297908/1.png" alt="1"></p>
<h2 id="CUDA-编程">CUDA 编程</h2>
<h3 id="简单示例代码">简单示例代码</h3>
<p>hello world 例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*hello_world.cu</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">hello_world</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;GPU: Hello world! \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;CPU: Hello world!\n&quot;</span>);</span><br><span class="line">  hello_world&lt;&lt;&lt;<span class="number">1</span>,<span class="number">10</span>&gt;&gt;&gt;();</span><br><span class="line">  <span class="built_in">cudaDeviceReset</span>(); <span class="comment">//if no this line, it can not output hello world from gpu</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单介绍其中几个关键字</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">__global__ <span class="comment">// 是告诉编译器这个是个可以在设备上执行的核函数</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">hello_world&lt;&lt;&lt;<span class="number">1</span>, <span class="number">10</span>&gt;&gt;&gt;(); <span class="comment">// 其中变量的含义是&lt;&lt;&lt;线程块的个数,每个线程块中线程的个数&gt;&gt;&gt; 一个核函数被执行的次数就是两个参数的乘积</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cudaDeviceReset</span>();</span><br></pre></td></tr></table></figure>
<p>这句话如果没有，则不能正常的运行，因为这句话包含了隐式同步，GPU 和 CPU 执行程序是异步的，核函数调用后成立刻会到主机线程继续，而不管 GPU 端核函数是否执行完毕，所以上面的程序就是GPU 刚开始执行，CPU已经退出程序了，所以我们要等 GPU 执行完了，再退出主机线程。</p>
<h3 id="调用核函数">调用核函数</h3>
<p>核函数就是在 CUDA 模型上诸多线程中运行的那段串行代码，这段代码在 GPU 上运行，用 NVCC 编译，产生的机器码是 GPU 的机器码，所以我们写 CUDA 程序就是写核函数，第一步我们要确保核函数能正确的运行产生正确的结果，第二优化 CUDA 程序的部分，无论是优化算法，还是调整内存结构，线程结构都是要调整核函数内的代码，来完成这些优化的。<br>
我们一直把我们的 CPU 当做一个控制者，运行核函数，要从 CPU 发起。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">kernel_name&lt;&lt;&lt;grid, block, share_mem, stream&gt;&gt;&gt;(argument list);</span><br></pre></td></tr></table></figure>
<p>&lt;&lt;&lt;grid, block, share_mem, stream&gt;&gt;&gt; 是对 GPU 代码执行的线程结构的配置。我们通过 CUDA C 内置的数据类型 dim3 类型的变量来配置 grid 和 block。</p>
<ol>
<li>grid: grid 中 block 的个数</li>
<li>block: 每个 block 中 thread 的布局</li>
<li>是一个可选参数，用于设置每个 block 除了静态分配的 shared memory 外，最多能动态分配的 shared memory 大小，单位为字节，默认为 0。</li>
<li>是一个可选参数，是 cudaStream_t 类型，初始值为 0，用于表示该核函数处于哪个流中。</li>
</ol>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">kernel_name&lt;&lt;&lt;<span class="number">4</span>, <span class="number">8</span>&gt;&gt;&gt;(argument list);</span><br></pre></td></tr></table></figure>
<p>表现为</p>
<p><img src="/20220523191254_3964297908/2.png" alt="2"></p>
<p>可以用 threadIdx.x 和 blockIdx.x （dim3 类型，可以为x, y, z）来组合获得对应的线程的唯一标识。当主机启动了核函数，控制权马上回到主机（不阻塞），而不是主机等待设备完成核函数的运行。想要主机等待设备端执行可以用下面这个指令：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">cudaError_t <span class="title">cudaDeviceSynchronize</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>当然，有些操作要阻塞，比如内存拷贝，因为要用到 host。</p>
<h3 id="编写核函数">编写核函数</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">sumArraysOnGPU</span><span class="params">(<span class="type">float</span> *A, <span class="type">float</span> *B, <span class="type">float</span> *C)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = threadIdx.x;</span><br><span class="line">  C[i] = A[i] + B[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">限定符</th>
<th style="text-align:center">执行</th>
<th style="text-align:center">调用</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">__global__</td>
<td style="text-align:center">设备端执行</td>
<td style="text-align:center">可以从主机调用也可以从计算能力3以上的设备调用</td>
<td style="text-align:center">必须有一个void的返回类型</td>
</tr>
<tr>
<td style="text-align:center">__device__</td>
<td style="text-align:center">设备端执行</td>
<td style="text-align:center">设备端调用</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">__host__</td>
<td style="text-align:center">主机端执行</td>
<td style="text-align:center">主机调用</td>
<td style="text-align:center">可以省略</td>
</tr>
</tbody>
</table>
<p>Kernel核函数编写有以下限制</p>
<ol>
<li>只能访问设备内存</li>
<li>必须有 void 返回类型</li>
<li>不支持可变数量的参数</li>
<li>不支持静态变量</li>
<li>显示异步行为</li>
</ol>
<h3 id="完整示例代码">完整示例代码</h3>
<p>一般 CUDA 程序分成下面这些步骤：</p>
<ol>
<li>分配 GPU 内存</li>
<li>拷贝内存到设备</li>
<li>调用 CUDA 内核函数来执行计算</li>
<li>把计算完成数据拷贝回主机端</li>
<li>内存释放</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cuda_runtime.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 错误检验的宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHECK(call)\</span></span><br><span class="line"><span class="meta">&#123;\</span></span><br><span class="line"><span class="meta">  const cudaError_t <span class="keyword">error</span>=call;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(<span class="keyword">error</span>!=cudaSuccess)\</span></span><br><span class="line"><span class="meta">  &#123;\</span></span><br><span class="line"><span class="meta">      printf(<span class="string">&quot;ERROR: %s:%d,&quot;</span>,__FILE__,__LINE__);\</span></span><br><span class="line"><span class="meta">      printf(<span class="string">&quot;code:%d,reason:%s\n&quot;</span>,<span class="keyword">error</span>,cudaGetErrorString(<span class="keyword">error</span>));\</span></span><br><span class="line"><span class="meta">      exit(1);\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">sumArraysGPU</span><span class="params">(<span class="type">float</span>* a, <span class="type">float</span>* b, <span class="type">float</span>* res)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = threadIdx.x;</span><br><span class="line">  res[i] = a[i] + b[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initialData</span><span class="params">(<span class="type">float</span>* vec, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        vec[i] = (<span class="type">float</span>)i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> dev = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">cudaSetDevice</span>(dev);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> nElem = <span class="number">32</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Vector size:%d\n&quot;</span>, nElem);</span><br><span class="line">  <span class="type">int</span> nByte = <span class="built_in">sizeof</span>(<span class="type">float</span>)*nElem;</span><br><span class="line">  <span class="type">float</span> *a_h = (<span class="type">float</span>*)<span class="built_in">malloc</span>(nByte); <span class="comment">// 输入数据 a</span></span><br><span class="line">  <span class="type">float</span> *b_h = (<span class="type">float</span>*)<span class="built_in">malloc</span>(nByte); <span class="comment">// 输入数据 b</span></span><br><span class="line">  <span class="type">float</span> *res_from_gpu_h = (<span class="type">float</span>*)<span class="built_in">malloc</span>(nByte); <span class="comment">// 用于接受从 gpu 返回的结果</span></span><br><span class="line">  <span class="built_in">memset</span>(res_from_gpu_h, <span class="number">0</span>, nByte);</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> *a_d, *b_d, *res_d; <span class="comment">// 核函数的输入核输出地址（在 gpu 上申请的内存）</span></span><br><span class="line">  <span class="built_in">CHECK</span>(<span class="built_in">cudaMalloc</span>((<span class="type">float</span>**)&amp;a_d, nByte)); <span class="comment">// 在 gpu 上申请内存</span></span><br><span class="line">  <span class="built_in">CHECK</span>(<span class="built_in">cudaMalloc</span>((<span class="type">float</span>**)&amp;b_d, nByte));</span><br><span class="line">  <span class="built_in">CHECK</span>(<span class="built_in">cudaMalloc</span>((<span class="type">float</span>**)&amp;res_d, nByte));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">initialData</span>(a_h, nElem);</span><br><span class="line">  <span class="built_in">initialData</span>(b_h, nElem);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">CHECK</span>(<span class="built_in">cudaMemcpy</span>(a_d, a_h, nByte, cudaMemcpyHostToDevice)); <span class="comment">// 将输入数据拷贝到 gpu</span></span><br><span class="line">  <span class="built_in">CHECK</span>(<span class="built_in">cudaMemcpy</span>(b_d, b_h, nByte, cudaMemcpyHostToDevice));</span><br><span class="line"></span><br><span class="line">  <span class="function">dim3 <span class="title">block</span><span class="params">(nElem)</span></span>;</span><br><span class="line">  <span class="function">dim3 <span class="title">grid</span><span class="params">(nElem / block.x)</span></span>;</span><br><span class="line">  sumArraysGPU&lt;&lt;&lt;grid, block&gt;&gt;&gt;(a_d, b_d, res_d); <span class="comment">// 调用核函数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Execution configuration&lt;&lt;&lt;%d, %d&gt;&gt;&gt;\n&quot;</span>, block.x, grid.x);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">CHECK</span>(<span class="built_in">cudaMemcpy</span>(res_from_gpu_h, res_d, nByte, cudaMemcpyDeviceToHost)); <span class="comment">// 将核函数结果从 gpu 返回给 主机</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">cudaFree</span>(a_d);</span><br><span class="line">  <span class="built_in">cudaFree</span>(b_d);</span><br><span class="line">  <span class="built_in">cudaFree</span>(res_d);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(a_h);</span><br><span class="line">  <span class="built_in">free</span>(b_h);</span><br><span class="line">  <span class="built_in">free</span>(res_from_gpu_h);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nvcc xxx.cu -o a.out</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>gpu</category>
      </categories>
      <tags>
        <tag>gpu</tag>
      </tags>
  </entry>
  <entry>
    <title>gpu计算</title>
    <url>/20220522152654_4271767810/</url>
    <content><![CDATA[<h1>gpu计算</h1>
<h2 id="异构计算">异构计算</h2>
<p>异构计算，首先必须了解什么是异构，不同的计算机架构就是异构，按照指令集划分或者按照内存结构划分。</p>
<p>GPU 本来的任务是做图形图像的，并行度很高，一定距离外的像素点之间的计算是独立的，所以属于并行任务。GPU 插在主板的 PCIe 卡口上，运行程序的时候，CPU 像是一个控制者，指挥两台 显卡完成工作后进行汇总，和下一步工作安排，所以 CPU 我们可以把它看做一个指挥者，主机端，host，而完成大量计算的 GPU 是我们的计算设备，device。</p>
<p><img src="/20220522152654_4271767810/1.png" alt="1"></p>
<p>上面这张图能大致反应 CPU 和 GPU 的架构不同。</p>
<p>左图：一个四核 CPU 一般有四个 ALU，ALU 是完成逻辑计算的核心，也是我们平时说四核八核的核，控制单元，缓存也在片上，DRAM 是内存，一般不在片上，CPU 通过总线访问内存。</p>
<p>右图：GPU，绿色小方块是 ALU，我们注意红色框内的部分 SM，这一组 ALU 共用一个 Control 单元和 Cache，这个部分相当于一个完整的多核 CPU，但是不同的是 ALU 多了，Control 部分变小。所以计算能力提升了，控制能力减弱了。所以对于控制密集的程序，一个 GPU 的 SM 是没办法和 CPU 比较的，但是对了逻辑简单，数据量大的任务，GPU 更高效。并且，一个 GPU 有好多个 SM。</p>
<p><img src="/20220522152654_4271767810/2.png" alt="2"></p>
<p>CPU和GPU之间通过 PCIe 总线连接，用于传递指令和数据，这部分也是后面要讨论的性能瓶颈之一。<br>
一个异构应用包含两种以上架构，所以代码也包括不止一部分：</p>
<ol>
<li>主机代码在主机端运行，被编译成主机架构的机器码</li>
<li>设备端的在设备上执行，被编译成设备架构的机器码。</li>
</ol>
<p>所以主机端的机器码和设备端的机器码是隔离的，自己执行自己的，没办法交换执行。<br>
主机端代码主要是<strong>控制设备</strong>，完成<strong>数据传输</strong>等<strong>控制</strong>类工作，设备端主要的任务就是<strong>计算</strong>。</p>
<p>因为当没有 GPU 的时候 CPU 也能完成这些计算，只是速度会慢很多，所以可以把 GPU 看成 CPU 的一个加速设备。</p>
<h2 id="GPU-硬件结构">GPU 硬件结构</h2>
<p>GPU的硬件结构，也不是具体的硬件结构，就是与 CUDA 相关的几个概念：thread，block，grid，Wrap，SP，SM。</p>
<ol>
<li>
<p>SP：最基本的处理单元，streaming processor。最后具体的指令和任务都是在 SP 上处理的。GPU 进行并行计算，也就是很多个 SP 同时做处理。每个 SP 有它自己的寄存器，比较稀缺的资源。</p>
</li>
<li>
<p>SM：多个（几十或者上百，取决于设备） SP 加上其他的一些资源组成一个 SM，streaming multiprocessor。其他资源也就是存储资源，共享内存，寄储器等。各个 SM 之间只能通过全局内存间接通信，没有其它互联通道，所以这个集群只适合进行纯并行化计算。如果在计算过程中每个 SM 之间还需要通信，则整体运行效率很低。</p>
</li>
<li>
<p>Wrap：</p>
</li>
</ol>
<blockquote>
<ol>
<li>SM 中的 SP 会分成成组的 Warp，每组 32 个。</li>
<li>Wrap Scheduler 会从在 SM 上的所有 Warp 中进行指令调度。从已经有指令可以被执行的 Warp 中挑选然后分配下去。这些 Warp 可能来自与驻留在 SM 上的任何线程块。</li>
<li>所以，Warp 是 GPU 执行程序时的调度单位，同在一个 Wrap 的线程，以不同数据资源执行相同的指令。</li>
<li>一个 SM 上在某一个时刻，有 32 个线程在执行同一条指令，这 32 个线程可以选择性执行，虽然有些可以不执行，但是他也不能执行别的指令。</li>
<li>当一个 Warp 空闲时（或者在读数据，或者执行完），SM 就可以调度驻留在该 SM 上的另一个 Warp。</li>
<li>并发的 Warp 之间切换是没消耗的，因为资源早就被分配到所有 thread 和 block。</li>
</ol>
</blockquote>
<p><img src="/20220522152654_4271767810/3.png" alt="3"></p>
<p><img src="/20220522152654_4271767810/4.png" alt="4"></p>
<blockquote>
<p>如上图，如果有 if-else 分支，同一个 Warp 内的线程，不能在执行 if 的同时，另一群在执行 else，而是在执行 if 时，另一群选择等待。这种现象又被称为 Warp 发散。</p>
</blockquote>
<ol start="4">
<li>grid、block、thread：在利用 cuda 进行编程时，一个核函数会分配一个 grid。一个 grid 分为多个 block，而一个 block 分为多个 thread。其中任务划分到是否影响最后的执行效果。划分的依据是<strong>任务特性</strong>和 GPU 本身的<strong>硬件特性</strong>。</li>
</ol>
<blockquote>
<ol>
<li>block 是软件概念，通过设置该属性告诉 GPU 我有多少个线程，该如何组织。</li>
<li>一个 block 只会由一个 SM 进行调度，一旦被分配好 SM，block 就会一直驻留在 SM 中直到程序结束。</li>
<li>一个 SM 可以拥有多个 block，但是要顺序执行：</li>
</ol>
</blockquote>
<p><img src="/20220522152654_4271767810/5.png" alt="5"></p>
<blockquote>
<ol start="4">
<li>一个 block 有多个 Warp，例如一个有 512 线程的 block，有（512 / 32 = 16）个 Warp，这些 Warp 轮流进入 SM，由 Warp Scheduler 负责调度。若 block 内的线程数不是 32 的整数倍，那多余的 thread 单独为一个 Warp。</li>
<li>目前一个 block 内最多 1024 个线程。</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>gpu</category>
      </categories>
      <tags>
        <tag>gpu</tag>
      </tags>
  </entry>
  <entry>
    <title>linux io 复用高级应用2：聊天室程序</title>
    <url>/20220216093825_32353/</url>
    <content><![CDATA[<p>客户端：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="built_in">basename</span>(argv[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = <span class="built_in">atoi</span>(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server_address;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;server_address, <span class="built_in">sizeof</span>(server_address));</span><br><span class="line">    server_address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, ip, &amp;server_address.sin_addr);</span><br><span class="line">    server_address.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sockfd = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert</span>(sockfd &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">connect</span>(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;server_address, <span class="built_in">sizeof</span>(server_address)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connection failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pollfd fds[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 0文件描述符为标准输入 注册可读事件POLLIN</span></span><br><span class="line">    fds[<span class="number">0</span>].fd = <span class="number">0</span>;</span><br><span class="line">    fds[<span class="number">0</span>].events = POLLIN;</span><br><span class="line">    fds[<span class="number">0</span>].revents = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sockfd文件描述符为监听的端口 注册可读事件POLLIN和对方关闭连接事件POLLRDHUP</span></span><br><span class="line">    fds[<span class="number">1</span>].fd = sockfd;</span><br><span class="line">    fds[<span class="number">1</span>].events = POLLIN | POLLRDHUP;</span><br><span class="line">    fds[<span class="number">1</span>].revents = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> read_buf[BUFFER_SIZE];</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">pipe</span>(pipefd);</span><br><span class="line">    <span class="built_in">assert</span>(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        ret = <span class="built_in">poll</span>(fds, <span class="number">2</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;poll failure\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fds[<span class="number">1</span>].revents &amp; POLLRDHUP) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server close the connection&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fds[<span class="number">1</span>].revents &amp; POLLIN) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(read_buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE);</span><br><span class="line">            <span class="built_in">recv</span>(fds[<span class="number">1</span>].fd, read_buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, read_buf);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fds[<span class="number">0</span>].revents &amp; POLLIN) &#123;</span><br><span class="line">            <span class="comment">// 零拷贝 0 -&gt; sockfd</span></span><br><span class="line">            ret = <span class="built_in">splice</span>(<span class="number">0</span>, <span class="literal">NULL</span>, pipefd[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE);</span><br><span class="line">            ret = <span class="built_in">splice</span>(pipefd[<span class="number">0</span>], <span class="literal">NULL</span>, sockfd, <span class="literal">NULL</span>, <span class="number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USER_LIMIT 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FD_LIMIT 65535</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">client_data</span></span><br><span class="line">&#123;</span><br><span class="line">    sockaddr_in address;</span><br><span class="line">    <span class="type">char</span>* write_buf;</span><br><span class="line">    <span class="type">char</span> buf[BUFFER_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="type">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> old_option = <span class="built_in">fcntl</span>(fd, F_GETFL);</span><br><span class="line">    <span class="type">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">    <span class="built_in">fcntl</span>(fd, F_SETFL, new_option);</span><br><span class="line">    <span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s ip_address portnumber\n&quot;</span>, <span class="built_in">basename</span>(argv[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = <span class="built_in">atoi</span>(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;address, <span class="built_in">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> listenfd = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert</span>(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">bind</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="built_in">sizeof</span>(address));</span><br><span class="line">    <span class="built_in">assert</span>(ret != <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">listen</span>(listenfd, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">assert</span>(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    client_data* users = <span class="keyword">new</span> client_data[FD_LIMIT];</span><br><span class="line"></span><br><span class="line">    pollfd fds[USER_LIMIT + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> user_counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= USER_LIMIT; i++) &#123;</span><br><span class="line">        fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">        fds[i].events = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注册事件：监听端口是否可读或者出现错误</span></span><br><span class="line">    fds[<span class="number">0</span>].fd = listenfd;</span><br><span class="line">    fds[<span class="number">0</span>].events = POLLIN | POLLERR;</span><br><span class="line">    fds[<span class="number">0</span>].revents = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        ret = <span class="built_in">poll</span>(fds, user_counter + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;poll failure\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; user_counter + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((fds[i].fd == listenfd) &amp;&amp; (fds[i].revents &amp; POLLIN)) &#123;</span><br><span class="line">                <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_address;</span><br><span class="line">                <span class="type">socklen_t</span> client_addrlength = <span class="built_in">sizeof</span>(client_address);</span><br><span class="line">                <span class="type">int</span> connfd = <span class="built_in">accept</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;client_address, &amp;client_addrlength);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (connfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;errno is: %d\n&quot;</span>, errno);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (user_counter &gt;= USER_LIMIT) &#123;</span><br><span class="line">                    <span class="type">const</span> <span class="type">char</span>* info = <span class="string">&quot;too many users\n&quot;</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, info);</span><br><span class="line">                    <span class="built_in">send</span>(connfd, info, <span class="built_in">strlen</span>(info), <span class="number">0</span>);</span><br><span class="line">                    <span class="built_in">close</span>(connfd);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                user_counter++;</span><br><span class="line">                users[connfd].address = client_address;</span><br><span class="line">                <span class="built_in">setnonblocking</span>(connfd);</span><br><span class="line">                <span class="comment">// 用于和新连接进来的客户的交互的文件描述符connfd</span></span><br><span class="line">                fds[user_counter].fd = connfd;</span><br><span class="line">                fds[user_counter].events = POLLIN | POLLRDHUP | POLLERR;</span><br><span class="line">                fds[user_counter].revents = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;comes a new user, now have %d users\n&quot;</span>, user_counter);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fds[i].revents &amp; POLLERR) &#123; <span class="comment">// 某个和用户连接出错了</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;get an error from %d\n&quot;</span>, fds[i].fd);</span><br><span class="line">                <span class="type">char</span> errors[<span class="number">100</span>];</span><br><span class="line">                <span class="built_in">memset</span>(errors, <span class="string">&#x27;\0&#x27;</span>, <span class="number">100</span>);</span><br><span class="line">                <span class="type">socklen_t</span> length = <span class="built_in">sizeof</span>(errors);</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">getsockopt</span>(fds[i].fd, SOL_SOCKET, SO_ERROR, &amp;errors, &amp;length) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;get socket options failed]n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fds[i].revents &amp; POLLRDHUP) &#123; <span class="comment">// 用户断开了连接</span></span><br><span class="line">                users[fds[i].fd] = users[fds[user_counter].fd];</span><br><span class="line">                <span class="built_in">close</span>(fds[i].fd);</span><br><span class="line">                fds[i] = fds[user_counter];</span><br><span class="line">                i--;</span><br><span class="line">                user_counter--;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;a client left\n&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fds[i].revents &amp; POLLIN) &#123; <span class="comment">// 用户连接可读，表示用户发送了数据过来</span></span><br><span class="line">                <span class="type">int</span> connfd = fds[i].fd;</span><br><span class="line">                <span class="built_in">memset</span>(users[connfd].buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE);</span><br><span class="line">                ret = <span class="built_in">recv</span>(connfd, users[connfd].buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;get %d bytes of client data %s from %d\n&quot;</span>, ret, users[connfd].buf, connfd);</span><br><span class="line">                <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">                        <span class="built_in">close</span>(connfd);</span><br><span class="line">                        users[fds[i].fd] = users[fds[user_counter].fd];</span><br><span class="line">                        fds[i] = fds[user_counter];</span><br><span class="line">                        i--;</span><br><span class="line">                        user_counter--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123; <span class="comment">// 对方关闭了连接 此时有POLLHUP处理</span></span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= user_counter; j++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (fds[j].fd == connfd) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        fds[j].events |= ~POLLIN; <span class="comment">// 原书这里是这样写的 目的为注销可读。但是本人认为应该是 &amp;= ，下同。</span></span><br><span class="line">                        fds[j].events |= POLLOUT;</span><br><span class="line">                        users[fds[j].fd].write_buf = users[connfd].buf; <span class="comment">// 其他用户的buf写上当前收到的某fd所发送的信息</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fds[i].revents &amp; POLLOUT) &#123; <span class="comment">// 用户连接可写，把buffer信息写进去</span></span><br><span class="line">                <span class="type">int</span> connfd = fds[i].fd;</span><br><span class="line">                <span class="keyword">if</span> (!users[connfd].write_buf) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ret = <span class="built_in">send</span>(connfd, users[connfd].write_buf, <span class="built_in">strlen</span>(users[connfd].write_buf), <span class="number">0</span>);</span><br><span class="line">                users[connfd].write_buf = <span class="literal">NULL</span>;</span><br><span class="line">                fds[i].events |= ~POLLOUT;</span><br><span class="line">                fds[i].events |= POLLIN;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] users;</span><br><span class="line">    <span class="built_in">close</span>(listenfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>演示结果：<br>
服务器：<br>
<img src="/20220216093825_32353/1.png" alt="在这里插入图片描述"></p>
<hr>
<p>客户端1:<br>
<img src="/20220216093825_32353/2.png" alt="客户端发送：client 1 : 1111111"></p>
<hr>
<p>客户端2:<br>
<img src="/20220216093825_32353/3.png" alt="客户端发送：client 2 : 2222222"></p>
<hr>
<p>reference：<br>
linux高性能服务器编程——游双</p>
]]></content>
      <categories>
        <category>socket-programming</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 高级服务器编程ET LT</title>
    <url>/20220211093017_10688/</url>
    <content><![CDATA[<h1>linux 服务器高级编程ET LT代码</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EVENT_NUMBER 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="type">int</span> fd)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> old_option = <span class="built_in">fcntl</span>(fd, F_GETFL);</span><br><span class="line">    <span class="type">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">    <span class="built_in">fcntl</span>(fd, F_SETFL, new_option);</span><br><span class="line">    <span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addfd</span><span class="params">(<span class="type">int</span> epollfd, <span class="type">int</span> fd, <span class="type">bool</span> enable_et)</span> <span class="comment">//在内核事件表中为fd注册事件</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.events = EPOLLIN;</span><br><span class="line">    <span class="keyword">if</span> (enable_et)</span><br><span class="line">    &#123;</span><br><span class="line">        event.events |= EPOLLET;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, fd, &amp;event); <span class="comment">// 操作内核事件表的函数</span></span><br><span class="line">    <span class="built_in">setnonblocking</span>(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lt</span><span class="params">(epoll_event* events, <span class="type">int</span> number, <span class="type">int</span> epollfd, <span class="type">int</span> listenfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line">        <span class="type">int</span> sockfd = events[i].data.fd;</span><br><span class="line">        <span class="keyword">if</span> (sockfd == listenfd) &#123;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_address;</span><br><span class="line">            <span class="type">socklen_t</span> client_addrlength = <span class="built_in">sizeof</span>(client_address);</span><br><span class="line">            <span class="type">int</span> connfd = <span class="built_in">accept</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;client_address, &amp;client_addrlength);</span><br><span class="line">            <span class="built_in">addfd</span>(epollfd, connfd, <span class="literal">false</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;connect fd:%d listenfd=%d\n&quot;</span>, connfd, listenfd);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;event trigger once\n&quot;</span>);</span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE);</span><br><span class="line">            <span class="type">int</span> ret = <span class="built_in">recv</span>(sockfd, buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;socket fd:%d listenfd=%d\n&quot;</span>, sockfd, listenfd);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">close</span>(sockfd);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;get %d bytes of content: %s\n&quot;</span>, ret, buf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;sth else happend\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">et</span><span class="params">(epoll_event* events, <span class="type">int</span> number, <span class="type">int</span> epollfd, <span class="type">int</span> listenfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; number; i++) &#123;</span><br><span class="line">        <span class="type">int</span> sockfd = events[i].data.fd;</span><br><span class="line">        <span class="keyword">if</span> (sockfd == listenfd) &#123;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_address;</span><br><span class="line">            <span class="type">socklen_t</span> client_addrlength = <span class="built_in">sizeof</span>(client_address);</span><br><span class="line">            <span class="type">int</span> connfd = <span class="built_in">accept</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;client_address, &amp;client_addrlength);</span><br><span class="line">            <span class="built_in">addfd</span>(epollfd, connfd, <span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;event trigger once\n&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE);</span><br><span class="line">                <span class="type">int</span> ret = <span class="built_in">recv</span>(sockfd, buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((errno == EAGAIN) || (errno == EWOULDBLOCK)) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;read later\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">close</span>(sockfd);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">close</span>(sockfd);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;get %d bytes of content:%s\n&quot;</span>, ret, buf);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;nothing happend\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="built_in">basename</span>(argv[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = <span class="built_in">atoi</span>(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;address, <span class="built_in">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> listenfd = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert</span>(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">bind</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="built_in">sizeof</span>(address));</span><br><span class="line">    <span class="built_in">assert</span>(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">listen</span>(listenfd, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">assert</span>(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line">    <span class="type">int</span> epollfd = <span class="built_in">epoll_create</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">addfd</span>(epollfd, listenfd, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">epoll_wait</span>(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;epoll fail\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// lt(events, ret, epollfd, listenfd);</span></span><br><span class="line">        <span class="built_in">et</span>(events, ret, epollfd, listenfd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(listenfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>ET:<br>
<img src="/20220211093017_10688/1.png" alt="1"><br>
ET模式下需要一次性处理完所有数据，下次就不会加入到epoll_wait的事件中了。</p>
<hr>
<p>LT:<br>
<img src="/20220211093017_10688/2.png" alt="2"><br>
LT模式下未处理完的事件还是会被加入到epoll_wait监听的事件中。</p>
<hr>
<p>reference：<br>
linux高性能服务器编程——游双P153-P157</p>
]]></content>
      <categories>
        <category>socket-programming</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>linux中&gt;&amp;和&amp;&gt;区别</title>
    <url>/20230522100059_339516945/</url>
    <content><![CDATA[<h2 id="Linux-中常用的文件描述符">Linux 中常用的文件描述符</h2>
<ul>
<li>0 文件描述符，表示标准输入。</li>
<li>1 文件描述符，表示标准输出。</li>
<li>2 文件描述符，表示标准错误。</li>
</ul>
<p>标准情况下，这些文件描述符和以下设备关联：</p>
<ul>
<li>0 文件描述符关联键盘，并返回给前端。</li>
<li>1 正确返回值，返回给前端。</li>
<li>2 错误返回值，返回给前端。</li>
</ul>
<h2 id="符号">&gt; 符号</h2>
<p>在 shell 中，我们经常使用 &gt; 符号，把输出重定位到一个文件。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /proc/xxx/maps &gt; memory.txt</span><br></pre></td></tr></table></figure>
<p>以上输出是把某个进程的内存布局重定向到一个文件。其中，&gt; 是 1&gt; 的简写，实际意思是把标准输出重定向到后面的文件。这样屏幕上就不会有打印了，打印会重定向到文件中。</p>
<h2 id="符号-2">&gt;&amp; 符号</h2>
<p>本质上，&gt;&amp; 符号不是一个符号。我们经常见到 2&gt;&amp;1 符号，实际意义是，将<strong>标准错误</strong>重新定位到<strong>标准输出</strong>。那为什么要加个 &amp; 呢？因为不加 &amp; 的话操作系统不会认为你是想把标准错误重定位给标准输出，而是想重定向到一个叫 “1” 的文件。所以 &amp;1 表示 1 输出通道。举例，strace 命令可以查看系统调用，这个结果是输出到标准错误的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">strace ls &gt; log 2&gt;&amp;1</span><br></pre></td></tr></table></figure>
<p>将标准输出重定向到 log 文件，并将标准错误重定向到标准输出。这样标准错误也会被重定向到 log 文件。</p>
<h2 id="符号-3">&amp;&gt; 符号</h2>
<p>&amp;&gt; 意思是把标准错误和标准输出都重定向到某个文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">strace ls &amp;&gt; log</span><br></pre></td></tr></table></figure>
<p>写起来比较简单，且省力。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux内存寻址</title>
    <url>/20230127151632_3224177663/</url>
    <content><![CDATA[<h2 id="内存寻址定义">内存寻址定义</h2>
<p>所谓内存寻址，就是 cpu 接受到指令后，需要从内存中取得相应数据。但是内存中的数据都是有对应地址的，如何通过地址拿到的地址，来获取相应地址段上的数据。</p>
<p>所谓地址在操作系统中分为逻辑地址，虚拟地址，线性地址和物理地址。</p>
<h3 id="1-逻辑地址">1. 逻辑地址</h3>
<p>逻辑地址就是机器码指令用到的地址。机器指令码中用到的地址都是逻辑地址。目前这个地址是由 16 位段选择符和 32 位偏移量来表示的（CS：EIP 段选择符：段内偏移量）。</p>
<h3 id="2-虚拟地址">2. 虚拟地址</h3>
<p>虚拟地址就是逻辑地址的段内偏移量。所以逻辑地址 = 段选择符：<strong>虚拟地址</strong>。我们正常代码中拿到的地址就是虚拟地址，比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure>
<h3 id="3-线性地址">3. 线性地址</h3>
<p>是一个 32 位无符号整数，是<strong>由逻辑地址</strong>经过段页式转换而来的。我们常说的进程的地址空间，所谓的地址指的就是线性地址。</p>
<h3 id="4-物理地址">4. 物理地址</h3>
<p>是内存芯片中的物理地址，是存放数据的实际地址。是<strong>由逻辑地址</strong>转换而来的。最终是由这个地址来定位到内存空间。在页表转换时，这里存的不是真正物理地址，是物理内存块编号。例如一个内存块大小为 4K，那第 0 块地址若为 0x50000000，第一块就为 0x50001000。</p>
<p>最后给一张地址变换的图：</p>
<p><img src="/20230127151632_3224177663/0.png" alt="0"></p>
<h2 id="x86-段页式内存管理机制">x86 段页式内存管理机制</h2>
<p>逻辑地址转换为物理地址需要经历两个过程：</p>
<h3 id="1-段式内存管理：逻辑地址-线性地址">1. 段式内存管理：逻辑地址 =&gt; 线性地址</h3>
<p>逻辑地址是（selector：offset）的形式，selector 可以为代码段或者数据段。</p>
<p><img src="/20230127151632_3224177663/1.png" alt="1"></p>
<p>如用 selector 去 GDT 全局描述符表（假定 TI = 0）拿到段基址 segment base address，之后再加上 offset，就得到了线性地址。这个过程，被称为<strong>段式内存管理</strong>。对于表指示器 Table Indicator 来讲，决定了去哪种表寻找描述符。全局描述符放在 GDT（每个 CPU 有一个）里面，进程自己的放在 LDT 里面。</p>
<p>分段的目的主要有两个：</p>
<ul>
<li>使操作系统可以访问大于地址总线的内存，如 32 位地址总线可以访问 大于 4G 的内存。</li>
<li>权限控制，将每个段设置权限位，让不同程序可以访问不同段。</li>
</ul>
<h3 id="2-页式内存管理：线性地址-物理地址">2. 页式内存管理：线性地址 =&gt; 物理地址</h3>
<p>线性地址结构如下图：</p>
<p><img src="/20230127151632_3224177663/2.png" alt="2"></p>
<p>线性地址切成三段，用前两段分别作为索引去 Page Directory 和 Page Table 里查表，会先得到一个页目录表项，再得到一个页表项（Page Table Entry），那里面的值就是一个物理内存块的起始地址（其实就是是物理内存编号），把它加上 线性地址 切分之后第三段的<strong>页内偏移</strong>就得到了最终的物理地址。我们把这个过程称作<strong>页式内存管理</strong>。</p>
<h2 id="Linux-段页式管理做法">Linux 段页式管理做法</h2>
<p>Linux 认为靠页式管理就能完成内核所需的功能了，段式太麻烦了。关又关不掉，因为是硬件那里做的，所以只能略施小计：所有段的 segment base address 都设置为 0！这样就不分段了，所有段内空间和线性空间重合。</p>
<blockquote>
<p><strong>逻辑地址 == 虚拟地址 == 线性地址</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux进程内存布局</title>
    <url>/20220726151829_508913850/</url>
    <content><![CDATA[<h2 id="进程内存布局">进程内存布局</h2>
<p><img src="/20220726151829_508913850/1.png" alt="1"><br>
在 x86_64 架构的 32 位操作系统中，linux 的进程内存布局如图所示。这个是进程的虚拟地址空间，这些虚拟地址通过<strong>页表</strong>映射到物理内存。页表由操作系统维护，由处理器引用。每一个进程都有一个自己的页表。内核也是一个特殊的进程，因为虚拟地址被使能会应用于所有软件，所以内核需要在每个进程的地址空间中都保留一部分虚拟地址专门给内核使用。</p>
<h2 id="内核空间">内核空间</h2>
<p>从 0xC0000000 到 0xFFFFFFFF 这 1G 的空间是内核空间，而 0x00000000 到 0xBFFFFFFF 是用户空间。用户空间无法直接访问内核的虚拟内存空间，仅能通过系统调用来进入内核态，从而来访问内核空间的内存地址。只要用户态的程序试图访问这些页，就会导致一个页错误（page fault）。在 linux 中，内核空间持续存在，并且所有进程中都映射到同样的物理内存。内核的代码和数据总是可以被寻址的，因为随时为系统调用和中断做准备。另外，用户进程也是无法访问 0x00000000 ~ 0x08048000 这一段虚拟内存地址的，在这段地址上有诸多例如 C 库，动态加载器如 <a href="http://ld.so">ld.so</a> 等的映射地址。 如果用户进程访问到该区间会返回段错误。</p>
<h2 id="用户空间">用户空间</h2>
<h3 id="栈">栈</h3>
<p>在用户空间的最顶部的部分被叫做栈空间，它一般用于存放函数参数或局部变量。例如：调用一个函数会将函数参数压入到栈空间中，在函数返回时，参数会被栈弹出清理。进程中的<strong>每一个线程都有属于自己的栈</strong>。</p>
<h3 id="mmap">mmap</h3>
<p>在栈的低一段便是 mmap，mmap 是一种高效便捷的文件 I/O 方式。内核将文件内容映射在此段内存中，例如加载动态链接库。另外，在 linux 中，如果你通过 malloc 申请一块大于 MMAP_THRESHOLD（默认大小是 128KB）大小的堆空间时，glibc 会返回一块匿名的 mmap 内存块而非一块堆内存。</p>
<h3 id="堆">堆</h3>
<p>堆同栈一样，都是为进程运行提供动态的内存分配，但其和栈的的一个很大区别在于堆上内存的生命周期和执行分配的函数的生命周期不同，堆上分配的内存只有在对应进程通过系统调用<strong>主动释放</strong>或<strong>进程结束后</strong>才会释放。堆的内存分配效率比栈要低得多。因为栈是由操作系统提供管理的，会在底层堆栈提供支持，分配专门的寄存器（$esp）存放栈的地址，包括压栈出栈也都有<strong>专门的指令</strong>执行，所以执行效率很高。而堆则是由 C 函数库提供支持，它的机制相对复杂，例如分配一块内存，库函数会按照一定的算法在堆内存空间中搜索可用的足够大的内存空间，如果没有足够大的连续空间，则需要操作系统来重新整理堆内存，这样才有机会分到足够大小的空间，然后才返回。对于堆来说，频繁的 malloc/free（new/delete）势必会造成内存空间的不连续，从而造成大量的内存碎片，程序的运行效率降低。而对于栈来说，分配的一定是连续的内存空间。</p>
<h3 id="BSS段">BSS段</h3>
<p>堆段再往下便是 BSS 段这个静态内存区域，它是用来存储<strong>静态局部</strong>或<strong>静态全局变量</strong>的，其在<strong>编译期间</strong>便决定了虚拟内存的消耗，BSS 段存放的是未初始化的变量。另外根据 C 语言标准规定，未初始化的静态成员变量的初始值必须为 0，所以内核在加载二进制文件后执行程序前会将 BSS 段清 0。</p>
<h3 id="DATA段">DATA段</h3>
<p>DATA 段也是个静态内存区域，也是用来存储静态局部或静态全局变量。但是放的是已经初始化的变量。</p>
<h3 id="代码段">代码段</h3>
<p>DATA 段再往下便是代码段，这段中存有程序的指令代码。TEXT 段是通过<strong>只读</strong>的方式加载到内存中的，它可以在多个进程中被安全共享。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>nslookup程序(getaddrinfo和getnameinfo示例)</title>
    <url>/20220926020815_60782/</url>
    <content><![CDATA[<h3 id="代码：">代码：</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 64</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">p</span>, *<span class="title">listp</span>, <span class="title">hints</span>;</span></span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="type">int</span> rc, flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;domain name&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));</span><br><span class="line">    hints.ai_family = AF_INET;  <span class="comment">// 只用IPV4</span></span><br><span class="line">    hints.ai_socktype = SOCK_STREAM;  <span class="comment">// 只用TCP</span></span><br><span class="line">    <span class="keyword">if</span> ((rc = getaddrinfo(argv[<span class="number">1</span>], <span class="literal">NULL</span>, &amp;hints, &amp;listp)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;getaddrinfo error: %s\n&quot;</span>, gai_strerror(rc));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flags = NI_NUMERICHOST;  <span class="comment">// 展示数字而不是域名</span></span><br><span class="line">    <span class="keyword">for</span> (p = listp; p; p = p-&gt;ai_next) &#123;  <span class="comment">// 遍历结果链表</span></span><br><span class="line">        getnameinfo(p-&gt;ai_addr, p-&gt;ai_addrlen, buf, MAXLINE, <span class="literal">NULL</span>, <span class="number">0</span>, flags);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    freeaddrinfo(listp);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="编译：">编译：</h3>
<blockquote>
<p>gcc nslookup.c -o nslook</p>
</blockquote>
<h3 id="运行：">运行：</h3>
<p><img src="/20220926020815_60782/1.png" alt="在这里插入图片描述"></p>
<hr>
<h3 id="Reference">Reference:</h3>
<p>CSAPP: $P_{659}$</p>
]]></content>
      <categories>
        <category>socket-programming</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>plt表链接过程</title>
    <url>/20230613093018_2903084538/</url>
    <content><![CDATA[<h2 id="概念">概念</h2>
<p>在 ELF 文件中，查看可以获得它的节的名字。其中有几个带有 plt 和 got 的节。</p>
<p>在此处，给出各节的定义如下：</p>
<ul>
<li>.got：Global Offset Table，全局偏移表。这是链接器为外部符号填充的实际偏移表。</li>
<li>.plt：Procedure Linkage Table，程序链接表。他有两个作用，要么在 .got.plt 中拿到链接地址跳转，要么触发链接器去寻找地址。</li>
<li>.got.plt：是 .got 的一部分（但是是两个不同的节），是 got 专门为 plt 准备的节，包含了 plt 表需要的地址。（新版 gcc 可能将他叫为 .plt.got）</li>
<li>.rela.plt：程序链接表的重定位表，记录所有全局函数的动态链接信息，用于在程序加载时修正 plt 表中的跳转指针，使它们指向正确的地址。</li>
</ul>
<h2 id="实验">实验</h2>
<p>接下来将使用 gdb 一步一步跟着汇编走完动态链接的过程。</p>
<h3 id="准备工作">准备工作</h3>
<h4 id="实验代码如下：">实验代码如下：</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="查看节的地址与大小：">查看节的地址与大小：</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@└────&gt; <span class="comment"># objdump -h plt | grep -E &quot;plt|got&quot;</span></span><br><span class="line">plt:     file format elf64-x86-64</span><br><span class="line">  9 .rela.plt     00000030  0000000000400468  0000000000400468  00000468  2**3</span><br><span class="line"> 11 .plt          00000030  00000000004004c0  00000000004004c0  000004c0  2**4</span><br><span class="line"> 20 .got          00000020  0000000000600fe0  0000000000600fe0  00000fe0  2**3</span><br><span class="line"> 21 .got.plt      00000028  0000000000601000  0000000000601000  00001000  2**3</span><br></pre></td></tr></table></figure>
<h4 id="查看需要动态链接的符号：">查看需要动态链接的符号：</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@└────&gt; <span class="comment"># readelf -r plt</span></span><br><span class="line"></span><br><span class="line">Relocation section <span class="string">&#x27;.rela.dyn&#x27;</span> at offset 0x408 contains 4 entries:</span><br><span class="line">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</span><br><span class="line">000000600fe0  000100000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_deregisterTMClone + 0</span><br><span class="line">000000600fe8  000400000006 R_X86_64_GLOB_DAT 0000000000000000 __libc_start_main@GLIBC_2.2.5 + 0</span><br><span class="line">000000600ff0  000500000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0</span><br><span class="line">000000600ff8  000600000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_registerTMCloneTa + 0</span><br><span class="line"></span><br><span class="line">Relocation section <span class="string">&#x27;.rela.plt&#x27;</span> at offset 0x468 contains 2 entries:</span><br><span class="line">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</span><br><span class="line">000000601018  000200000007 R_X86_64_JUMP_SLO 0000000000000000 puts@GLIBC_2.2.5 + 0</span><br><span class="line">000000601020  000300000007 R_X86_64_JUMP_SLO 0000000000000000 <span class="built_in">printf</span>@GLIBC_2.2.5 + 0</span><br></pre></td></tr></table></figure>
<h4 id="反汇编查看-plt-相关函数：">反汇编查看 plt 相关函数：</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@└────&gt; <span class="comment"># objdump -d plt</span></span><br><span class="line">Disassembly of section .plt:</span><br><span class="line"></span><br><span class="line">00000000004004c0 &lt;.plt&gt;:</span><br><span class="line">  4004c0:       ff 35 42 0b 20 00       pushq  0x200b42(%rip)        <span class="comment"># 601008 &lt;_GLOBAL_OFFSET_TABLE_+0x8&gt;</span></span><br><span class="line">  4004c6:       ff 25 44 0b 20 00       jmpq   *0x200b44(%rip)        <span class="comment"># 601010 &lt;_GLOBAL_OFFSET_TABLE_+0x10&gt;</span></span><br><span class="line">  4004cc:       0f 1f 40 00             nopl   0x0(%rax)</span><br><span class="line"></span><br><span class="line">00000000004004d0 &lt;puts@plt&gt;:</span><br><span class="line">  4004d0:       ff 25 42 0b 20 00       jmpq   *0x200b42(%rip)        <span class="comment"># 601018 &lt;puts@GLIBC_2.2.5&gt;</span></span><br><span class="line">  4004d6:       68 00 00 00 00          pushq  <span class="variable">$0x0</span></span><br><span class="line">  4004db:       e9 e0 ff ff ff          jmpq   4004c0 &lt;.plt&gt;</span><br><span class="line"></span><br><span class="line">00000000004004e0 &lt;<span class="built_in">printf</span>@plt&gt;:</span><br><span class="line">  4004e0:       ff 25 3a 0b 20 00       jmpq   *0x200b3a(%rip)        <span class="comment"># 601020 &lt;printf@GLIBC_2.2.5&gt;</span></span><br><span class="line">  4004e6:       68 01 00 00 00          pushq  <span class="variable">$0x1</span></span><br><span class="line">  4004eb:       e9 d0 ff ff ff          jmpq   4004c0 &lt;.plt&gt;</span><br></pre></td></tr></table></figure>
<h3 id="开始">开始</h3>
<ol>
<li>首先断点到 puts 函数，查看调用处：</li>
</ol>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="comment">@(gdb) disassemble main</span></span><br><span class="line"><span class="symbol">Dump</span> of assembler <span class="meta">code</span> for <span class="meta">function</span> main:</span><br><span class="line">   <span class="number">0x00000000004005d6</span> &lt;+<span class="number">0</span>&gt;:     <span class="keyword">push</span>   %rbp</span><br><span class="line">   <span class="number">0x00000000004005d7</span> &lt;+<span class="number">1</span>&gt;:     <span class="keyword">mov</span>    %rsp,%rbp</span><br><span class="line">=&gt; <span class="number">0x00000000004005da</span> &lt;+<span class="number">4</span>&gt;:     <span class="keyword">mov</span>    <span class="number">$0x400698</span>,%edi</span><br><span class="line">   <span class="number">0x00000000004005df</span> &lt;+<span class="number">9</span>&gt;:     callq  <span class="number">0x4004d0</span> &lt;puts<span class="comment">@plt&gt;</span></span><br><span class="line">   <span class="number">0x00000000004005e4</span> &lt;+<span class="number">14</span>&gt;:    <span class="keyword">mov</span>    <span class="number">$0x400698</span>,%edi</span><br><span class="line">   <span class="number">0x00000000004005e9</span> &lt;+<span class="number">19</span>&gt;:    <span class="keyword">mov</span>    <span class="number">$0x0</span>,%eax</span><br><span class="line">   <span class="number">0x00000000004005ee</span> &lt;+<span class="number">24</span>&gt;:    callq  <span class="number">0x4004e0</span> &lt;printf<span class="comment">@plt&gt;</span></span><br><span class="line">   <span class="number">0x00000000004005f3</span> &lt;+<span class="number">29</span>&gt;:    <span class="keyword">mov</span>    <span class="number">$0x0</span>,%eax</span><br><span class="line">   <span class="number">0x00000000004005f8</span> &lt;+<span class="number">34</span>&gt;:    <span class="keyword">pop</span>    %rbp</span><br><span class="line">   <span class="number">0x00000000004005f9</span> &lt;+<span class="number">35</span>&gt;:    retq</span><br><span class="line"><span class="symbol">End</span> of assembler dump.</span><br></pre></td></tr></table></figure>
<p>可以看到，调用处实际上是使用 call 指令走到 puts 的代码段。下面的 printf 也是如出一辙。</p>
<ol start="2">
<li>查看 puts@plt 的汇编指令</li>
</ol>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="comment">@(gdb) disassemble</span></span><br><span class="line"><span class="symbol">Dump</span> of assembler <span class="meta">code</span> for <span class="meta">function</span> puts<span class="comment">@plt:</span></span><br><span class="line">=&gt; <span class="number">0x00000000004004d0</span> &lt;+<span class="number">0</span>&gt;:     jmpq   *<span class="number">0x200b42</span>(%rip)        # <span class="number">0x601018</span> &lt;puts<span class="comment">@got.plt&gt;</span></span><br><span class="line">   <span class="number">0x00000000004004d6</span> &lt;+<span class="number">6</span>&gt;:     pushq  <span class="number">$0x0</span></span><br><span class="line">   <span class="number">0x00000000004004db</span> &lt;+<span class="number">11</span>&gt;:    jmpq   <span class="number">0x4004c0</span></span><br><span class="line"><span class="symbol">End</span> of assembler dump.</span><br></pre></td></tr></table></figure>
<p>可以看到，在汇编中，他首先要跳转到 0x601018 地址的位置。这个地址内容是个全局变量，实际上根据节的地址位置和大小可以判断，是处于 .got.plt 的位置内（ 0x601000 ~ 0x601028）。所以可以认为，在 .got.plt 中，存在了 puts 函数的地址。</p>
<ol start="3">
<li>查看 .got.plt</li>
</ol>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="comment">@(gdb) x/16x 0x601018</span></span><br><span class="line"><span class="number">0x601018</span> &lt;puts<span class="comment">@got.plt&gt;:        0x004004d6      0x00000000      0x004004e6      0x00000000</span></span><br><span class="line"><span class="number">0x601028</span>:       <span class="number">0x00000000</span>      <span class="number">0x00000000</span>      <span class="number">0x00000000</span>      <span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x601038</span>:       <span class="number">0x00000000</span>      <span class="number">0x00000000</span>      <span class="number">0x00000000</span>      <span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x601048</span>:       <span class="number">0x00000000</span>      <span class="number">0x00000000</span>      <span class="number">0x00000000</span>      <span class="number">0x00000000</span></span><br></pre></td></tr></table></figure>
<p>查看表中内容，发现跳转的地址是 0x4004d6，<strong>这不就是我们跳转之前的下一个地址吗！（puts@plt 的第二条指令）</strong> 同理，printf 函数也是如此（0x4004e6）。这是因为，之前没有调用过 puts 函数，第一次查找的时候，.got.plt 表中找不到函数的地址，那就先返回继续执行去调用链接器获取地址。</p>
<ol start="4">
<li>准备调用链接器</li>
</ol>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="number">00000000004004</span><span class="built_in">d0</span> &lt;puts<span class="comment">@plt&gt;:</span></span><br><span class="line">  <span class="number">4004</span><span class="built_in">d0</span>:       ff <span class="number">25</span> <span class="number">42</span> <span class="number">0</span>b <span class="number">20</span> <span class="number">00</span>       jmpq   *<span class="number">0x200b42</span>(%rip)        # <span class="number">601018</span> &lt;puts<span class="comment">@GLIBC_2.2.5&gt;</span></span><br><span class="line">  <span class="number">4004</span><span class="built_in">d6</span>:       <span class="number">68</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          pushq  <span class="number">$0x0</span></span><br><span class="line">  <span class="number">4004</span>db:       e9 e0 ff ff ff          jmpq   <span class="number">4004</span><span class="built_in">c0</span> &lt;.plt&gt;</span><br></pre></td></tr></table></figure>
<p>首先 pushq $0x0，这个是在 got.plt 中的编号，如 puts 是 0，printf 是 1。这个参数是给后续链接器使用的。然后跳到了 .plt 的位置执行（0x4004c0）。可以看到，printf@plt 函数最后也是跳到这个位置执行。</p>
<ol start="5">
<li>调用链接器</li>
</ol>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="number">00000000004004</span><span class="built_in">c0</span> &lt;.plt&gt;:</span><br><span class="line">  <span class="number">4004</span><span class="built_in">c0</span>:       ff <span class="number">35</span> <span class="number">42</span> <span class="number">0</span>b <span class="number">20</span> <span class="number">00</span>       pushq  <span class="number">0x200b42</span>(%rip)        # <span class="number">601008</span> &lt;_GLOBAL_OFFSET_TABLE_+<span class="number">0x8</span>&gt;</span><br><span class="line">  <span class="number">4004</span><span class="built_in">c6</span>:       ff <span class="number">25</span> <span class="number">44</span> <span class="number">0</span>b <span class="number">20</span> <span class="number">00</span>       jmpq   *<span class="number">0x200b44</span>(%rip)        # <span class="number">601010</span> &lt;_GLOBAL_OFFSET_TABLE_+<span class="number">0x10</span>&gt;</span><br><span class="line">  <span class="number">4004</span>cc:       <span class="number">0</span>f <span class="number">1</span>f <span class="number">40</span> <span class="number">00</span>             nopl   <span class="number">0x0</span>(%rax)</span><br></pre></td></tr></table></figure>
<p>首先 push 了 0x601008 到栈中，这是 .got.plt 表中的一个地址。之后跳转到 0x601010 所存储的地址去执行相应的代码。不难看出，0x601010 也是存储在 .got.plt 表中的。查看一下存储的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@(gdb) x/10x 0x601010</span><br><span class="line">0x601010:       0xf7de64a0      0x00007fff      0x004004d6      0x00000000</span><br><span class="line">0x601020 &lt;printf@got.plt&gt;:      0x004004e6      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x601030:       0x00000000      0x00000000</span><br></pre></td></tr></table></figure>
<p>可以看到，是让我们跳转到 0x00007ffff7de64a0 去执行相应的代码。那么这块代码是什么呢？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@(gdb) info sharedlibrary</span><br><span class="line">From                To                  Syms Read   Shared Object Library</span><br><span class="line">0x00007ffff7dd0fa0  0x00007ffff7df2cd4  Yes (*)     /lib64/ld-linux-x86-64.so.2</span><br><span class="line">0x00007ffff7a2cb90  0x00007ffff7b798ad  Yes (*)     /lib64/libc.so.6</span><br><span class="line">(*): Shared library is missing debugging information.</span><br></pre></td></tr></table></figure>
<p>可以看到，该地址是 <a href="http://ld-linux-x86-64.so">ld-linux-x86-64.so</a> 加载的位置。说明执行的是链接器的代码。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>: x/<span class="number">5</span>i $<span class="built_in">pc</span></span><br><span class="line">=&gt; <span class="number">0x7ffff7de64a0</span> &lt;_dl_runtime_resolve_xsavec&gt;: endbr64</span><br><span class="line">   <span class="number">0x7ffff7de64a4</span> &lt;_dl_runtime_resolve_xsavec+<span class="number">4</span>&gt;:       <span class="keyword">push</span>   %rbx</span><br><span class="line">   <span class="number">0x7ffff7de64a5</span> &lt;_dl_runtime_resolve_xsavec+<span class="number">5</span>&gt;:       <span class="keyword">mov</span>    %rsp,%rbx</span><br><span class="line">   <span class="number">0x7ffff7de64a8</span> &lt;_dl_runtime_resolve_xsavec+<span class="number">8</span>&gt;:       <span class="keyword">and</span>    <span class="number">$0xffffffffffffffc0</span>,%rsp</span><br><span class="line">   <span class="number">0x7ffff7de64ac</span> &lt;_dl_runtime_resolve_xsavec+<span class="number">12</span>&gt;:</span><br><span class="line">    <span class="keyword">sub</span>    <span class="number">0x21616d</span>(%rip),%rsp        # <span class="number">0x7ffff7ffc620</span> &lt;_rtld_local_ro+<span class="number">384</span>&gt;</span><br><span class="line"><span class="comment">@(gdb) bt</span></span><br><span class="line"><span class="comment">#0  0x00007ffff7de64a0 in _dl_runtime_resolve_xsavec () from /lib64/ld-linux-x86-64.so.2</span></span><br><span class="line"><span class="comment">#1  0x00000000004005e4 in main () at plt.c:3</span></span><br></pre></td></tr></table></figure>
<p>可以看到这里代码执行的是 ld 中的 _dl_runtime_resolve_xsavec 函数是第一次函数调用时用于查找函数符号的，并且在结尾处会直接去调用找到的函数符号（本文中为 puts 函数）。</p>
<ol start="6">
<li>写回 .got.plt 表<br>
在 puts 上打个断点，这样继续的话就是执行完 _dl_runtime_resolve_xsavec 还未执行 puts 的状态了。</li>
</ol>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="comment">@(gdb) bt</span></span><br><span class="line"><span class="comment">#0  0x00007ffff7a7d8c0 in puts () from /lib64/libc.so.6</span></span><br><span class="line"><span class="comment">#1  0x00000000004005e4 in main () at plt.c:3</span></span><br><span class="line"><span class="comment">@(gdb) x/10x 0x601018</span></span><br><span class="line"><span class="number">0x601018</span> &lt;puts<span class="comment">@got.plt&gt;:        0xf7a7d8c0      0x00007fff      0x004004e6      0x00000000</span></span><br><span class="line"><span class="number">0x601028</span>:       <span class="number">0x00000000</span>      <span class="number">0x00000000</span>      <span class="number">0x00000000</span>      <span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x601038</span>:       <span class="number">0x00000000</span>      <span class="number">0x00000000</span></span><br></pre></td></tr></table></figure>
<p>可以看到，此时，got.plt 表中的地址已经被写为 puts 函数实际的地址了（0x00007ffff7a7d8c0 在 0x00007ffff7a2cb90  ~ 0x00007ffff7b798ad 范围内，属于 /lib64/libc.so.6），这样下次调用 puts 就不用再次调用链接器了。</p>
<h3 id="题外话">题外话</h3>
<p>其实看一下 .got.plt 表的内容，会发现明明 puts 是第一个需要被链接的函数，为什么第一个却不是它呢？</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="comment">@(gdb) x/10x 0x601000</span></span><br><span class="line"><span class="number">0x601000</span>:       <span class="number">0x0000000000600e10</span>      <span class="number">0x00007ffff7ffe1d0</span></span><br><span class="line"><span class="number">0x601010</span>:       <span class="number">0x00007ffff7de64a0</span>      <span class="number">0x00007ffff7a7d8c0</span></span><br><span class="line"><span class="number">0x601020</span> &lt;printf<span class="comment">@got.plt&gt;:      0x00000000004004e6      0x0000000000000000</span></span><br><span class="line"><span class="number">0x601030</span>:       <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x601040</span>:       <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure>
<p>puts 地址实际上是 got[3]:0x00007ffff7a7d8c0，前面还有 3 项。其中：</p>
<ul>
<li>got[0]:0x0000000000600e10 自身模块 dynamic 段地址</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@(gdb) info symbol 0x0000000000600e10</span><br><span class="line">_DYNAMIC <span class="keyword">in</span> section .dynamic of /root/xxx/plt</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>got[1]:0x00007ffff7ffe1d0 本模块的 link_map 的地址。编译期间会初始化为 0。link_map 是一个双向链表的入口，链接进程所有加载的动态库。当链接器查找符号时，通过遍历该链表找到对应的符号。</p>
</li>
<li>
<p>got[2]:0x00007ffff7de64a0 _dl_runtime_resolve_xsavec 的地址。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@(gdb) info symbol 0x00007ffff7de64a0</span><br><span class="line">_dl_runtime_resolve_xsavec <span class="keyword">in</span> section .text of /lib64/ld-linux-x86-64.so.2</span><br></pre></td></tr></table></figure>
<p>_dl_runtime_resolve 格式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用形式为：</span></span><br><span class="line">_dl_runtime_resolve((link_map*)(got[<span class="number">1</span>]), <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 第二个参数 0，为 &lt;puts@plt&gt;:中的 pushq $0x0；</span></span><br><span class="line"><span class="comment">// 同理如果是 printf，就是&lt;printf@plt&gt;:中 pushq $0x1；</span></span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>虚拟地址空间内流程图：<br>
<img src="/20230613093018_2903084538/1.png" alt="1"></p>
<p>第二次调用：<br>
<img src="/20230613093018_2903084538/2.png" alt="2"></p>
]]></content>
      <categories>
        <category>compiler</category>
      </categories>
      <tags>
        <tag>compiler</tag>
      </tags>
  </entry>
  <entry>
    <title>select&amp;poll&amp;epoll的区别</title>
    <url>/20230419003547_3397109457/</url>
    <content><![CDATA[<h1>什么是多路复用</h1>
<p>操作系统在处理 I/O 的时候，分为两个阶段：</p>
<ol>
<li>等待数据到达内核空间。</li>
<li>等待数据从内核空间拷贝到用户空间。</li>
</ol>
<p>在 Linux 操作系统中，多路复用的方式有三种。分别是 select，poll，和 epoll。I/O 多路复用为，只通过一种机制，可以监视多个描述符，一旦某个描述符就绪（读就绪/写就绪），能够通知程序进行相应的读写操作。</p>
<p>但 select，poll，epoll 本质上都是同步 I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步 I/O 则无需自己负责进行读写，异步 I/O 的实现会负责把数据从内核拷贝到用户空间。</p>
<h1>select</h1>
<p>单个进程就可以同时处理多个网络连接的 I/O 请求（同时阻塞多个 I/O 操作）。</p>
<p>基本原理就是：</p>
<ol>
<li>程序调用 select，然后整个程序就阻塞状态。</li>
<li>这时候，内核就会<em><strong>轮询检查</strong></em>所有 select 负责的文件描述符集合 fd_set（一般上限为 1024 个），当找到其中那个的数据准备好了的文件描述符返回给 select。</li>
<li>select 进行系统调用，将数据从内核复制到进程缓冲区（用户空间）。</li>
</ol>
<p><img src="/20230419003547_3397109457/1.png" alt="1"></p>
<p>select的缺点：</p>
<ol>
<li>每次调用 select，都需要把 fd_set 从用户态拷贝到内核态，这个开销在 fd 很多时会很大。</li>
<li>同时每次调用 select 都需要在内核遍历传递进来的所有 fd，这个开销在 fd 很多时也很大</li>
<li>select 支持的文件描述符数量太小了，默认是 1024</li>
</ol>
<h1>poll</h1>
<p>poll的原理与select非常相似，差别如下：</p>
<ol>
<li>描述fd集合的方式不同，poll 使用 pollfd 结构而不是 fd_set 结构，是链式的，所以没有最大连接数的限制。</li>
<li>poll 有一个特点是水平触发，也就是通知程序 fd 就绪后，这次没有被处理，那么下次 poll 的时候会再次通知同样的 fd 已经就绪。</li>
</ol>
<p>poll 解决了 fd_set 有上限的情况，并且每次读就绪描述符集合时不用保存之前的状态。</p>
<h1>epoll</h1>
<p>epoll 提供了三个函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create</span><span class="params">(<span class="type">int</span> size)</span></span>;</span><br><span class="line"><span class="comment">//  建立一個 epoll 对象，并传回它的id</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span></span>;</span><br><span class="line"><span class="comment">//  事件注册函数，将需要监听的事件和需要监听的fd交给epoll对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span></span>;</span><br><span class="line"><span class="comment">//  等待注册的事件被触发或者timeout发生</span></span><br></pre></td></tr></table></figure>
<p>epoll解决的问题：</p>
<ol>
<li>epoll没有fd数量限制</li>
</ol>
<blockquote>
<p>epoll没有这个限制，我们知道每个 epoll 监听一个 fd，所以最大数量与能打开的 fd 数量有关，一个 G 的内存的机器上，能打开10万个左右</p>
</blockquote>
<ol start="2">
<li>epoll 不需要每次都从用户空间将 fd_set 复制到内核</li>
</ol>
<blockquote>
<p>epoll 在用 epoll_ctl 函数进行事件注册的时候，已经将 fd 复制到内核中，所以不需要每次都重新复制一次</p>
</blockquote>
<ol start="3">
<li>select 和 poll 都是主动轮询机制，需要遍历每一个人 fd；而 epoll 是被动触发方式。</li>
</ol>
<blockquote>
<p>epoll_ctl 给 fd 注册了相应事件的时候，我们为每一个 fd 指定了一个<em><strong>回调函数</strong></em>，当数据准备好之后，就会把就绪的 fd 加入一个就绪的队列中，epoll_wait 的工作方式实际上就是在这个<em><strong>就绪队列中查看</strong></em>有没有就绪的 fd，如果有，就唤醒就绪队列上的等待者，然后调用回调函数。</p>
</blockquote>
<blockquote>
<p>虽然 epoll, poll, select 都需要查看是否有 fd 就绪，但是 epoll 之所以是被动触发，就在于它<em><strong>只要去查找就绪队列</strong></em>中有没有 fd，就绪的 fd 是主动加到队列中，epoll 不需要一个个轮询确认。</p>
</blockquote>
<blockquote>
<p>换一句话讲，就是 select 和 poll 只能通知有 fd 已经就绪了，但不能知道究竟是哪个 fd 就绪，所以 select 和 poll 就要去主动<strong>轮询一遍</strong>所有监听的 fd 才能找到就绪的 fd。而 epoll 则是不但可以知道有 fd 可以就绪，而且还具体可以知道就绪 fd 的编号，所以直接找到就可以，不用轮询。</p>
</blockquote>
<p>注意，epoll 只有 Linux 上面有。</p>
]]></content>
      <categories>
        <category>socket-programming</category>
        <category>concurrent-programming</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>socket</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>x86_64常用汇编</title>
    <url>/20230530190403_3280945033/</url>
    <content><![CDATA[<p>本文用以记录常用汇编指令以供快速查找回忆，仅限于 X86_64 的 AT&amp;T 格式。</p>
<h2 id="语法格式">语法格式</h2>
<h3 id="1-引用寄存器前加-。如">1. 引用寄存器前加 %。如</h3>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span>    %rsp, %rbp</span><br></pre></td></tr></table></figure>
<h3 id="2-指令长度后缀">2. 指令长度后缀</h3>
<p>对于访问内存的数据，指令后加上 b w l q，操作 1 2 4 8 字节。如</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">movb</span>   <span class="number">$0x1</span>,<span class="number">0x201c3f</span>(%rip)</span><br><span class="line"><span class="symbol">nopw</span>   %cs:<span class="number">0x0</span>(%rax,%rax,<span class="number">1</span>)</span><br><span class="line"><span class="symbol">movl</span>   <span class="number">$0x5</span>,-<span class="number">0xc</span>(%rbp)</span><br><span class="line"><span class="symbol">movq</span>   <span class="number">$0x400b30</span>,-<span class="number">0x18</span>(%rbp)</span><br></pre></td></tr></table></figure>
<h3 id="3-立即数前加-。16-进制数用-0x-开头。如">3. 立即数前加 $。16 进制数用 0x 开头。如</h3>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">movl</span>   <span class="number">$1</span>, %eax</span><br><span class="line"><span class="keyword">mov</span>    <span class="number">$0x0</span>,%eax</span><br></pre></td></tr></table></figure>
<h3 id="4-注释可以用-开头，也可以用">4. 注释可以用 ! 开头，也可以用 ;</h3>
<h3 id="5-操作数顺序">5. 操作数顺序</h3>
<p>从源操作数到目的操作数，如下将 %rsp 寄存器中的数传给 %rbp 寄存器。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span>    %rsp,%rbp</span><br></pre></td></tr></table></figure>
<h3 id="6-数据声明">6. 数据声明</h3>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">数据类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">.ascii</td>
<td style="text-align:center">文本字符串</td>
</tr>
<tr>
<td style="text-align:center">.asciz</td>
<td style="text-align:center">以空字符串结尾的文本字符串</td>
</tr>
<tr>
<td style="text-align:center">.byte</td>
<td style="text-align:center">字节值</td>
</tr>
<tr>
<td style="text-align:center">.double</td>
<td style="text-align:center">双精度浮点数</td>
</tr>
<tr>
<td style="text-align:center">.float</td>
<td style="text-align:center">单精度浮点数</td>
</tr>
<tr>
<td style="text-align:center">.single</td>
<td style="text-align:center">单精度浮点数同上</td>
</tr>
<tr>
<td style="text-align:center">.int</td>
<td style="text-align:center">32位整数</td>
</tr>
<tr>
<td style="text-align:center">.long</td>
<td style="text-align:center">32位整数同上</td>
</tr>
<tr>
<td style="text-align:center">.octa</td>
<td style="text-align:center">16字节整数</td>
</tr>
<tr>
<td style="text-align:center">.quad</td>
<td style="text-align:center">8字节整数</td>
</tr>
<tr>
<td style="text-align:center">.short</td>
<td style="text-align:center">16位整数</td>
</tr>
<tr>
<td style="text-align:center">.comm</td>
<td style="text-align:center">声明未初始化的数据的通用内存区域</td>
</tr>
<tr>
<td style="text-align:center">.lcomm</td>
<td style="text-align:center">声明未初始化的数据的本地通用内存区域</td>
</tr>
</tbody>
</table>
<h3 id="7-文件组成">7. 文件组成</h3>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">.org</td>
<td style="text-align:center">定义当前汇编位置</td>
</tr>
<tr>
<td style="text-align:center">.globl</td>
<td style="text-align:center">让段全局可见</td>
</tr>
<tr>
<td style="text-align:center">.text</td>
<td style="text-align:center">存放代码指令正文段</td>
</tr>
<tr>
<td style="text-align:center">.bss</td>
<td style="text-align:center">存放未初始化的全局和静态变量，运行时该区域初始化为 0</td>
</tr>
<tr>
<td style="text-align:center">.rodata</td>
<td style="text-align:center">read only data</td>
</tr>
<tr>
<td style="text-align:center">.data</td>
<td style="text-align:center">可读可写的数据段</td>
</tr>
</tbody>
</table>
<h3 id="8-寻址方式">8. 寻址方式</h3>
<ul>
<li>直接寻址：把某个地址上的值放到寄存器中</li>
</ul>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span>    <span class="number">$0x8000</span>,%eax</span><br></pre></td></tr></table></figure>
<ul>
<li>间址寻址：把寄存器上的值所代表的地址所指向的值放到寄存器中</li>
</ul>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">movl</span>   <span class="number">$0x8000</span>,%ebx  </span><br><span class="line"><span class="symbol">movl</span>   (%ebx),%eax  <span class="comment">; 间址寻址, 把地址 0x8000（在寄存器 %ebx 中）上的值放到 %eax 中</span></span><br></pre></td></tr></table></figure>
<ul>
<li>基址寻址：以寄存器里的数值作为基址，加上一个常数得到最终地址，把地址上的值放到寄存器中</li>
</ul>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">movl</span>   <span class="number">$0x8000</span>,%eax  </span><br><span class="line"><span class="symbol">movl</span>   <span class="number">4</span>(%eax),%ebx  <span class="comment">; 基址寻址, 把地址 0x8004（0x8000+4）上的值放到 %eax 中</span></span><br></pre></td></tr></table></figure>
<ul>
<li>变址寻址：以两个寄存器里的数值之和加上一个常数得到最终地址，把地址上的值放到寄存器中</li>
</ul>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">movl</span>   <span class="number">$0x8000</span>,%eax</span><br><span class="line"><span class="symbol">movl</span>   <span class="number">$0x4</span>,%ebx</span><br><span class="line"><span class="symbol">movl</span>   (%eax,%ebx),%ecx    <span class="comment">; 变址寻址, 把地址 0x8004（0x8000+4）上的值放到 %ecx 中</span></span><br><span class="line"><span class="symbol">movl</span>   <span class="number">4</span>(%eax,%ebx),%ecx   <span class="comment">; 变址寻址, 把地址 0x8008（0x8000+4+4）上的值放到 %ecx 中</span></span><br></pre></td></tr></table></figure>
<ul>
<li>比例变址寻址：以一个寄存器里的数值加上另一个寄存器里的数字，乘以一个比例因子（1,2,4,8）再加上一个常数得到最终地址，把地址上的值放到寄存器中</li>
</ul>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">movl</span>   <span class="number">$0x2000</span>,%eax   </span><br><span class="line"><span class="symbol">movl</span>   <span class="number">$0x2</span>,%ebx   </span><br><span class="line"><span class="symbol">movl</span>   (,%eax,<span class="number">4</span>),%ecx      <span class="comment">; 比例变址寻址, 把地址 0x8000（0 + 0x2000*4）上的值放到 %ecx 中</span></span><br><span class="line"><span class="symbol">movl</span>   <span class="number">6</span>(,%eax,<span class="number">4</span>), %ecx    <span class="comment">; 比例变址寻址, 把地址 0x8006（0 + 0x2000*4 + 6）上的值放到 %ecx 中</span></span><br><span class="line"><span class="symbol">movl</span>   (%ebx,%eax,<span class="number">4</span>),%ecx  <span class="comment">; 比例变址寻址, 把地址 0x8002（0x2 + 0x2000*4）上的值放到 %ecx 中</span></span><br><span class="line"><span class="symbol">movl</span>   <span class="number">6</span>(%ebx,%eax,<span class="number">4</span>),%ecx <span class="comment">; 比例变址寻址, 把地址 0x8008（0x2 + 0x2000*4 + 6）上的值放到 %ecx 中</span></span><br></pre></td></tr></table></figure>
<h2 id="常见指令">常见指令</h2>
<h3 id="1-mov-用于将源操作数移动到目的操作数">1. mov 用于将源操作数移动到目的操作数</h3>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span>    %rsp,%rbp      <span class="comment">; %rbp = %rsp</span></span><br></pre></td></tr></table></figure>
<h3 id="2-add-用于将源操作数加给目的操作数">2. add 用于将源操作数加给目的操作数</h3>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">addl</span>   %eax,%ebx      <span class="comment">; %ebx = %ebx + %eax</span></span><br></pre></td></tr></table></figure>
<h3 id="3-sub-用于将两个数相减">3. sub 用于将两个数相减</h3>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">subl</span>   %eax,%ebx      <span class="comment">; %ebx = %ebx - %eax</span></span><br></pre></td></tr></table></figure>
<h3 id="4-inc-用于加一">4. inc 用于加一</h3>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">incl</span>   %eax           <span class="comment">; %eax = %eax + 1</span></span><br></pre></td></tr></table></figure>
<h3 id="5-dec-用于减一">5. dec 用于减一</h3>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">decl</span>   %eax           <span class="comment">; %eax = %eax - 1</span></span><br></pre></td></tr></table></figure>
<h3 id="6-push-用于将数据压入栈">6. push 用于将数据压入栈</h3>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">pushl</span>  %eax           <span class="comment">; 入栈，%esp = %esp - 0x4, %esp = %eax </span></span><br></pre></td></tr></table></figure>
<h3 id="7-pop-用于将数据出栈">7. pop 用于将数据出栈</h3>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">popl</span>   %eax           <span class="comment">; 出栈，%eax = %esp, %esp = %esp + 0x4</span></span><br></pre></td></tr></table></figure>
<h3 id="8-jmp-跳转">8. jmp 跳转</h3>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">jmp</span>    label          <span class="comment">; 无条件跳转为 label, %rip = label</span></span><br><span class="line"><span class="symbol">je</span>     label          <span class="comment">; 相等 ZF = 1, %rip = label</span></span><br><span class="line"><span class="symbol">jne</span>    label          <span class="comment">; 不相等 ZF = 0, %rip = label</span></span><br><span class="line"><span class="symbol">jg</span>     label          <span class="comment">; 大于 %rip = label</span></span><br><span class="line"><span class="symbol">jge</span>    label          <span class="comment">; 大于等于 %rip = label</span></span><br><span class="line"><span class="symbol">jl</span>     label          <span class="comment">; 小于 %rip = label</span></span><br><span class="line"><span class="symbol">jle</span>    label          <span class="comment">; 小于等于 %rip = label</span></span><br><span class="line"><span class="symbol">ja</span>     label          <span class="comment">; 无符号比较 大于 %rip = label</span></span><br><span class="line"><span class="symbol">jae</span>    label          <span class="comment">; 无符号比较 大于等于 %rip = label</span></span><br><span class="line"><span class="symbol">jb</span>     label          <span class="comment">; 无符号比较 小于 %rip = label</span></span><br><span class="line"><span class="symbol">jbe</span>    label          <span class="comment">; 无符号比较 小于等于 %rip = label</span></span><br></pre></td></tr></table></figure>
<h3 id="9-mul-乘法">9. mul 乘法</h3>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">imull</span>  %eax,%ebx      <span class="comment">; %ebx = %eax * %ebx  用于有符号数</span></span><br><span class="line"><span class="symbol">mull</span>   %eax,%ebx      <span class="comment">; %ebx = %eax * %ebx  用于无符号数</span></span><br></pre></td></tr></table></figure>
<h3 id="10-div-除法">10. div 除法</h3>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">idivl</span>  %ebx           <span class="comment">; %edx = %eax % %ebx, %eax = %eax / %ebx  用于有符号数</span></span><br><span class="line"><span class="symbol">divl</span>   %ebx           <span class="comment">; %edx = %eax % %ebx, %eax = %eax / %ebx  用于无符号数</span></span><br></pre></td></tr></table></figure>
<h3 id="11-and-按位与">11. and 按位与</h3>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">andl</span>   %eax,%ebx      <span class="comment">; %ebx = %ebx &amp; %eax</span></span><br></pre></td></tr></table></figure>
<h3 id="12-or-按位或">12. or 按位或</h3>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">orl</span>    %eax,%ebx      <span class="comment">; %ebx = %ebx | %eax</span></span><br></pre></td></tr></table></figure>
<h3 id="13-xor-按位异位">13. xor 按位异位</h3>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">xorl</span>   %eax,%ebx      <span class="comment">; %ebx = %eax ^ %ebx</span></span><br></pre></td></tr></table></figure>
<h3 id="14-shl-和-sal-位左移">14. shl 和 sal 位左移</h3>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">shll</span>   <span class="number">$1</span>,%eax        <span class="comment">; %eax = %eax &lt;&lt; 1  逻辑左移，填充 0</span></span><br><span class="line"><span class="symbol">sall</span>   <span class="number">$1</span>,%eax        <span class="comment">; %eax = %eax &lt;&lt; 1  算数左移，填充 0</span></span><br></pre></td></tr></table></figure>
<h3 id="15-shr-和-sar-位右移">15. shr 和 sar 位右移</h3>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">shrl</span>   <span class="number">$1</span>,%eax        <span class="comment">; %eax = %eax &gt;&gt; 1  逻辑右移，填充 0</span></span><br><span class="line"><span class="symbol">sarl</span>   <span class="number">$1</span>,%eax        <span class="comment">; %eax = %eax &gt;&gt; 1  算数右移，填充 符号位</span></span><br></pre></td></tr></table></figure>
<h3 id="16-lea-装载有效地址">16. lea 装载有效地址</h3>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">leal</span>   <span class="number">8</span>(%ebx),%eax   <span class="comment">; %eax = 8 + %ebx 可理解为 %eax = &amp;(*(%ebx)) + 8</span></span><br></pre></td></tr></table></figure>
<h3 id="17-call-函数调用">17. call 函数调用</h3>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">call</span>   func_name      <span class="comment">; 将下一条指令的 %rip push 到栈中，之后 %rip = func_name </span></span><br></pre></td></tr></table></figure>
<h3 id="18-ret-函数返回">18. ret 函数返回</h3>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">ret</span>                   <span class="comment">; 将函数返回地址的下一条要执行指令的值赋值给 %rip，push %rip</span></span><br></pre></td></tr></table></figure>
<h3 id="19-test-与运算并设置标志寄存器">19. test 与运算并设置标志寄存器</h3>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">testl</span>  %eax,%ebx      <span class="comment">; %eax &amp; %ebx，不会改变这两个寄存器值，改变标志寄存器零标志位（ZF）、符号标志位（SF）、奇偶标志位（PF）和进位标志位（CF），但不会影响溢出标志位（OF）</span></span><br></pre></td></tr></table></figure>
<h3 id="20-cmp-比较操作数大小">20. cmp 比较操作数大小</h3>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">cmpl</span>   %eax,%ebx      <span class="comment">; 根据 %ebx - %eax 的值来改变零标志位（ZF）、符号标志位（SF）、奇偶标志位（PF）、进位标志位（CF）和溢出标志位（OF）</span></span><br></pre></td></tr></table></figure>
<h3 id="21-rep-重复执行指令直到某一条件">21. rep 重复执行指令直到某一条件</h3>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">repz</span>   movsb          <span class="comment">; 重复执行 movsb 直到 ZF = 0</span></span><br><span class="line"><span class="symbol">repne</span>  scasb          <span class="comment">; 重复执行 scasb 直到 ZF = 1</span></span><br></pre></td></tr></table></figure>
<h3 id="22-lock-锁定总线">22. lock 锁定总线</h3>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">lock</span> addl <span class="number">$1</span>,(%eax)   <span class="comment">; 锁定总线，并使 *(%eax) = *(%eax) + 1，因为总线是锁定的，不会被其他处理器打断</span></span><br></pre></td></tr></table></figure>
<h3 id="23-xadd-交换两个操作数值，使他们相加">23. xadd 交换两个操作数值，使他们相加</h3>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">xaddl</span>  %eax,%ebx      <span class="comment">; tmp = %eax，%eax = %ebx，%ebx = tmp + %ebx 交换两个数，并将和写到 %ebx</span></span><br></pre></td></tr></table></figure>
<h3 id="24-nop-空操作">24. nop 空操作</h3>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">nop</span>                   <span class="comment">; 什么都不做，充当占位符或者插入延迟</span></span><br></pre></td></tr></table></figure>
<h3 id="25-hlt-使处理器暂停直到收到中断信号">25. hlt 使处理器暂停直到收到中断信号</h3>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">hlt</span>                   <span class="comment">; 使处理器进入暂停状态，直到发生外部中断。它通常用于操作系统内核中，以降低功耗和发热量。只有特权级别为 0 （内核态） 才能使用，否则会导致异常</span></span><br></pre></td></tr></table></figure>
<h3 id="26-xchg-交换两个操作数的值">26. xchg 交换两个操作数的值</h3>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">xchgl</span>  %eax,%ebx       <span class="comment">; tmp = %eax，%eax = %ebx，%ebx = tmp</span></span><br></pre></td></tr></table></figure>
<h3 id="27-cld-清除方向寄存器（DF）">27. cld 清除方向寄存器（DF）</h3>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">cld</span>                    <span class="comment">; 清除方向寄存器，使 %rdi 递增</span></span><br></pre></td></tr></table></figure>
<h3 id="28-movsb-移动字符串">28. movsb 移动字符串</h3>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">movsb</span>                  <span class="comment">; 以 %rsi 为源地址，%rdi 为目的地址，将字符以一个字节拷贝。每次执行 movsb，%rsi 和 %rdi 以方向标志寄存器（DF）自动递增或递减</span></span><br></pre></td></tr></table></figure>
<h3 id="29-scasb-查找字符">29. scasb 查找字符</h3>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">scasb</span>                  <span class="comment">; 将被查找字符放到 %al 中，与 %rdi 地址的字符串依次比较，根据比较结果设置标志寄存器</span></span><br></pre></td></tr></table></figure>
<h3 id="30-cli-禁用所有中断">30. cli 禁用所有中断</h3>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">cli</span>                    <span class="comment">; 禁用所用中断</span></span><br><span class="line"><span class="symbol">hlt</span>                    <span class="comment">; 使处理器保持暂停状态，直到中断被重新启用</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>asm</tag>
      </tags>
  </entry>
  <entry>
    <title>为何基类析构函数必须为虚函数</title>
    <url>/20220817112634_531881886/</url>
    <content><![CDATA[<h1>基类析构函数为虚函数的必要性</h1>
<p>由于 C++ 中类的多态性，使用基类指针指向派生类时，若函数是虚的，则调用派生类中的函数。析构函数也是如此。如果有个基类指针指向了派生类对象，删除这个指针，调用的则是派生类的析构函数。派生类的析构函数又会自动调用基类的析构函数，达到所有空间都释放的目的。</p>
<p>如果不声明为虚函数，那么编译器实行静态绑定，在删除基类指针时，只调用基类的虚构函数而不调用派生类的析构函数，造成派生类中有空间没有释放完全而导致<em><strong>内存泄漏</strong></em>。</p>
<p>所以声明为虚函数是必要的，为了防止只析构基类而不析构派生类。</p>
<h1>非虚析构函数会发生什么</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Parent</span>() &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;父类构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">Parent</span>() &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;父类析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Parent &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Son</span>() &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;子类构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">Son</span>() &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;子类析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Parent *p = <span class="keyword">new</span> <span class="built_in">Son</span>();</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    p = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@└────&gt; # ./a.out </span><br><span class="line">父类构造函数</span><br><span class="line">子类构造函数</span><br><span class="line">父类析构函数</span><br></pre></td></tr></table></figure>
<p>可以看到，子类析构函数并没有被调用到。</p>
<h1>基类析构函数定义为虚函数</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Parent</span>() &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;父类构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Parent</span>() &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;父类析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Parent &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Son</span>() &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;子类构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">Son</span>() &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;子类析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Parent *p = <span class="keyword">new</span> <span class="built_in">Son</span>();</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    p = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@└────&gt; # ./a.out </span><br><span class="line">父类构造函数</span><br><span class="line">子类构造函数</span><br><span class="line">子类析构函数</span><br><span class="line">父类析构函数</span><br></pre></td></tr></table></figure>
<h1>小技巧</h1>
<p>如果父类的设计者忘记了在析构函数处加 virtual，子类的设计者有义务提醒父类设计者，避免内存泄漏。</p>
<p>C++11 的关键字 override 可以起作用。override 表示函数应当重写基类中的虚函数（用于派生类的虚函数中）。编译器会检查基类中的虚函数和派生类中带有 override 的虚函数有没有相同的函数签名，一旦不匹配便会报错。</p>
<p>因此子类设计者可以在其析构函数后增加关键字 override，一旦父类缺少关键字 virtual，就会被编译器发现并报错。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Parent</span>() &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;父类构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">Parent</span>() &#123;  <span class="comment">// 此处没加 virtual，会有编译错误</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;父类析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Parent &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Son</span>() &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;子类构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">Son</span>() <span class="keyword">override</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;子类析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Parent *p = <span class="keyword">new</span> <span class="built_in">Son</span>();</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    p = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@└────&gt; # g++ test.cc </span><br><span class="line">test.cc:18:9: error: ‘Son::~Son()’ marked ‘override’, but does not override</span><br><span class="line">         ~Son() override &#123;</span><br><span class="line">         ^</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>不相干进程之间传递fd</title>
    <url>/20220404212726_25762/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> CONTROL_LEN = <span class="built_in">CMSG_LEN</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="comment">// 发送文件描述符，fd参数适用来传递信息的unix域socket，fd_to_send参数是待发送文件的文件描述符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">send_fd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> fd_to_send)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">iovec</span> iov[<span class="number">1</span>]; <span class="comment">// 单次系统调用对多个缓冲区进行读写</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">msghdr</span> msg;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    iov[<span class="number">0</span>].iov_base = buf;</span><br><span class="line">    iov[<span class="number">0</span>].iov_len = <span class="number">1</span>;</span><br><span class="line">    msg.msg_name = <span class="literal">NULL</span>;</span><br><span class="line">    msg.msg_namelen= <span class="number">0</span>;</span><br><span class="line">    msg.msg_iov = iov;</span><br><span class="line">    msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    cmsghdr cm;</span><br><span class="line">    cm.cmsg_len = CONTROL_LEN;</span><br><span class="line">    cm.cmsg_level = SOL_SOCKET;</span><br><span class="line">    cm.cmsg_type = SCM_RIGHTS;</span><br><span class="line">    *(<span class="type">int</span> *)<span class="built_in">CMSG_DATA</span>(&amp;cm) = fd_to_send;</span><br><span class="line">    <span class="comment">// 设置辅助数据</span></span><br><span class="line">    msg.msg_control = &amp;cm; </span><br><span class="line">    msg.msg_controllen = CONTROL_LEN;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sendmsg</span>(fd, &amp;msg, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接收目标文件描述符</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">recv_fd</span><span class="params">(<span class="type">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iovec</span> iov[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">msghdr</span> msg;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    iov[<span class="number">0</span>].iov_base = buf;</span><br><span class="line">    iov[<span class="number">0</span>].iov_len = <span class="number">1</span>;</span><br><span class="line">    msg.msg_name = <span class="literal">NULL</span>;</span><br><span class="line">    msg.msg_namelen = <span class="number">0</span>;</span><br><span class="line">    msg.msg_iov = iov;</span><br><span class="line">    msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    cmsghdr cm;</span><br><span class="line">    msg.msg_control = &amp;cm;</span><br><span class="line">    msg.msg_controllen = CONTROL_LEN;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">recvmsg</span>(fd, &amp;msg, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd_to_read = *(<span class="type">int</span> *)<span class="built_in">CMSG_DATA</span>(&amp;cm);</span><br><span class="line">    <span class="keyword">return</span> fd_to_read;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> fd_to_pass = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 创建父子进程间的管道，文件描述符fd[0] fd[1]都是unix域的socket</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">socketpair</span>(PF_UNIX, SOCK_DGRAM, <span class="number">0</span>, pipefd);</span><br><span class="line">    <span class="built_in">assert</span>(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="built_in">assert</span>(pid &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">close</span>(pipefd[<span class="number">0</span>]);</span><br><span class="line">        fd_to_pass = <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, O_RDWR, <span class="number">0666</span>);</span><br><span class="line">        <span class="comment">// 子进程通过管道将文件描述符发送到父进程，如果文件test.txt打开失败，则子进程将标准输入文件描述符发送到父进程</span></span><br><span class="line">        <span class="built_in">send_fd</span>(pipefd[<span class="number">1</span>], (fd_to_pass &gt; <span class="number">0</span>) ? fd_to_pass : <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">close</span>(fd_to_pass);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(pipefd[<span class="number">1</span>]); <span class="comment">// 父进程</span></span><br><span class="line">    fd_to_pass = <span class="built_in">recv_fd</span>(pipefd[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, <span class="number">1024</span>);</span><br><span class="line">    <span class="built_in">read</span>(fd_to_pass, buf, <span class="number">1024</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I got fd %d and data %s\n&quot;</span>, fd_to_pass, buf);</span><br><span class="line">    <span class="built_in">close</span>(fd_to_pass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子进程把打开的文件描述符fd值放入一个socket中，父进程从socket中读到fd的值，最后再读fd中的内容。<br>
运行结果：<br>
<img src="/20220404212726_25762/1.png" alt="在这里插入图片描述"></p>
<hr>
<p>reference：<br>
linux高性能服务器编程——游双$P_{267}$</p>
]]></content>
      <categories>
        <category>socket-programming</category>
        <category>concurrent-programming</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>socket</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>修改host实现访问github</title>
    <url>/20230409022514_6883/</url>
    <content><![CDATA[<h1>国内有时访问github会失败，这是为什么呢？</h1>
<p>CDN（Content Delivery Network），即内容分发网络，也称为内容传送网络。它主要依靠部署在各地的边缘服务器，平衡中心服务器的负荷，就近提供用户所需内容，提高响应速度和命中率。我们访问的就是github的CDN。<br>
DNS（Domain Name System）, 即域名系统，它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。主要是做域名解析，域名最终指向的是IP地址。我们输入github.com的时候，会经过DNS解析，得到一个ip地址，电脑再使用这个ip地址来访问github。<br>
DNS污染：就是域名系统被入侵或者认为的修改某些记录，导致对该域名的访问由原IP地址转入到修改后的指定IP，其结果就是对特定的网址不能访问或访问的是假网址。如果访问的DNS服务器被污染了，那么我们访问的网址ip可能就不对，导致访问失败。</p>
<h1>解决方案：修改host文件</h1>
<p>Windows：C:\Windows\System32\drivers\etc\hosts<br>
Mac/Linux: /etc/hosts<br>
优先级是host文件 &gt; DNS服务器。host文件是本地文件，优先级最高，如果它中有指定的域名，那么就可以使用host文件中指定的IP地址；而DNS服务器则是远程服务，优先级次之，如果host文件中没有指定的域名，那么就会使用DNS服务器来查找相应的IP地址。我们的目的就是在hosts中告诉电脑，<a href="http://xn--github-vy7ir11bqliy9du84c1v9flx1a.com">如果访问域名为github.com</a>，那么他的ip就按xxx.xxx.xxx.xxx来算。</p>
<h2 id="方法一">方法一</h2>
<p>通过网站查询。<a href="https://tool.chinaz.com/dns">https://tool.chinaz.com/dns</a>, <a href="http://xn--github-2l2j0122b.com">输入github.com</a>。得到ip地址，以</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">20.205.243.166  github.com</span><br></pre></td></tr></table></figure>
<p>的方式加入到hosts文件末尾。</p>
<h2 id="方法二">方法二</h2>
<p>用ping命令查询得到其ip地址。</p>
<p>但是这个ip地址是会变化的，有没有更快捷的方法？</p>
<h1>UsbEAm Hosts Editor</h1>
<p>该工具可以快速测速，一键加入hosts地址，只要点点点的方式就可以执行上述组合操作。<br>
下载博客地址：<a href="https://www.dogfight360.com/blog/475/">https://www.dogfight360.com/blog/475/</a><br>
上个软件的截图<br>
<img src="/20230409022514_6883/1.png" alt="软件截图"></p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>内存模型与内存序</title>
    <url>/20230607171855_854612321/</url>
    <content><![CDATA[<h2 id="硬件结构">硬件结构</h2>
<p>现代机器都是多个处理器，每个处理器有自己的 cache。这个结构如下所示:<br>
<img src="/20230607171855_854612321/1.png" alt="1"><br>
可以看到，每个 CPU 都有自己的缓存，之后再写到内存中。并且由于编译器的优化，你写的代码可能和你执行的代码顺序有所不同。他们优化的规则是：保证对于一个单核情况下，执行结果不会发生变化。但是多线程就不一定了。</p>
<p>那么在多线程情况下，如何协调这些 CPU 缓存的数据一致性就成了一个问题。</p>
<h2 id="常见优化">常见优化</h2>
<p>再谈保证数据的一致性之前，先谈谈编译器能做的优化。</p>
<h3 id="重排-Reordering">重排 Reordering</h3>
<p>编译器和 CPU 都会发生重排，为了提升代码的效率。采用乱序执行、流水线、分支预测以及多级缓存等方法来提升程序性能。编译器会基于这些规则来提升自己代码的速度，所以就会对指令进行优化。例子如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">()</span> &#123;</span><br><span class="line">    a = b + <span class="number">1</span>; <span class="comment">// L5</span></span><br><span class="line">    b = <span class="number">1</span>;     <span class="comment">// L6</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    fun();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="comment">@└────&gt; # gcc 1.c -O0 -g</span></span><br><span class="line"><span class="comment">@└────&gt; # objdump -d a.out</span></span><br><span class="line"><span class="number">0000000000400536</span> &lt;fun&gt;:</span><br><span class="line">  <span class="number">400536</span>:       <span class="number">55</span>                      <span class="keyword">push</span>   %rbp</span><br><span class="line">  <span class="number">400537</span>:       <span class="number">48</span> <span class="number">89</span> e5                <span class="keyword">mov</span>    %rsp,%rbp</span><br><span class="line">  <span class="number">40053</span>a:       <span class="number">8</span>b <span class="number">05</span> e4 <span class="number">0</span>a <span class="number">20</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">0x200ae4</span>(%rip),%eax        # <span class="number">601024</span> &lt;b&gt;</span><br><span class="line">  <span class="number">400540</span>:       <span class="number">83</span> <span class="built_in">c0</span> <span class="number">01</span>                <span class="keyword">add</span>    <span class="number">$0x1</span>,%eax</span><br><span class="line">  <span class="number">400543</span>:       <span class="number">89</span> <span class="number">05</span> <span class="built_in">d7</span> <span class="number">0</span>a <span class="number">20</span> <span class="number">00</span>       <span class="keyword">mov</span>    %eax,<span class="number">0x200ad7</span>(%rip)        # <span class="number">601020</span> &lt;__TMC_END__&gt;</span><br><span class="line">  <span class="number">400549</span>:       <span class="built_in">c7</span> <span class="number">05</span> <span class="built_in">d1</span> <span class="number">0</span>a <span class="number">20</span> <span class="number">00</span> <span class="number">01</span>    movl   <span class="number">$0x1</span>,<span class="number">0x200ad1</span>(%rip)        # <span class="number">601024</span> &lt;b&gt;</span><br><span class="line">  <span class="number">400550</span>:       <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line">  <span class="number">400553</span>:       <span class="number">90</span>                      <span class="keyword">nop</span></span><br><span class="line">  <span class="number">400554</span>:       <span class="number">5</span>d                      <span class="keyword">pop</span>    %rbp</span><br><span class="line">  <span class="number">400555</span>:       <span class="built_in">c3</span>                      retq</span><br><span class="line"></span><br><span class="line"><span class="comment">@└────&gt; # gcc 1.c -O2 -g</span></span><br><span class="line"><span class="comment">@└────&gt; # objdump -d a.out</span></span><br><span class="line"><span class="number">0000000000400560</span> &lt;fun&gt;:</span><br><span class="line">  <span class="number">400560</span>:       <span class="number">8</span>b <span class="number">05</span> ba <span class="number">0</span>a <span class="number">20</span> <span class="number">00</span>       <span class="keyword">mov</span>    <span class="number">0x200aba</span>(%rip),%eax        # <span class="number">601020</span> &lt;__TMC_END__&gt;</span><br><span class="line">  <span class="number">400566</span>:       <span class="built_in">c7</span> <span class="number">05</span> b0 <span class="number">0</span>a <span class="number">20</span> <span class="number">00</span> <span class="number">01</span>    movl   <span class="number">$0x1</span>,<span class="number">0x200ab0</span>(%rip)        # <span class="number">601020</span> &lt;__TMC_END__&gt;</span><br><span class="line">  <span class="number">40056</span>d:       <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line">  <span class="number">400570</span>:       <span class="number">83</span> <span class="built_in">c0</span> <span class="number">01</span>                <span class="keyword">add</span>    <span class="number">$0x1</span>,%eax</span><br><span class="line">  <span class="number">400573</span>:       <span class="number">89</span> <span class="number">05</span> ab <span class="number">0</span>a <span class="number">20</span> <span class="number">00</span>       <span class="keyword">mov</span>    %eax,<span class="number">0x200aab</span>(%rip)        # <span class="number">601024</span> &lt;a&gt;</span><br><span class="line">  <span class="number">400579</span>:       <span class="built_in">c3</span>                      retq   </span><br><span class="line">  <span class="number">40057</span>a:       <span class="number">66</span> <span class="number">0</span>f <span class="number">1</span>f <span class="number">44</span> <span class="number">00</span> <span class="number">00</span>       nopw   <span class="number">0x0</span>(%rax,%rax,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<ol>
<li>对于 O0 等级的优化，执行顺序是 L5-&gt;L6。</li>
<li>但是对于 O2 等级的优化，执行顺序是 L6-&gt;L5，但是结果是不影响的。</li>
</ol>
<p>为什么要这么做呢？因为 CPU 读取数据从 cache 中读取。如果不优化的话，先读 b，再读 a 的时候可能把 b 的缓存换出去了，那么再写 b 的时候还需要把 b 换进来。但是如果优化了，就是读 b，写 b，再写 a，就不存在缓存的换入换出了。</p>
<h3 id="插入-Invention">插入 Invention</h3>
<p>假设有如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    x[i] = y[i] + z[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可能优化成如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    __builtin_prefetch(&amp;y[i + <span class="number">16</span>]);</span><br><span class="line">    __builtin_prefetch(&amp;z[i + <span class="number">16</span>]);</span><br><span class="line">    x[i] = y[i] + z[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>预读取这些数据来减少缓存未命中次数。</p>
<h3 id="删除-Removal">删除 Removal</h3>
<p>删除很好理解了，删除没用的变量赋值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> z = x + y;</span><br><span class="line">x = <span class="number">3</span>;</span><br><span class="line">y = <span class="number">4</span>;</span><br></pre></td></tr></table></figure>
<p>优化后：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line">x = <span class="number">3</span>;</span><br><span class="line">y = <span class="number">4</span>;</span><br></pre></td></tr></table></figure>
<h2 id="关系术语">关系术语</h2>
<h3 id="sequence-before">sequence-before</h3>
<p>sequence-before 是对一个线程内，求值顺序关系的描述：</p>
<ul>
<li>A sequence-before B，先对 A 求值，再对 B 求值。</li>
<li>A not sequence-before B，并且 B not sequence-before A，那么 A 和 B 谁先求值是未知的。</li>
</ul>
<h3 id="synchronizes-with">synchronizes-with</h3>
<p>描述的是不同线程内的执行关系。在两个线程分别执行时，即使线程 A 先执行，线程 B 后执行，A 中写了某个共享变量，由于<strong>指令重排</strong>或者<strong>写到了 cache</strong> 或<strong>寄存器没来得及写入内存</strong>导致 B 读到了错误的值。</p>
<ul>
<li>A synchronizes-with B，在线程 A 中的写操作结果对线程 B 可见。</li>
</ul>
<h3 id="happens-before">happens-before</h3>
<p>是 sequence-before 的扩展，包括了不同线程的关系。</p>
<ul>
<li>A happens-before B，那么不但 A 先于 B 执行，并且 A 的结果对 B 可见。
<ul>
<li>同线程：和 sequence-before 一样。</li>
<li>不同线程：和 synchronizes-with 一样。</li>
</ul>
</li>
</ul>
<h2 id="内存序">内存序</h2>
<p>C++11 中引入了 6 种内存序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">memory_order</span> &#123;</span><br><span class="line">    memory_order_relaxed,</span><br><span class="line">    memory_order_consume,</span><br><span class="line">    memory_order_acquire,</span><br><span class="line">    memory_order_release,</span><br><span class="line">    memory_order_acq_rel,</span><br><span class="line">    memory_order_seq_cst</span><br><span class="line">&#125; memory_order;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">内存序类型</th>
<th style="text-align:center">用于读/写</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">memory_order_relaxed</td>
<td style="text-align:center">读/写</td>
<td style="text-align:center">仅要求<strong>原子性</strong>和<strong>内存一致性</strong></td>
</tr>
<tr>
<td style="text-align:center">memory_order_consume</td>
<td style="text-align:center">读</td>
<td style="text-align:center">读操作所在线程该操作<strong>后面的和该变量</strong> <em><strong>有依赖关系的</strong></em> <strong>读写操作不会被优化到先于该操作执行</strong></td>
</tr>
<tr>
<td style="text-align:center">memory_order_acquire</td>
<td style="text-align:center">读</td>
<td style="text-align:center">读操作所在线程该操作<strong>后面的读写操作不会被优化到先于该操作执行</strong></td>
</tr>
<tr>
<td style="text-align:center">memory_order_release</td>
<td style="text-align:center">写</td>
<td style="text-align:center">写操作所在线程该操作<strong>前面的读写操作不会被优化到后于该操作执行</strong></td>
</tr>
<tr>
<td style="text-align:center">memory_order_acq_rel</td>
<td style="text-align:center">读/写</td>
<td style="text-align:center">是 memory_order_acquire 和 memory_order_release 组成的双向屏障，<strong>上下皆不能跨过该指令</strong></td>
</tr>
<tr>
<td style="text-align:center">memory_order_seq_cst</td>
<td style="text-align:center">读/写</td>
<td style="text-align:center">双向屏障，并且<strong>该线程所有原子指令并且也指定为 memory_order_seq_cst 的都已全局内存修改顺序为参照</strong></td>
</tr>
</tbody>
</table>
<p>值得一提的是，若一个原子变量在一个线程中施加了 memory_order_release，但是在其他线程中没有使用 memory_order_acquire 或 memory_order_consume 读取，那么他就不会具备 memory_order_release 所赋予的屏障功能。（即只有被观测才会起作用，读操作也是如此）</p>
<p><img src="/20230607171855_854612321/2.png" alt="2"><br>
如上图所示，就像加锁一样会构成临界区。但是外面的变量可以移入临界区，却不能移出去，所以称 memory_order_acquire 和 memory_order_release 如同单向屏障一般。</p>
<h2 id="内存模型">内存模型</h2>
<p>一言以蔽之，引入内存模型的原因，有以下几个原因：</p>
<ol>
<li>编译器优化：在某些情况下，即使是简单的语句，也不能保证是原子操作。</li>
<li>CPU out-of-order：CPU 为了提升计算性能，可能会调整指令的执行顺序。</li>
<li>CPU Cache 不一致：在 CPU Cache 的影响下，在某个 CPU 下执行了指令，不会立即被其它 CPU 所看到。</li>
</ol>
<p>从上面的内存序中，按照访问控制的角度可以分为三种模型：</p>
<ol>
<li>Sequential Consistency 模型</li>
<li>Acquire-Release 模型</li>
<li>Relax 模型</li>
</ol>
<p>其中，Sequential Consistency 模型约束最强，Acquire-Release 次之，Relax 模型最弱。</p>
<h3 id="Sequential-Consistency-模型">Sequential Consistency 模型</h3>
<p>对应 memory_order_seq_cst 内存序。Sequential Consistency 模型有以下特点：</p>
<ul>
<li>每个线程的执行顺序与代码顺序严格一致</li>
<li>线程的执行顺序可能会交替进行，但是从单个线程的角度来看，仍然是顺序执行</li>
</ul>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">x = y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">thread1:</span><br><span class="line">x = <span class="number">1</span>;</span><br><span class="line">r1 = y;</span><br><span class="line"></span><br><span class="line">thread2:</span><br><span class="line">y = <span class="number">1</span>;</span><br><span class="line">r2 = x;</span><br></pre></td></tr></table></figure>
<p>那么可能的执行顺序为：</p>
<table>
<thead>
<tr>
<th style="text-align:center">可能性</th>
<th style="text-align:center">第一步</th>
<th style="text-align:center">第二步</th>
<th style="text-align:center">第三步</th>
<th style="text-align:center">第四步</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">x = 1</td>
<td style="text-align:center">r1 = y</td>
<td style="text-align:center">y = 1</td>
<td style="text-align:center">r2 = x</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">y = 1</td>
<td style="text-align:center">r2 = x</td>
<td style="text-align:center">x = 1</td>
<td style="text-align:center">r1 = y</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">x = 1</td>
<td style="text-align:center">y = 1</td>
<td style="text-align:center">r1 = y</td>
<td style="text-align:center">r2 = x</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">x = 1</td>
<td style="text-align:center">r2 = x</td>
<td style="text-align:center">y = 1</td>
<td style="text-align:center">r1 = y</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">y = 1</td>
<td style="text-align:center">x = 1</td>
<td style="text-align:center">r1 = y</td>
<td style="text-align:center">r2 = x</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">y = 1</td>
<td style="text-align:center">x = 1</td>
<td style="text-align:center">r2 = x</td>
<td style="text-align:center">r1 = y</td>
</tr>
</tbody>
</table>
<p>std::atomic 默认值都是使用 memory_order_seq_cst，保证不出错。但是相对的，限制了 CPU 并行处理的能力，会降低效率。这个模型的所有线程都参考全局的内存修改顺序。因此，我们可<strong>认为</strong>所有变量的读写都<strong>直接从内存</strong>进行，从而完全不用考虑 Cache，Store Buffer 这些因素。</p>
<h3 id="Acquire-Release-模型">Acquire-Release 模型</h3>
<p>对应 memory_order_consume、memory_order_acquire、memory_order_release、memory_order_acq_rel 内存序。对于一个原子变量 A，对 A 的写操作（Release）和读操作（Acquire）之间进行同步，并建立排序约束关系，即对于写操作（release）X，在写操作 X 之前的所有读写指令都不能放到写操作 X 之后；对于读操作（acquire）Y，在读操作 Y 之后的所有读写指令都不能放到读操作 Y 之前。</p>
<h3 id="Relax-模型">Relax 模型</h3>
<p>对应的是 memory_order_relaxed 内存序。其对于内存序的限制最小，也就是说这种方式只能保证当前的数据访问是原子操作（不会被其他线程的操作打断），但是对内存访问顺序没有任何约束，也就是说对不同的数据的读写可能会被重新排序。</p>
]]></content>
      <categories>
        <category>compiler</category>
      </categories>
      <tags>
        <tag>compiler</tag>
      </tags>
  </entry>
  <entry>
    <title>内存泄露定位</title>
    <url>/20221208021019_25309/</url>
    <content><![CDATA[<h1>什么是内存泄漏？</h1>
<p>内存泄漏（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或<br>
无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。</p>
<h1>valgrid工具</h1>
<p>(1) 简介：<br>
Valgrind 是一套 Linux 下，开放源代码（GPL V2）的仿真调试工具的集合。Valgrind 由<br>
内核（core）以及基于内核的其他调试工具组成。内核类似于一个框架（framework），它模<br>
拟了一个 CPU 环境，并提供服务给其他工具；而其他工具则类似于插件 (plug-in)，利用内<br>
核提供的服务完成各种特定的内存调试任务。最常用的工具为 Memcheck，用来检测程序中<br>
出现的内存问题，所有对内存的读写都会被检测到，一切对 malloc()/free()/new/delete 的调用<br>
都会被捕获。所以，它能检测以下问题：<br>
• 对未初始化内存的使用；<br>
• 读/写释放后的内存块；<br>
• 读/写超出 malloc 分配的内存块；<br>
• 读/写不适当的栈中内存块；<br>
• 内存泄漏，指向一块内存的指针永远丢失；<br>
• 不正确的 malloc/free 或 new/delete 匹配；<br>
• memcpy()相关函数中的 dst 和 src 指针重叠。<br>
(2) 使用示例：<br>
valgrind --log-file=report.log --tool=memcheck --leak-check=full --show-leak-kinds=all ./benc<br>
hmark arg1 arg2 …<br>
(3) 输出日志解读：<br>
• 报告中会指示出发生泄漏的函数和文件位置；<br>
• 最后会给出一个总结，标明了泄漏的内存总量；<br>
• definitely lost: 铁定丢失，一般来说存在明显的泄漏；<br>
• indirectly lost: 间接丢失，当使用了含有指针成员的类或结构时可能会报这个错误；<br>
• possibly lost: 可能丢失；<br>
• 只能定位到内存最初被申请的位置，不能定位到是哪里泄漏</p>
<h1>AddressSantizer</h1>
<p>(1) 简介：<br>
AddressSanitizer（ASan）是一个快速的内存错误检测工具。它包括一个编译器 instrumentation 模块和一个提供 malloc()/free()替代项的运行时库。<br>
(2) 使用：<br>
编译和链接选项中加入-fsanitize=address -fno-omit-frame-pointer 即可。可以通过 readelf <a href="http://xn--h6qv61aqxhhxp.so">工具查看.so</a> 的依赖库中是否包含 ASan 来确认编译是否成功。</p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>内嵌汇编</title>
    <url>/20230609105733_4112471478/</url>
    <content><![CDATA[<h2 id="为什么要使用内嵌汇编？">为什么要使用内嵌汇编？</h2>
<p>内嵌汇编通常用于在程序中实现一些高效、精确的操作。例如，在嵌入式平台上运行的程序，如果需要代码占用内存更小、程序运行的效率更高或需要准确地操作寄存器时，嵌入汇编会是不错的选择。</p>
<h2 id="基本语法">基本语法</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;assembly code&quot;</span>        <span class="comment">/* 汇编代码 */</span></span><br><span class="line">    :output_operand        <span class="comment">/* 输出参数列表 */</span>          </span><br><span class="line">    :input_operand         <span class="comment">/* 输入参数列表 */</span>          </span><br><span class="line">    :clobbered_operand     <span class="comment">/* 被改变的操作对象列表 */</span>      </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 举例</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">value_assignment</span><span class="params">(<span class="type">int</span> input)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;movl %1, %0\n&quot;</span>   <span class="comment">// 超过一条指令就要用 \n 来分割，排版整齐还要加 \t</span></span></span><br><span class="line"><span class="params">        :<span class="string">&quot;=r&quot;</span>(ret)</span></span><br><span class="line"><span class="params">        :<span class="string">&quot;r&quot;</span>(input)</span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="被改变的操作对象列表">被改变的操作对象列表</h3>
<p>在被改变的参数列表 clobbered_operand 中有一个比较有用的标识符：memory。指定 memory，相当于对编译器形成了一个内存读写的屏障，保证<strong>在内联汇编执行前，编译器将某些寄存器里的值刷新进内存，同时在内联汇编执行后，编译器重新加载相关变量的值</strong>。<br>
所以我们可以见到这样的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;&quot;</span> ::: <span class="string">&quot;memory&quot;</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>作为内存屏障，保证编译器的优化不会跨过这道屏障。加上 volatile 告诉编译器不要优化汇编。</p>
<h3 id="修饰符">修饰符</h3>
<p>修饰符一般跟在参数列表前面。</p>
<table>
<thead>
<tr>
<th style="text-align:center">修饰符</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">=</td>
<td style="text-align:center">只写，常用于修饰所有输出操作数</td>
</tr>
<tr>
<td style="text-align:center">无</td>
<td style="text-align:center">只读</td>
</tr>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">可读可写</td>
</tr>
<tr>
<td style="text-align:center">r</td>
<td style="text-align:center">可以是任意通用寄存器存储其值</td>
</tr>
<tr>
<td style="text-align:center">m</td>
<td style="text-align:center">一个有效的内存地址</td>
</tr>
<tr>
<td style="text-align:center">i</td>
<td style="text-align:center">是立即数</td>
</tr>
<tr>
<td style="text-align:center">%</td>
<td style="text-align:center">被修饰的操作数可以和下一个互换</td>
</tr>
<tr>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">只能做输出，一般和 “=” 一起使用，如 “=&amp;r(val)”</td>
</tr>
<tr>
<td style="text-align:center">x</td>
<td style="text-align:center">只能做输入</td>
</tr>
</tbody>
</table>
<h3 id="占位符">占位符</h3>
<p>%0 表示输入和输出列表合并的第 1 个操作数，%1 表示第 2 个，以此类推。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>asm</tag>
      </tags>
  </entry>
  <entry>
    <title>半同步-半反应堆线程池实现</title>
    <url>/20220516013947_39259/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREADPOOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;locker.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池类，定义为模板类是为了代码复用，模板参数T是任务类</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadpool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// thread_number是线程池中线程的数量， max_requests是请求队列中最多允许的 等待处理的请求的数量</span></span><br><span class="line">    <span class="built_in">threadpool</span>( <span class="type">int</span> thread_number = <span class="number">8</span>, <span class="type">int</span> max_requests = <span class="number">10000</span> );</span><br><span class="line">    ~<span class="built_in">threadpool</span>();</span><br><span class="line">    <span class="comment">// 向请求队列添加任务</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">append</span><span class="params">( T* request )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 工作线程运行的函数， 它不断从工作队列中取出任务执行之</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">worker</span><span class="params">( <span class="type">void</span>* arg )</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_thread_number; <span class="comment">// 线程池中线程数</span></span><br><span class="line">    <span class="type">int</span> m_max_requests;  <span class="comment">// 请求队列中允许的最大请求数量</span></span><br><span class="line">    <span class="type">pthread_t</span>* m_threads; <span class="comment">// 描述线程池的数组，其大小为m_thread_number</span></span><br><span class="line">    std::list&lt; T* &gt; m_workqueue; <span class="comment">// 请求队列</span></span><br><span class="line">    locker m_queuelocker; <span class="comment">// 保护请求队列的互斥锁</span></span><br><span class="line">    sem m_queuestat; <span class="comment">// 是否有任务要处理</span></span><br><span class="line">    <span class="type">bool</span> m_stop; <span class="comment">// 是否结束线程</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line">threadpool&lt; T &gt;::<span class="built_in">threadpool</span>( <span class="type">int</span> thread_number, <span class="type">int</span> max_requests ) : </span><br><span class="line">        <span class="built_in">m_thread_number</span>( thread_number ), <span class="built_in">m_max_requests</span>( max_requests ), <span class="built_in">m_stop</span>( <span class="literal">false</span> ), <span class="built_in">m_threads</span>( <span class="literal">NULL</span> )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( ( thread_number &lt;= <span class="number">0</span> ) || ( max_requests &lt;= <span class="number">0</span> ) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_threads = <span class="keyword">new</span> <span class="type">pthread_t</span>[ m_thread_number ];</span><br><span class="line">    <span class="keyword">if</span>( ! m_threads )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建thread_number个线程，并将它们设置为脱离线程</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; thread_number; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;create the %dth thread\n&quot;</span>, i );</span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">pthread_create</span>( m_threads + i, <span class="literal">NULL</span>, worker, <span class="keyword">this</span> ) != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> [] m_threads;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">pthread_detach</span>( m_threads[i] ) )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> [] m_threads;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line">threadpool&lt; T &gt;::~<span class="built_in">threadpool</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> [] m_threads;</span><br><span class="line">    m_stop = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line"><span class="type">bool</span> threadpool&lt; T &gt;::<span class="built_in">append</span>( T* request )</span><br><span class="line">&#123;</span><br><span class="line">    m_queuelocker.<span class="built_in">lock</span>(); <span class="comment">// 操作工作队列要加锁，因为他被所有线程共享</span></span><br><span class="line">    <span class="keyword">if</span> ( m_workqueue.<span class="built_in">size</span>() &gt; m_max_requests )</span><br><span class="line">    &#123;</span><br><span class="line">        m_queuelocker.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_workqueue.<span class="built_in">push_back</span>( request );</span><br><span class="line">    m_queuelocker.<span class="built_in">unlock</span>();</span><br><span class="line">    m_queuestat.<span class="built_in">post</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line"><span class="type">void</span>* threadpool&lt; T &gt;::<span class="built_in">worker</span>( <span class="type">void</span>* arg )</span><br><span class="line">&#123;</span><br><span class="line">    threadpool* pool = ( threadpool* )arg;</span><br><span class="line">    pool-&gt;<span class="built_in">run</span>();</span><br><span class="line">    <span class="keyword">return</span> pool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line"><span class="type">void</span> threadpool&lt; T &gt;::<span class="built_in">run</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> ( ! m_stop )</span><br><span class="line">    &#123;</span><br><span class="line">        m_queuestat.<span class="built_in">wait</span>();</span><br><span class="line">        m_queuelocker.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span> ( m_workqueue.<span class="built_in">empty</span>() )</span><br><span class="line">        &#123;</span><br><span class="line">            m_queuelocker.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        T* request = m_workqueue.<span class="built_in">front</span>();</span><br><span class="line">        m_workqueue.<span class="built_in">pop_front</span>();</span><br><span class="line">        m_queuelocker.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">if</span> ( ! request )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        request-&gt;<span class="built_in">process</span>(); <span class="comment">// 模板类需要实现这个接口</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>在c++中使用pthread_create时，第三个参数必须为静态函数。在静态函数中使用类的动态成员（包括成员函数和成员变量），只能通过两种方式实现：</p>
<ol>
<li>通过类的静态对象来调用。比如单例模式中，静态函数可以通过类的全局唯一实例来访问动态成员函数。</li>
<li>将类的对象作为参数传给该静态函数，在静态函数中引用这个对象，并调用动态方法。</li>
</ol>
<p>上面代码中向线程参数设置为this指针，在worker函数中获得该指针并调用动态方法run()。</p>
<hr>
<p>reference:<br>
linux高性能服务器编程——游双$P_{301}$</p>
]]></content>
      <categories>
        <category>concurrent-programming</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>回文串</title>
    <url>/20220910100549_28421/</url>
    <content><![CDATA[<h1>什么是回文串？</h1>
<p>回文串是如abcdedcba，abccba这样的字符串，从前往后和从后往前读是一样的结果。<br>
算法逻辑也很简单，从前和从后同时校验一个字符串，如果不相等直接返回失败。时间复杂度为 $O(n)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] != s[len - <span class="number">1</span> - i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>最长回文串问题</h1>
<blockquote>
<p>给你一个字符串 s，找到 s 中最长的回文子串。<br>
示例：<br>
输入：s = “babad”<br>
输出：“bab”<br>
解释：“aba” 同样是符合题意的答案。</p>
</blockquote>
<h2 id="暴力搜索">暴力搜索</h2>
<p>暴力搜索就是依次判断每个子串，如果是回文串就记录下他的长度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> maxlen = <span class="number">1</span>;</span><br><span class="line">    string res = s.<span class="built_in">substr</span>(<span class="number">0</span>, maxlen);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; i + j &lt;= len; j++) &#123; <span class="comment">// j是子串的长度，一种优化手段就是从 maxlen + 1 开始取</span></span><br><span class="line">            string sub = s.<span class="built_in">substr</span>(i, j);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(sub) &amp;&amp; j &gt; maxlen) &#123; <span class="comment">// 更新最长的回文串信息</span></span><br><span class="line">                res = sub;</span><br><span class="line">                maxlen = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历每个子串的时间复杂度是 $O(n^2)$，检验回文串时间复杂度为 $O(n)$，所以暴力求解的时间复杂度为 $O(n^3)$。</p>
<h2 id="中心扩散法">中心扩散法</h2>
<p>从每一个位置出发，向两边扩散即可，遇到不是回文串就结束。</p>
<blockquote>
<p>举例，s=acd<em><strong>b</strong></em>bdaa时，从s[2]=b开始扩散，是什么步骤呢？</p>
<ol>
<li>向左扩散，直到不和原字符相等。<br>
left = 2, right = 2, cur = 2, len = 1<br>
acd<em><strong>b</strong></em>bdaa</li>
<li>向右扩散，直到不和原字符相等。<br>
left = 2, right = 3, cur = 2, len = 2<br>
acd<em><strong>bb</strong></em>daa</li>
<li>同时向左右扩散，直到左右不相等。<br>
left = 1, right = 4, cur = 2, len = 4<br>
ac<em><strong>dbbd</strong></em>aa</li>
</ol>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line">    string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur &lt; len) &#123;</span><br><span class="line">        left = cur, right = cur;</span><br><span class="line">        <span class="keyword">while</span> (left &gt; <span class="number">0</span> &amp;&amp; s[left - <span class="number">1</span>] == s[cur]) &#123; <span class="comment">// 向左扩散</span></span><br><span class="line">            left--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; len - <span class="number">1</span> &amp;&amp; s[right + <span class="number">1</span>] == s[cur]) &#123; <span class="comment">// 向右扩散</span></span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left &gt; <span class="number">0</span> &amp;&amp; right &lt; len - <span class="number">1</span> &amp;&amp; s[left - <span class="number">1</span>] == s[right + <span class="number">1</span>]) &#123; <span class="comment">// 两边扩散</span></span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right - left + <span class="number">1</span> &gt; res.<span class="built_in">size</span>()) &#123; <span class="comment">// 更新结果</span></span><br><span class="line">            res = s.<span class="built_in">substr</span>(left, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cur++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法遍历中心点时间复杂度 $O(n)$，扩散的时间复杂度 $O(n)$，总时间复杂度 $O(n^2)$。</p>
<h2 id="动态规划">动态规划</h2>
<p>要判断 $dp[l][r]$ 是否是回文串，只需要知道 $dp[l+1][r-1]$ 是否是回文串就可以了。如果是的话，那么如果 $s[l] == s[r]$，那么就是回文串，否则不是。其中有一种特殊情况，在 $s[l] == s[r]$ 相等时，如果这俩相隔是 $2$， 也可以认为是回文串。<br>
初始化边界条件为所有都是 $false$ ，当 $l==r$ 时为 $true$（单个字符是回文串）。<br>
递推关系式为<br>
$$<br>
dp[l][r] = ((dp[l+1][r-1]\ \ || \ \ j - i &lt;= 2)\ \ &amp;&amp; \ \ s[l]==s[r])\ ?\ true : false<br>
$$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>)); <span class="comment">// 初始化为都不是</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">// 初始化边界</span></span><br><span class="line">        dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    string res = s.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 注意遍历顺序，倒着遍历是为了保证依赖的数据是经过计算的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i + <span class="number">1</span>][j - <span class="number">1</span>] || j - i &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; res.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    res = s.<span class="built_in">substr</span>(i, j - i + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式时间复杂度为 $O(n^2)$，空间复杂度也为 $O(n^2)$。</p>
<h2 id="Manacher算法">Manacher算法</h2>
<p>这种算法又被称为“马拉车”，可以用 $O(n)$的时间复杂度解决最长回文字符串问题。这个算法的总框架是，遍历所有的中心点，寻找每个中心点对应的最长回文子串，然后找到所有中心点对应的最长回文子串。但是在时间复杂度上做了优化，使其变成线性。</p>
<h3 id="臂长">臂长</h3>
<p>为了表述方便，我们定义一个新概念<strong>臂长</strong>，表示中心扩展算法向外扩展的长度。如果一个位置的最大回文字符串长度为 $2 * length + 1$，其臂长为 $length$。<br>
下面的讨论只涉及长度为奇数的回文字符串。长度为偶数的回文字符串可以在每个字符串之间添加用不到的字符从而达到长度变为 $2n + 1$ 为奇数的目的。<br>
<img src="/20220910100549_28421/1.png" alt="1"><br>
从中心扩展的长度即为臂长，$臂长 - 1$ 就是原子串的回文字符串长度。所以问题就变成了求臂长数组。</p>
<h3 id="求原字符串下标">求原字符串下标</h3>
<p>用 $(i - P[i]) / 2$，就是原字符串开头的下标了。例如 $P[6] = 5$，那么原字符串开头下标为 $(6 - 5) / 2 = 0$，所以返回的结果为原字符串的 $[0, 5 - 1]$ 即可。</p>
<h3 id="求每个-P-i">求每个 P[i]</h3>
<p>用 $C$ 表示回文串中心 $Centre$，用 $R$ 表示臂长右半部分下标边界，即 $R = C + P[i]$。$C$ 和 $R$ 对应当前循环中 $R$ 最靠右的回文串（手最长的，能管这个数组到最远的，之所以可以保证复杂度是因为保证 $R$ 不退缩）。<br>
<img src="/20220910100549_28421/2.png" alt="2"><br>
如图，在求 $P[i]$ 时，用 $i_mirror$ 表示要求的第 $i$ 个字符关于 $C$ 对应的下标。我们要求 $P[i]$，用中心扩展法就是向两边伸长。但是可以利用已经求出来的回文串中心 $C$ 的对称性，因为 $P[i_mirror] = 3$，那干脆让 $P[i] = 3$。有以下 $3$ 中情况会导致这个直接赋值不正确：</p>
<h4 id="1-超出了-R">1. 超出了 R</h4>
<p><img src="/20220910100549_28421/3.png" alt="3"><br>
当求 $P[i]$ 时，$P[i_mirror] = 7$，但是却不应该等于 $7$，因为从 $i$ 往后面数 $7$ 个已经等于 $22$ 了，然而 $R$ 才到 $20$，很显然还没有探索到那里。但是可以保证我们一定可以扩展到 $R$（因为对称），所以 $P[i]$ 至少可以为 $5$。剩下的只能中心扩展了。</p>
<h4 id="2-P-i-mirror-遇到了原字符串左边界">2. P[i_mirror] 遇到了原字符串左边界</h4>
<p><img src="/20220910100549_28421/4.png" alt="4"><br>
此时 $P[i_mirror] = 1$，但是 $P[i]$ 赋值成 $1$ 是不正确的，原因是 $P[i_mirror]$ 在扩展时首先是 $#=#$ ，之后遇到了边界才终止循环的，但是 $P[i]$ 并没有遇到边界，所以和上面一样继续中心扩展。</p>
<h4 id="3-i-R">3. i == R</h4>
<p>这个和情况一很像，将 $P[i] = 0$，之后中心扩展即可。</p>
<h3 id="C-和-R-的更新">C 和 R 的更新</h3>
<p>一步一步求 $P[i]$， 当求出的 $P[i]$ 的右边界大于当前 $R$ 时，就要更新 $C$ 和 $R$ 了。<br>
<img src="/20220910100549_28421/5.png" alt="5"><br>
此时 $P[i] = 3$，导致 $R_(new) = 10 + 3 = 13 &gt; 11$，那么 $C = 10, R = 13$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 预处理</span></span><br><span class="line">    string s1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        s1 += <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        s1 += s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    s1 += <span class="string">&quot;#&quot;</span>;</span><br><span class="line">    len = s1.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> R = <span class="number">0</span>;               <span class="comment">// 当前访问到的所有回文子串，所能触及的最右一个字符的位置</span></span><br><span class="line">    <span class="type">int</span> C = <span class="number">0</span>;               <span class="comment">// R对应的回文串的对称轴所在的位置</span></span><br><span class="line">    <span class="type">int</span> MaxP = <span class="number">0</span>;            <span class="comment">// 最大回文串的回文半径</span></span><br><span class="line">    <span class="type">int</span> MaxC = <span class="number">0</span>;            <span class="comment">// MaxP对应的回文串的对称轴所在的位置</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">P</span><span class="params">(len, <span class="number">0</span>)</span></span>;   <span class="comment">// P[i] 表示以第 i 个字符为对称轴的回文串的回文半径</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; R) &#123;  <span class="comment">// 1) 当i在R的左边</span></span><br><span class="line">            P[i] = <span class="built_in">min</span>(P[<span class="number">2</span> * C - i], R - i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 2) 当i在R的右边</span></span><br><span class="line">            P[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 尝试扩展 P[i]，注意处理边界</span></span><br><span class="line">        <span class="keyword">while</span> (i - P[i] &gt;= <span class="number">0</span> &amp;&amp; <span class="comment">// 可以把 P[i] 理解为左半径,即回文串的起始位不能小于 0</span></span><br><span class="line">               i + P[i] &lt; len &amp;&amp; <span class="comment">// 同上,即回文串的结束位不能大于总长</span></span><br><span class="line">               s1[i - P[i]] == s1[i + P[i]]) &#123;  <span class="comment">// 回文串特性，左右扩展，判断字符串是否相同</span></span><br><span class="line">            P[i] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新 R, C</span></span><br><span class="line">        <span class="keyword">if</span> (P[i] + i - <span class="number">1</span> &gt; R) &#123;</span><br><span class="line">            R = P[i] + i - <span class="number">1</span>;</span><br><span class="line">            C = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新 MaxP, MaxC</span></span><br><span class="line">        <span class="keyword">if</span> (MaxP &lt;= P[i]) &#123;</span><br><span class="line">            MaxP = P[i];</span><br><span class="line">            MaxC = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">substr</span>((MaxC - MaxP + <span class="number">1</span>) / <span class="number">2</span>, MaxP - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>基于共享内存的聊天室服务程序</title>
    <url>/20220317211553_61371/</url>
    <content><![CDATA[<p>服务器代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USER_LIMIT 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FD_LIMIT 65535</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EVENT_NUMBER 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESS_LIMIT 65536</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">client_data</span> &#123;</span><br><span class="line">    sockaddr_in address; <span class="comment">// 客户端ip地址</span></span><br><span class="line">    <span class="type">int</span> connfd;         <span class="comment">// socket文件描述符</span></span><br><span class="line">    <span class="type">pid_t</span> pid;         <span class="comment">//  处理这个连接的子进程pid</span></span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];      <span class="comment">// 和父进程通信用的管道</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* shm_name = <span class="string">&quot;/my_shm&quot;</span>;</span><br><span class="line"><span class="type">int</span> sig_pipefd[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> epollfd;</span><br><span class="line"><span class="type">int</span> listenfd;</span><br><span class="line"><span class="type">int</span> shmfd;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* share_mem = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">client_data* users = <span class="number">0</span>; <span class="comment">// 客户连接数组，进程用客户连接的编号来索引这个数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* sub_process = <span class="number">0</span>; <span class="comment">// 子进程和客户连接的映射关系表。用进程的pid来索引这个数组，即可取得该进程 所处理的客户连接 的编号</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> user_count = <span class="number">0</span>; <span class="comment">// 当前客户数量</span></span><br><span class="line"><span class="type">bool</span> stop_child = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="type">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> old_option = <span class="built_in">fcntl</span>(fd, F_GETFL);</span><br><span class="line">    <span class="type">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">    <span class="built_in">fcntl</span>(fd, F_SETFL, new_option);</span><br><span class="line">    <span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addfd</span><span class="params">(<span class="type">int</span> epollfd, <span class="type">int</span> fd)</span> </span>&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.events = EPOLLIN | EPOLLET;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">    <span class="built_in">setnonblocking</span>(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sig_handler</span><span class="params">(<span class="type">int</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> save_errno = errno;</span><br><span class="line">    <span class="type">int</span> msg = sig;</span><br><span class="line">    <span class="built_in">send</span>(sig_pipefd[<span class="number">1</span>], (<span class="type">char</span>*)&amp;msg, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    errno = save_errno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addsig</span><span class="params">(<span class="type">int</span> sig, <span class="type">void</span>(*handler)(<span class="type">int</span>), <span class="type">bool</span> restart = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> sa;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;sa, <span class="string">&#x27;\0&#x27;</span>, <span class="built_in">sizeof</span>(sa));</span><br><span class="line">    sa.sa_handler = handler;</span><br><span class="line">    <span class="keyword">if</span> (restart) &#123;</span><br><span class="line">        sa.sa_flags |= SA_RESTART;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sigfillset</span>(&amp;sa.sa_mask);</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">sigaction</span>(sig, &amp;sa, <span class="literal">NULL</span>) != <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del_resource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">close</span>(sig_pipefd[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">close</span>(sig_pipefd[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">close</span>(listenfd);</span><br><span class="line">    <span class="built_in">close</span>(epollfd);</span><br><span class="line">    <span class="built_in">shm_unlink</span>(shm_name);</span><br><span class="line">    <span class="keyword">delete</span>[] users;</span><br><span class="line">    <span class="keyword">delete</span>[] sub_process;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">child_term_handler</span><span class="params">(<span class="type">int</span> sig)</span> </span>&#123; <span class="comment">// 停止一个子进程</span></span><br><span class="line">    stop_child = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子进程运行的函数。参数idx指出该子进程处理的客户连接的编号，users是保存所有客户连接数据的数组。参数share_mem指出共享内存的起始地址</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">run_child</span><span class="params">(<span class="type">int</span> idx, client_data* users, <span class="type">char</span>* share_mem)</span> </span>&#123;</span><br><span class="line">    epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line">    <span class="comment">// 子进程用io复用技术来同时监听两个文件描述符： 客户连接socket和与父进程的管道文件描述符</span></span><br><span class="line">    <span class="type">int</span> child_epollfd = <span class="built_in">epoll_create</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">assert</span>(child_epollfd != <span class="number">-1</span>);</span><br><span class="line">    <span class="type">int</span> connfd = users[idx].connfd; <span class="comment">// 客户端socket</span></span><br><span class="line">    <span class="built_in">addfd</span>(child_epollfd, connfd);</span><br><span class="line">    <span class="type">int</span> pipefd = users[idx].pipefd[<span class="number">1</span>]; <span class="comment">// 父进程管道文件描述符</span></span><br><span class="line">    <span class="built_in">addfd</span>(child_epollfd, pipefd);</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">// 子进程设置自己的信号处理函数</span></span><br><span class="line">    <span class="built_in">addsig</span>(SIGTERM, child_term_handler, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stop_child) &#123;</span><br><span class="line">        <span class="type">int</span> number = <span class="built_in">epoll_wait</span>(child_epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> ((number &lt; <span class="number">0</span>) &amp;&amp; (errno != EINTR)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line">            <span class="type">int</span> sockfd = events[i].data.fd;</span><br><span class="line">            <span class="comment">// 本子进程负责的客户连接有数据到达</span></span><br><span class="line">            <span class="keyword">if</span> ((sockfd == connfd) &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123;</span><br><span class="line">                <span class="built_in">memset</span>(share_mem + idx * BUFFER_SIZE, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE);</span><br><span class="line">                <span class="comment">// 将客户数据读取到对应 读缓存 中。 读缓存是共享内存的一段，开始于 idx*BUFFER_SIZE处，长度为BUFFER_SIZE字节。因此，各个客户连接的</span></span><br><span class="line">                <span class="comment">// 读缓存是共享的</span></span><br><span class="line">                ret = <span class="built_in">recv</span>(connfd, share_mem + idx * BUFFER_SIZE, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">                        stop_child = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">                    stop_child = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 成功读取客户数据后就通知主进程（通过管道）来处理</span></span><br><span class="line">                    <span class="built_in">send</span>(pipefd, (<span class="type">char</span>*)&amp;idx, <span class="built_in">sizeof</span>(idx), <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 主进程通知本进程（通过管道）将第client个客户的数据发送到本进程负责处理的客户端</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((sockfd == pipefd) &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123;</span><br><span class="line">                <span class="type">int</span> client = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 接收主进程发送来的数据，即 有客户数据到达的连接 的编号。</span></span><br><span class="line">                ret = <span class="built_in">recv</span>(sockfd, (<span class="type">char</span>*)&amp;client, <span class="built_in">sizeof</span>(client), <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">                        stop_child = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">                    stop_child = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">send</span>(connfd, share_mem + client * BUFFER_SIZE, BUFFER_SIZE, <span class="number">0</span>); <span class="comment">// 通知这个子进程负责的connfd，有个编号为client的客户端发消息了，把这段消息发给connfd</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(connfd);</span><br><span class="line">    <span class="built_in">close</span>(pipefd);</span><br><span class="line">    <span class="built_in">close</span>(child_epollfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="built_in">basename</span>(argv[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = <span class="built_in">atoi</span>(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;address, <span class="built_in">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line"></span><br><span class="line">    listenfd = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert</span>(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">bind</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="built_in">sizeof</span>(address));</span><br><span class="line">    <span class="built_in">assert</span>(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">listen</span>(listenfd, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">assert</span>(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    user_count = <span class="number">0</span>;</span><br><span class="line">    users = <span class="keyword">new</span> client_data[USER_LIMIT + <span class="number">1</span>];</span><br><span class="line">    sub_process = <span class="keyword">new</span> <span class="type">int</span>[PROCESS_LIMIT];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PROCESS_LIMIT; ++i) &#123;</span><br><span class="line">        sub_process[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line">    epollfd = <span class="built_in">epoll_create</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">assert</span>(epollfd != <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">addfd</span>(epollfd, listenfd);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">socketpair</span>(PF_UNIX, SOCK_STREAM, <span class="number">0</span>, sig_pipefd);</span><br><span class="line">    <span class="built_in">assert</span>(ret != <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">setnonblocking</span>(sig_pipefd[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">addfd</span>(epollfd, sig_pipefd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">addsig</span>(SIGCHLD, sig_handler);</span><br><span class="line">    <span class="built_in">addsig</span>(SIGTERM, sig_handler);</span><br><span class="line">    <span class="built_in">addsig</span>(SIGINT, sig_handler);</span><br><span class="line">    <span class="built_in">addsig</span>(SIGPIPE, SIG_IGN);</span><br><span class="line">    <span class="type">bool</span> stop_server = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> terminate = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建共享内存，作为所有客户socket连接的读缓存</span></span><br><span class="line">    shmfd = <span class="built_in">shm_open</span>(shm_name, O_CREAT | O_RDWR, <span class="number">0666</span>);</span><br><span class="line">    <span class="built_in">assert</span>(shmfd != <span class="number">-1</span>);</span><br><span class="line">    ret = <span class="built_in">ftruncate</span>(shmfd, USER_LIMIT * BUFFER_SIZE);</span><br><span class="line">    <span class="built_in">assert</span>(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    share_mem = (<span class="type">char</span>*)<span class="built_in">mmap</span>(<span class="literal">NULL</span>, USER_LIMIT * BUFFER_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, shmfd, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert</span>(share_mem != MAP_FAILED);</span><br><span class="line">    <span class="built_in">close</span>(shmfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stop_server) &#123;</span><br><span class="line">        <span class="type">int</span> number = <span class="built_in">epoll_wait</span>(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> ((number &lt; <span class="number">0</span>) &amp;&amp; (errno != EINTR)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line">            <span class="type">int</span> sockfd = events[i].data.fd;</span><br><span class="line">            <span class="comment">// 新的客户连接到来</span></span><br><span class="line">            <span class="keyword">if</span> (sockfd == listenfd) &#123;</span><br><span class="line">                <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_address;</span><br><span class="line">                <span class="type">socklen_t</span> client_addrlength = <span class="built_in">sizeof</span>(client_address);</span><br><span class="line">                <span class="type">int</span> connfd = <span class="built_in">accept</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;client_address, &amp;client_addrlength);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (connfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;errno is: %d\n&quot;</span>, errno);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (user_count &gt;= USER_LIMIT) &#123;</span><br><span class="line">                    <span class="type">const</span> <span class="type">char</span>* info = <span class="string">&quot;too many users\n&quot;</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, info);</span><br><span class="line">                    <span class="built_in">send</span>(connfd, info, <span class="built_in">strlen</span>(info), <span class="number">0</span>);</span><br><span class="line">                    <span class="built_in">close</span>(connfd);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 保存第user_counter个客户连接的相关数据</span></span><br><span class="line">                users[user_count].address = client_address;</span><br><span class="line">                users[user_count].connfd = connfd;</span><br><span class="line">                <span class="comment">// 在主进程和子进程间建立管道，以传递必要数据</span></span><br><span class="line">                ret = <span class="built_in">socketpair</span>(PF_UNIX, SOCK_STREAM, <span class="number">0</span>, users[user_count].pipefd);</span><br><span class="line">                <span class="built_in">assert</span>(ret != <span class="number">-1</span>);</span><br><span class="line">                <span class="type">pid_t</span> pid = fork();</span><br><span class="line">                <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">close</span>(connfd);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">// 子进程</span></span><br><span class="line">                    <span class="built_in">close</span>(epollfd);</span><br><span class="line">                    <span class="built_in">close</span>(listenfd);</span><br><span class="line">                    <span class="built_in">close</span>(users[user_count].pipefd[<span class="number">0</span>]);</span><br><span class="line">                    <span class="built_in">close</span>(sig_pipefd[<span class="number">0</span>]);</span><br><span class="line">                    <span class="built_in">close</span>(sig_pipefd[<span class="number">1</span>]);</span><br><span class="line">                    <span class="built_in">run_child</span>(user_count, users, share_mem);</span><br><span class="line">                    <span class="built_in">munmap</span>((<span class="type">void</span>*)share_mem, USER_LIMIT * BUFFER_SIZE);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 父进程</span></span><br><span class="line">                    <span class="built_in">close</span>(connfd);</span><br><span class="line">                    <span class="built_in">close</span>(users[user_count].pipefd[<span class="number">1</span>]);</span><br><span class="line">                    <span class="built_in">addfd</span>(epollfd, users[user_count].pipefd[<span class="number">0</span>]); <span class="comment">// 监听子进程的管道</span></span><br><span class="line">                    users[user_count].pid = pid;</span><br><span class="line">                    <span class="comment">// 记录新的客户连接在数组users中的索引值，建立进程pid和该索引值之间的映射关系</span></span><br><span class="line">                    sub_process[pid] = user_count;</span><br><span class="line">                    user_count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((sockfd == sig_pipefd[<span class="number">0</span>]) &amp;&amp; events[i].events &amp; EPOLLIN) &#123; <span class="comment">// 处理信号事件</span></span><br><span class="line">                <span class="type">int</span> sig;</span><br><span class="line">                <span class="type">char</span> signals[<span class="number">1024</span>];</span><br><span class="line">                ret = <span class="built_in">recv</span>(sig_pipefd[<span class="number">0</span>], signals, <span class="built_in">sizeof</span>(signals), <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ret; ++i) &#123;</span><br><span class="line">                        <span class="keyword">switch</span>(signals[i]) &#123;</span><br><span class="line">                            <span class="keyword">case</span> SIGCHLD: &#123; <span class="comment">// 子进程推出，表示有某个客户端关闭了连接</span></span><br><span class="line">                                <span class="type">pid_t</span> pid;</span><br><span class="line">                                <span class="type">int</span> stat;</span><br><span class="line">                                <span class="keyword">while</span> ((pid = <span class="built_in">waitpid</span>(<span class="number">-1</span>, &amp;stat, WNOHANG)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                    <span class="comment">// 用子进程的pid取得被关闭的客户连接的编号</span></span><br><span class="line">                                    <span class="type">int</span> del_user = sub_process[pid];</span><br><span class="line">                                    sub_process[pid] = <span class="number">-1</span>;</span><br><span class="line">                                    <span class="keyword">if</span> ((del_user &lt; <span class="number">0</span>) || (del_user &gt; USER_LIMIT)) &#123;</span><br><span class="line">                                        <span class="keyword">continue</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    <span class="comment">// 清除第del_user个客户连接使用的相关数据</span></span><br><span class="line">                                    <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_DEL, users[del_user].pipefd[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">                                    <span class="built_in">close</span>(users[del_user].pipefd[<span class="number">0</span>]);</span><br><span class="line">                                    users[del_user] = users[--user_count];</span><br><span class="line">                                    sub_process[users[del_user].pid] = del_user;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (terminate &amp;&amp; user_count == <span class="number">0</span>) &#123;</span><br><span class="line">                                    stop_server = <span class="literal">true</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">case</span> SIGTERM:</span><br><span class="line">                            <span class="keyword">case</span> SIGINT: &#123; <span class="comment">// 结束服务器程序</span></span><br><span class="line">                                <span class="built_in">printf</span>(<span class="string">&quot;kill all the child now\n&quot;</span>);</span><br><span class="line">                                <span class="keyword">if</span> (user_count == <span class="number">0</span>) &#123;</span><br><span class="line">                                    stop_server = <span class="literal">true</span>;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; user_count; ++i) &#123;</span><br><span class="line">                                    <span class="type">int</span> pid = users[i].pid;</span><br><span class="line">                                    <span class="built_in">kill</span>(pid, SIGTERM);</span><br><span class="line">                                &#125;</span><br><span class="line">                                terminate = <span class="literal">true</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">default</span>: &#123;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123; <span class="comment">// 某个子进程向父进程写入了数据</span></span><br><span class="line">                <span class="type">int</span> child = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 读取管道数据，child变量记录了是哪个客户连接有数据到达</span></span><br><span class="line">                ret = <span class="built_in">recv</span>(sockfd, (<span class="type">char</span>*)&amp;child, <span class="built_in">sizeof</span>(child), <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;read data from child accross pipe\n&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 向除负责处理第child个客户连接的子进程之外的其他子进程发送消息，通知他们有客户数据要写</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; user_count; ++j) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (users[j].pipefd[<span class="number">0</span>] != sockfd) &#123;</span><br><span class="line">                            <span class="built_in">printf</span>(<span class="string">&quot;send data to child accross pipe\n&quot;</span>);</span><br><span class="line">                            <span class="built_in">send</span>(users[j].pipefd[<span class="number">0</span>], (<span class="type">char</span>*)&amp;child, <span class="built_in">sizeof</span>(child), <span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">del_resource</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>server:<br>
<img src="/20220317211553_61371/1.png" alt="在这里插入图片描述"></p>
<hr>
<p>client 1:<br>
<img src="/20220317211553_61371/2.png" alt="在这里插入图片描述"></p>
<hr>
<p>client 2:<br>
<img src="/20220317211553_61371/3.png" alt="在这里插入图片描述"></p>
<hr>
<p>先让服务器监听4444端口，之后客户端1连接，客户端2连接。客户端1发送11111，发现客户端1和2都能收到。客户端2发送2222，发现客户端1和2都能收到。</p>
<hr>
<p>reference: linux高性能服务器编程——游双$P_{255}$</p>
]]></content>
      <categories>
        <category>socket-programming</category>
        <category>concurrent-programming</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>socket</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>基于升序链表的定时器</title>
    <url>/20220303204239_59743/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LST_TIMER</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LST_TIMER</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 64</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">util_timer</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">client_data</span> &#123;</span><br><span class="line">    sockaddr_in address;</span><br><span class="line">    <span class="type">int</span> sockfd;</span><br><span class="line">    <span class="type">char</span> buf[BUFFER_SIZE];</span><br><span class="line">    util_timer* timer;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">util_timer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">util_timer</span>() : <span class="built_in">prev</span>(<span class="literal">NULL</span>), <span class="built_in">next</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">    <span class="type">time_t</span> expire;</span><br><span class="line">    <span class="built_in">void</span> (*cb_func)(client_data*);</span><br><span class="line">    client_data* user_data;</span><br><span class="line">    util_timer* prev;</span><br><span class="line">    util_timer* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sort_timer_lst</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">sort_timer_lst</span>() : <span class="built_in">head</span>(<span class="literal">NULL</span>), <span class="built_in">tail</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">sort_timer_lst</span>() &#123;</span><br><span class="line">        util_timer* tmp = head;</span><br><span class="line">        <span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">            head = tmp-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> tmp;</span><br><span class="line">            tmp = head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_timer</span><span class="params">(util_timer* timer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">            head = tail = timer;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timer-&gt;expire &lt; head-&gt;expire) &#123;</span><br><span class="line">            timer-&gt;next = head;</span><br><span class="line">            head-&gt;prev = timer;</span><br><span class="line">            head = timer;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">add_timer</span>(timer, head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">adjust_timer</span><span class="params">(util_timer* timer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        util_timer* tmp = timer-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (!tmp || (timer-&gt;expire &lt; tmp-&gt;expire)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (timer == head) &#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            head-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">            timer-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">add_timer</span>(timer, head);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            timer-&gt;prev-&gt;next = timer-&gt;next;</span><br><span class="line">            timer-&gt;next-&gt;prev = timer-&gt;prev;</span><br><span class="line">            <span class="built_in">add_timer</span>(timer, timer-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">del_timer</span><span class="params">(util_timer* timer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((timer == head) &amp;&amp; (timer == tail)) &#123;</span><br><span class="line">            <span class="keyword">delete</span> timer;</span><br><span class="line">            head = <span class="literal">NULL</span>;</span><br><span class="line">            tail = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timer == head) &#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            head-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">delete</span> timer;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timer == tail) &#123;</span><br><span class="line">            tail = tail-&gt;prev;</span><br><span class="line">            tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">delete</span> timer;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        timer-&gt;prev-&gt;next = timer-&gt;next;</span><br><span class="line">        timer-&gt;next-&gt;prev = timer-&gt;prev;</span><br><span class="line">        <span class="keyword">delete</span> timer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">tick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;timer tick\n&quot;</span>);</span><br><span class="line">        <span class="type">time_t</span> cur = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">        util_timer* tmp = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur &lt; tmp-&gt;expire) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp-&gt;<span class="built_in">cb_func</span>(tmp-&gt;user_data);</span><br><span class="line">            head = tmp-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (head) &#123;</span><br><span class="line">                head-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span> tmp;</span><br><span class="line">            tmp = head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_timer</span><span class="params">(util_timer* timer, util_timer* lst_head)</span> </span>&#123;</span><br><span class="line">        util_timer* prev = lst_head;</span><br><span class="line">        util_timer* tmp = prev-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timer-&gt;expire &lt; tmp-&gt;expire) &#123;</span><br><span class="line">                prev-&gt;next = timer;</span><br><span class="line">                timer-&gt;next = tmp;</span><br><span class="line">                tmp-&gt;prev = timer;</span><br><span class="line">                timer-&gt;prev = prev;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = tmp;</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!tmp) &#123;</span><br><span class="line">            prev-&gt;next = timer;</span><br><span class="line">            timer-&gt;prev = prev;</span><br><span class="line">            timer-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            tail = timer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    util_timer* head;</span><br><span class="line">    util_timer* tail;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LST_TIMER end */</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>此文件被包含在头文件中以便方便使用。tick为心跳函数，每隔一段时间执行一次。判断任务到期为定时器expire参数小于当前系统时间。<br>
执行时间复杂度：<br>
添加$O(n)$,删除$O(1)$，执行任务$O(1)$</p>
<hr>
<p>reference:<br>
Linux高性能服务器编程——游双</p>
]]></content>
      <categories>
        <category>socket-programming</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>基于时间堆的定时器</title>
    <url>/20220310205117_35219/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MIN_HEAP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_HEAP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::exception;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">heap_timer</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">client_data</span> &#123;</span><br><span class="line">    sockaddr_in address;</span><br><span class="line">    <span class="type">int</span> sockfd;</span><br><span class="line">    <span class="type">char</span> buf[BUFFER_SIZE];</span><br><span class="line">    heap_timer* timer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">heap_timer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">heap_timer</span>(<span class="type">int</span> delay) &#123;</span><br><span class="line">            expire = <span class="built_in">timer</span>(<span class="literal">NULL</span>) + delay;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">time_t</span> expire;</span><br><span class="line">        <span class="built_in">void</span> (*cb_func)(client_data*);</span><br><span class="line">        client_data* user_data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">time_heap</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">time_heap</span>(<span class="type">int</span> cap) <span class="keyword">throw</span> (std::exception) : <span class="built_in">capacity</span>(cap), <span class="built_in">cur_size</span>(<span class="number">0</span>) &#123;</span><br><span class="line">            array = <span class="keyword">new</span> heap_timer* [capacity];</span><br><span class="line">            <span class="keyword">if</span> (!array) &#123;</span><br><span class="line">                <span class="keyword">throw</span> std:<span class="built_in">exception</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; capacity; ++i) &#123;</span><br><span class="line">                array[i] = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">time_heap</span>(heap_timer** init_array, <span class="type">int</span> size, <span class="type">int</span> capacity) <span class="keyword">throw</span> (std::exception) : <span class="built_in">cur_size</span>(size), <span class="built_in">capacity</span>(capacity) &#123;</span><br><span class="line">            <span class="keyword">if</span> (capacity &lt; size) &#123;</span><br><span class="line">                <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            array = <span class="keyword">new</span> heap_timer* [capacity];</span><br><span class="line">            <span class="keyword">if</span> (!array) &#123;</span><br><span class="line">                <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; capacity; ++i) &#123;</span><br><span class="line">                array[i] = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (size != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">                    array[i] = init_array[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = (cur_size - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                    <span class="built_in">percolate_down</span>(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~<span class="built_in">time_heap</span>() &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cur_size; ++i) &#123;</span><br><span class="line">                <span class="keyword">delete</span> array[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span>[] array;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">add_timer</span><span class="params">(heap_timer* timer)</span> <span class="title">throw</span> <span class="params">(std::exception)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur_size &gt;= capacity) &#123;</span><br><span class="line">                <span class="built_in">resize</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> hole = cur_size++;</span><br><span class="line">            <span class="type">int</span> parent = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; hole &gt; <span class="number">0</span>; hole = parent) &#123; <span class="comment">// 上滤</span></span><br><span class="line">                parent = (hole - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (array[parent]-&gt;expire &lt;= timer-&gt;expire) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                array[hole] = array[parent];</span><br><span class="line">            &#125;</span><br><span class="line">            array[hole] = timer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">del_timer</span><span class="params">(heap_timer* timer)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            timer-&gt;cb_func = <span class="literal">NULL</span>; <span class="comment">// 所谓的延迟销毁，节省真正删除该定时器造成的开销，缺点是容易使数组膨胀</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">heap_timer* <span class="title">top</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">pop_timer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (array[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="keyword">delete</span> array[<span class="number">0</span>];</span><br><span class="line">                array[<span class="number">0</span>] = array[--cur_size];</span><br><span class="line">                <span class="built_in">percolate_down</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">tick</span><span class="params">()</span> </span>&#123; <span class="comment">// 把所有到期的事件都处理掉</span></span><br><span class="line">            heap_timer* tmp = array[<span class="number">0</span>];</span><br><span class="line">            <span class="type">time_t</span> cur = <span class="built_in">timer</span>(<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">while</span> (!<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!tmp) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (tmp-&gt;expire &gt; cur) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (array[<span class="number">0</span>]-&gt;cb_func) &#123;</span><br><span class="line">                    array[<span class="number">0</span>]-&gt;<span class="built_in">cb_func</span>(array[<span class="number">0</span>]-&gt;user_data);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">pop_timer</span>();</span><br><span class="line">                tmp = array[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cur_size == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">percolate_down</span><span class="params">(<span class="type">int</span> hole)</span> </span>&#123;</span><br><span class="line">            heap_timer* temp = array[hole];</span><br><span class="line">            <span class="type">int</span> child = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; ((hole * <span class="number">2</span> + <span class="number">1</span>) &lt;= (cur_size - <span class="number">1</span>)); hole = child) &#123;</span><br><span class="line">                child = hole * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> ((child &lt; (cur_size - <span class="number">1</span>)) &amp;&amp; (array[child + <span class="number">1</span>]-&gt;expire &lt; array[child]-&gt;expire)) &#123; <span class="comment">// 右孩子比左孩子小，换右孩子</span></span><br><span class="line">                    ++child;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (array[child]-&gt;expire &lt; temp-&gt;expire) &#123; <span class="comment">// 交换操作</span></span><br><span class="line">                    array[hole] = array[child];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            array[hole] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">()</span> <span class="title">throw</span> <span class="params">(std::exception)</span> </span>&#123;</span><br><span class="line">            heap_timer** temp = <span class="keyword">new</span> heap_timer* [<span class="number">2</span> * capacity];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * capacity; ++i) &#123;</span><br><span class="line">                temp[i] = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!temp) &#123;</span><br><span class="line">                <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            capacity = <span class="number">2</span> * capacity;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cur_size; ++i) &#123;</span><br><span class="line">                temp[i] = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span>[] array;</span><br><span class="line">            array = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        heap_timer** array;</span><br><span class="line">        <span class="type">int</span> capacity;</span><br><span class="line">        <span class="type">int</span> cur_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>堆是一种高效的数据结构，不熟悉堆的同学先学习下堆。<br>
<img src="/20220310205117_35219/1.png" alt="在这里插入图片描述"><br>
<img src="/20220310205117_35219/2.png" alt="在这里插入图片描述"><br>
<img src="/20220310205117_35219/3.png" alt="在这里插入图片描述"><br>
上图来自Linux高性能服务器编程——游双$P_{211}$</p>
<p>添加一个定时器的时间复杂度为$O(log_2n)$，删除定时器复杂度为$O(1)$，执行一个定时器时间复杂度为$O(1)$。</p>
<hr>
<p>reference：Linux高性能服务器编程——游双</p>
]]></content>
      <categories>
        <category>socket-programming</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>基于时间轮的定时器</title>
    <url>/20220308204810_47395/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TIME_WHEEL_TIMER</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_WHEEL_TIMER</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 64</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tw_timer</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">client_data</span> &#123;</span><br><span class="line">    sockaddr_in address;</span><br><span class="line">    <span class="type">int</span> sockfd;</span><br><span class="line">    <span class="type">char</span> buf[BUFFER_SIZE];</span><br><span class="line">    tw_timer* timer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tw_timer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">tw_timer</span>(<span class="type">int</span> rot, <span class="type">int</span> ts) : <span class="built_in">next</span>(<span class="literal">NULL</span>), <span class="built_in">prev</span>(<span class="literal">NULL</span>), <span class="built_in">rotation</span>(rot), <span class="built_in">time_slot</span>(ts) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> rotation; </span><br><span class="line">        <span class="type">int</span> time_slot;</span><br><span class="line">        <span class="built_in">void</span> (*cb_func)(client_data*);</span><br><span class="line">        client_data* user_data;</span><br><span class="line">        tw_timer* next;</span><br><span class="line">        tw_timer* prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">time_wheel</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">time_wheel</span>() : <span class="built_in">cur_slot</span>(<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">                slots[i] = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">time_wheel</span>() &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">                <span class="keyword">while</span>(tmp) &#123;</span><br><span class="line">                    slots[i] = tmp-&gt;next;</span><br><span class="line">                    <span class="keyword">delete</span> tmp;</span><br><span class="line">                    tmp = slots[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">tw_timer* <span class="title">add_timer</span><span class="params">(<span class="type">int</span> timeout)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> ticks = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 根据待插入定时器的超时值计算他在时间轮转动多少滴答后触发，并将该滴答数存储变量tics中。若待插入定时器超时值小于槽间隔SI，将tics向上折合为1.否则向下折合为timeout/SI</span></span><br><span class="line">            <span class="keyword">if</span> (timeout &lt; SI) &#123;</span><br><span class="line">                ticks = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ticks = timeout / SI;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> rotation = ticks / N; <span class="comment">// 计算待插入的定时器转动多少圈后触发</span></span><br><span class="line">            <span class="type">int</span> ts = (cur_slot + (ticks % N)) % N; <span class="comment">// 定时器应该被插入哪个槽</span></span><br><span class="line">            tw_timer* timer = <span class="keyword">new</span> <span class="built_in">tw_timer</span>(rotation, ts);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!slots[ts]) &#123; <span class="comment">// 没有定时器，把新建的定时器插入，并设置为头节点</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;add timer, rotation is %d, ts is %d, cur_slot is %d\n&quot;</span>, rotation, ts, cur_slot);</span><br><span class="line">                slots[ts] = timer;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 将定时器插入第ts个槽中</span></span><br><span class="line">                timer-&gt;next = slots[ts];</span><br><span class="line">                slots[ts]-&gt;prev = timer;</span><br><span class="line">                slots[ts] = timer;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> timer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">del_timer</span><span class="params">(tw_timer* timer)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> ts = timer-&gt;time_slot;</span><br><span class="line">            <span class="keyword">if</span> (timer == slots[ts]) &#123; <span class="comment">// 是头节点</span></span><br><span class="line">                slots[ts] = slots[ts]-&gt;next;</span><br><span class="line">                <span class="keyword">if</span> (slots[ts]) &#123;</span><br><span class="line">                    slots[ts]-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">delete</span> timer;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                timer-&gt;prev-&gt;next = timer-&gt;next;</span><br><span class="line">                <span class="keyword">if</span> (timer-&gt;next) &#123;</span><br><span class="line">                    timer-&gt;next-&gt;prev = timer-&gt;prev;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">delete</span> timer;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">tick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            tw_timer* tmp = slots[cur_slot];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;current slot is %d\n&quot;</span>, cur_slot);</span><br><span class="line">            <span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;tick the timer once\n&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (tmp-&gt;rotation &gt; <span class="number">0</span>) &#123; <span class="comment">// ratation大于0，这一轮不起作用</span></span><br><span class="line">                    tmp-&gt;rotation--;</span><br><span class="line">                    tmp = tmp-&gt;next;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 到期了，执行定时任务并且删除定时器</span></span><br><span class="line">                    tmp-&gt;<span class="built_in">cb_func</span>(tmp-&gt;user_data);</span><br><span class="line">                    <span class="keyword">if</span> (tmp == slots[cur_slot]) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;delete header in cur_slot\n&quot;</span>);</span><br><span class="line">                        slots[cur_slot] = tmp-&gt;next;</span><br><span class="line">                        <span class="keyword">delete</span> tmp;</span><br><span class="line">                        <span class="keyword">if</span> (slots[cur_slot]) &#123;</span><br><span class="line">                            slots[cur_slot]-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        tmp = slots[cur_slot];</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        tmp-&gt;prev-&gt;next = tmp-&gt;next;</span><br><span class="line">                        <span class="keyword">if</span> (tmp-&gt;next) &#123;</span><br><span class="line">                            tmp-&gt;next-&gt;prev = tmp-&gt;prev;</span><br><span class="line">                        &#125;</span><br><span class="line">                        tw_timer* tmp2 = tmp-&gt;next;</span><br><span class="line">                        <span class="keyword">delete</span> tmp;</span><br><span class="line">                        tmp = tmp2;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cur_slot = ++cur_slot % N;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> N = <span class="number">60</span>; <span class="comment">// 时间轮上槽的数目</span></span><br><span class="line">        <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> SI = <span class="number">1</span>; <span class="comment">// 每1s时间轮转动一次，槽间隔为1s</span></span><br><span class="line">        tw_timer* slots[N]; <span class="comment">// 每个元素指向一个定时器链表，无序</span></span><br><span class="line">        <span class="type">int</span> cur_slot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>结构如图所示：  <img src="/20220308204810_47395/1.png" alt="在这里插入图片描述"><br>
图片来自高性能服务器编程——游双<br>
$time\ slot = (current\ slot + (time\ interval / slot\ interval)) \ %\  N$<br>
其中，$time\ slot$为需要添加到的时间槽，$current\ slot$为现在时间轮所处的时间槽，$time\ interval$为从现在开始计时，需要多久触发执行任务的时间，$slot\ interval$为每个时间槽所代表的时间。$N$为时间槽总数。<br>
想要提高定时精度，使$slot\ interval$值变小。提高执行效率，增大$N$。</p>
<p>添加定时器时间复杂度$O(1)$，执行定时器时间复杂度$O(N)$，实际上效率比$O(N)$快，因为不同定时器被散列到不同的链表上了。当用多个时间轮时，该时间复杂度近似为$O(1)$。</p>
<hr>
<p>reference：高性能linux服务器编程——游双</p>
]]></content>
      <categories>
        <category>socket-programming</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>处理非活动连接</title>
    <url>/20220307204428_2297/</url>
    <content><![CDATA[<p>其中依赖的lst_timer.h见<a href="/20220303204239_59743/" title="基于升序链表的定时器">上篇文章</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lst_timer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FD_LIMIT 65535</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EVENT_NUMBER 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMESLOT 5</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> sort_timer_lst timer_lst;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> epollfd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="type">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> old_option = <span class="built_in">fcntl</span>(fd, F_GETFL);</span><br><span class="line">    <span class="type">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">    <span class="built_in">fcntl</span>(fd, F_SETFL, new_option);</span><br><span class="line">    <span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addfd</span><span class="params">(<span class="type">int</span> epollfd, <span class="type">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.events = EPOLLIN | EPOLLET;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">    <span class="built_in">setnonblocking</span>(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sig_handler</span><span class="params">(<span class="type">int</span> sig)</span> <span class="comment">// 将信号发往pipefd[1]</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> save_errno = errno;</span><br><span class="line">    <span class="type">int</span> msg = sig;</span><br><span class="line">    <span class="built_in">send</span>(pipefd[<span class="number">1</span>], (<span class="type">char</span>*)&amp;msg, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    errno = save_errno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addsig</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> sa;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;sa, <span class="string">&#x27;\0&#x27;</span>, <span class="built_in">sizeof</span>(sa));</span><br><span class="line">    sa.sa_handler = sig_handler;</span><br><span class="line">    sa.sa_flags |= SA_RESTART; <span class="comment">// 重新调用被该信号终止的系统调用 P182</span></span><br><span class="line">    <span class="built_in">sigfillset</span>(&amp;sa.sa_mask); <span class="comment">// 在信号集中设置所有信号</span></span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">sigaction</span>(sig, &amp;sa, <span class="literal">NULL</span>) != <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">timer_handler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    timer_lst.<span class="built_in">tick</span>();</span><br><span class="line">    <span class="built_in">alarm</span>(TIMESLOT); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cb_func</span><span class="params">(client_data* user_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_DEL, user_data-&gt;sockfd, <span class="number">0</span>); <span class="comment">// 把user_data-&gt;sockfd从监听的fd中删除</span></span><br><span class="line">    <span class="built_in">assert</span>(user_data);</span><br><span class="line">    <span class="built_in">close</span>(user_data-&gt;sockfd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;close fd %d\n&quot;</span>, user_data-&gt;sockfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, <span class="built_in">basename</span>(argv[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = <span class="built_in">atoi</span>(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;address, <span class="built_in">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> listenfd = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert</span>(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">bind</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="built_in">sizeof</span>(address));</span><br><span class="line">    <span class="built_in">assert</span>(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">listen</span>(listenfd, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">assert</span>(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line">    <span class="type">int</span> epollfd = <span class="built_in">epoll_create</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">assert</span>(epollfd != <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">addfd</span>(epollfd, listenfd);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">socketpair</span>(PF_UNIX, SOCK_STREAM, <span class="number">0</span>, pipefd); <span class="comment">// 双向管道</span></span><br><span class="line">    <span class="built_in">assert</span>(ret != <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">setnonblocking</span>(pipefd[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">addfd</span>(epollfd, pipefd[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">addsig</span>(SIGALRM);</span><br><span class="line">    <span class="built_in">addsig</span>(SIGTERM);</span><br><span class="line">    <span class="type">bool</span> stop_server = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    client_data* users = <span class="keyword">new</span> client_data[FD_LIMIT];</span><br><span class="line">    <span class="type">bool</span> timeout = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">alarm</span>(TIMESLOT); <span class="comment">// 定时</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stop_server) &#123;</span><br><span class="line">        <span class="type">int</span> number = <span class="built_in">epoll_wait</span>(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> ((number &lt; <span class="number">0</span>) &amp;&amp; (errno != EINTR)) &#123; <span class="comment">// EINTR代表临时性失败,进行系统调用时执行信号处理函数去了。 再次调用有可能成功</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line">            <span class="type">int</span> sockfd = events[i].data.fd;</span><br><span class="line">            <span class="keyword">if</span> (sockfd == listenfd) &#123;</span><br><span class="line">                <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_address;</span><br><span class="line">                <span class="type">socklen_t</span> client_addrlength = <span class="built_in">sizeof</span>(client_address);</span><br><span class="line">                <span class="type">int</span> connfd = <span class="built_in">accept</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;client_address, &amp;client_addrlength);</span><br><span class="line">                <span class="built_in">addfd</span>(epollfd, connfd);</span><br><span class="line">                users[connfd].address = client_address;</span><br><span class="line">                users[connfd].sockfd = connfd;</span><br><span class="line"></span><br><span class="line">                util_timer* timer = <span class="keyword">new</span> util_timer; <span class="comment">// 加入定时器</span></span><br><span class="line">                timer-&gt;user_data = &amp;users[connfd];</span><br><span class="line">                timer-&gt;cb_func = cb_func;</span><br><span class="line">                <span class="type">time_t</span> cur = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">                timer-&gt;expire = cur + <span class="number">3</span> * TIMESLOT;</span><br><span class="line">                users[connfd].timer = timer;</span><br><span class="line">                timer_lst.<span class="built_in">add_timer</span>(timer);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((sockfd == pipefd[<span class="number">0</span>]) &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123; <span class="comment">// 处理信号</span></span><br><span class="line">                <span class="type">int</span> sig;</span><br><span class="line">                <span class="type">char</span> signals[<span class="number">1024</span>];</span><br><span class="line">                ret = <span class="built_in">recv</span>(pipefd[<span class="number">0</span>], signals, <span class="built_in">sizeof</span>(signals), <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ret; ++i) &#123;</span><br><span class="line">                        <span class="keyword">switch</span>(signals[i]) &#123;</span><br><span class="line">                            <span class="keyword">case</span> SIGALRM: &#123;</span><br><span class="line">                                <span class="built_in">printf</span>(<span class="string">&quot;SIGALARM has been triggered!\n&quot;</span>);</span><br><span class="line">                                timeout = <span class="literal">true</span>; <span class="comment">// 标记有定时任务要处理</span></span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">case</span> SIGTERM: &#123;</span><br><span class="line">                                stop_server = <span class="literal">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123; <span class="comment">// 处理接收数据</span></span><br><span class="line">                <span class="built_in">memset</span>(users[sockfd].buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE);</span><br><span class="line">                ret = <span class="built_in">recv</span>(sockfd, users[sockfd].buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;get %d bytes of clinet data %s from %d\n&quot;</span>, ret, users[sockfd].buf, sockfd);</span><br><span class="line">                util_timer* timer = users[sockfd].timer;</span><br><span class="line">                <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (errno != EAGAIN) &#123; <span class="comment">// 非阻塞系统调用由于资源限制，意思很明显，让你再次尝试</span></span><br><span class="line">                        <span class="built_in">cb_func</span>(&amp;users[sockfd]); <span class="comment">// 发生读错误，sockfd可以删了</span></span><br><span class="line">                        <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">                            timer_lst.<span class="built_in">del_timer</span>(timer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123; <span class="comment">// 对方关闭连接 服务器也关闭连接</span></span><br><span class="line">                    <span class="built_in">cb_func</span>(&amp;users[sockfd]);</span><br><span class="line">                    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">                        timer_lst.<span class="built_in">del_timer</span>(timer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">                        <span class="type">time_t</span> cur = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">                        timer-&gt;expire = cur + <span class="number">3</span> * TIMESLOT;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;adjust timer once\n&quot;</span>);</span><br><span class="line">                        timer_lst.<span class="built_in">adjust_timer</span>(timer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (timeout) &#123; <span class="comment">// 处理定时事件（清理链表中超时的事件），优先级比io低。</span></span><br><span class="line">            <span class="built_in">timer_handler</span>();</span><br><span class="line">            timeout = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(listenfd);</span><br><span class="line">    <span class="built_in">close</span>(pipefd[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">close</span>(pipefd[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">delete</span>[] users;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>每过五秒就会发送一个SIGALRM信号，每个客户端和服务器的过期连接时常是3个timeslot，超时后服务器会自动断开与客户端的连接。每次客户端向服务器发送信息后，会调用adjust_timer来重新调整这个连接的到期时间，至发送信息后+三个timeslot。</p>
<hr>
<p>服务器：<br>
<img src="/20220307204428_2297/1.png" alt="在这里插入图片描述"></p>
<hr>
<p>客户端：<br>
<img src="/20220307204428_2297/2.png" alt="在这里插入图片描述"></p>
<hr>
<p>reference: Linux高性能服务器编程——游双</p>
]]></content>
      <categories>
        <category>socket-programming</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/20220809190428_61809/</url>
    <content><![CDATA[<h1>并查集是为了解决什么问题</h1>
<p>有10个人，他们之间有错综复杂的关系。如果认定1和2为朋友，2和3也为朋友，那么就认定1和3也是朋友。现在给定两个编号，能否快速知道这两个人是否是朋友？这就是并查集的领域了。</p>
<h2 id="基本思想：">基本思想：</h2>
<p>并查集的本质是一个单向且出度为1的图。可以用一个数组来表示，这个数组记录的内容为这个节点所指向的另一个节点的编号。由于这个图出度为1，所以每个元素只<em><strong>唯一的</strong></em>指向另一个元素。而指向的这个节点，我们称为该节点的父节点。<br>
并查集英文叫 unionFind，顾名思义这个数据结构有两个方法，union 和 find。union 用于连接两个集合，find 用于找到这个集合所属的编号。</p>
<h2 id="初始化">初始化</h2>
<p>只需要把每个节点的父节点设置为自己即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="所属集合的判断">所属集合的判断</h2>
<p>所属的集合只要一直向上遍历，直到找到祖先为止。祖先的编号就是这整个集合的标志编号。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (parent[i] != i) &#123;</span><br><span class="line">        i = parent[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关系的建立">关系的建立</h2>
<p>如果要把两个节点建立并查集关系，只需要指定一个节点的祖先为另一个节点的父节点就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">find</span>(a);</span><br><span class="line">    <span class="type">int</span> y = <span class="built_in">find</span>(b);</span><br><span class="line">    <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    parent[x] = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1>路径压缩</h1>
<p>在某些极端情况下，这棵树型结构的集合可能会退化为线性结构，这样的情况下find函数会十分耗时。所以我们可以试着在某些方面优化这个效率。</p>
<h2 id="查找时优化">查找时优化</h2>
<p>在查找的过程中就直接将沿途的所有元素都指向根节点，大大的缩短下次查找时的时间。<br>
<img src="/20220809190428_61809/1.png" alt="1"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == parent[i]) &#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent[i] = <span class="built_in">find</span>(parent[i]); <span class="comment">//在第一次查找的时候 将结点直接连到祖先</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="合并时优化">合并时优化</h2>
<p>目前的合并是无论如何都让第二个节点的祖先当第一个节点祖先的新祖先，无视了每个集合内树的高度。如果我们记录下树的高度，让较高的树作为新的祖先，较低的树作为它的子节点，可以一定程度的平衡下树的高度。<br>
<img src="/20220809190428_61809/2.png" alt="2"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">find</span>(a);</span><br><span class="line">    <span class="type">int</span> y = <span class="built_in">find</span>(b);</span><br><span class="line">    <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 比高度</span></span><br><span class="line">    <span class="keyword">if</span> (rank[x] &lt; rank[y]) &#123;</span><br><span class="line">        parent[x] = y;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent[y] = x;</span><br><span class="line">        <span class="keyword">if</span> (rank[x] == rank[y]) &#123;</span><br><span class="line">            rank[x]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>data-structure</category>
      </categories>
      <tags>
        <tag>data-structure</tag>
      </tags>
  </entry>
  <entry>
    <title>快速幂cpp代码</title>
    <url>/20220226095439_17254/</url>
    <content><![CDATA[<p>基础问题：求数字 $a$ 的 $n$ 次方。<br>
最基本的想法，就是一次一次相乘，时间复杂度为 $O(n)$。<br>
代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function">ll <span class="title">pow</span><span class="params">(ll a, ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        ret *= a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>稍微思考一下便可得知，计算一个数的$n$次方并不需要相乘 $n$ 次。我们如果知道 $a$ 的 $n/2$ 次方，便可以用两个 $a^{n/2}$ 相乘，获得 $a^n$。顺着这个思想往下想，可以考虑把 $n$ 拆成二进制的形式，这样只要把对应的二进制位数得到的幂相乘起来就可以得出答案了。举例：当 $n$ 为 7 时，我们要 $6^7$。$7$ 按照二进制可以拆成 $00000111$。那我们只要知道 $6^1$，$6^2$ 和 $6^4$，再把他们相乘就可以了。<br>
代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">qpow</span>(a, n - <span class="number">1</span>) * a;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ll ret = <span class="built_in">qpow</span>(a, n / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> ret * ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow2</span><span class="params">(ll a, ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            ret *= a;</span><br><span class="line">        &#125;</span><br><span class="line">        a *= a;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一为递归的方式，二为迭代的方式。考虑到调用栈切换，方式二会快一些。这种把幂拆成二进制的方法，就被称为快速幂。<br>
完整代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function">ll <span class="title">pow</span><span class="params">(ll a, ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        ret *= a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">qpow</span>(a, n - <span class="number">1</span>) * a;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ll ret = <span class="built_in">qpow</span>(a, n / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> ret * ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow2</span><span class="params">(ll a, ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            ret *= a;</span><br><span class="line">        &#125;</span><br><span class="line">        a *= a;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll a = <span class="number">7</span>, n = <span class="number">16</span>;</span><br><span class="line">    <span class="type">clock_t</span> startTime, endTime;</span><br><span class="line">    startTime = <span class="built_in">clock</span>(); <span class="comment">// cpu clock time</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">pow</span>(a, n) &lt;&lt; endl;</span><br><span class="line">    endTime = <span class="built_in">clock</span>();</span><br><span class="line">    cout &lt;&lt; (endTime - startTime) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    startTime = <span class="built_in">clock</span>(); <span class="comment">// cpu clock time</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">qpow</span>(a, n) &lt;&lt; endl;</span><br><span class="line">    endTime = <span class="built_in">clock</span>();</span><br><span class="line">    cout &lt;&lt; (endTime - startTime) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    startTime = <span class="built_in">clock</span>(); <span class="comment">// cpu clock time</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">qpow2</span>(a, n) &lt;&lt; endl;</span><br><span class="line">    endTime = <span class="built_in">clock</span>();</span><br><span class="line">    cout &lt;&lt; (endTime - startTime) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到后面两种cpu周期普遍低于前一种。</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>推理性能优化</title>
    <url>/20221123170741_370704261/</url>
    <content><![CDATA[<h2 id="推理性能优化">推理性能优化</h2>
<p>推理优化工作可以归成四类</p>
<ol>
<li>算子优化</li>
<li>图优化</li>
<li>模型压缩</li>
<li>部署优化</li>
</ol>
<h2 id="算子优化">算子优化</h2>
<p>算子优化就是优化单算子的性能，方法无非是算法优化和微架构优化。</p>
<p>对同一个算子可能有不同的算法去实现它。举个例子，对卷积算法我们常见的就有：矩阵乘法，直接卷积法，Winograd 变换法，FFT 变换法。需要我们针对目标问题，分析并实现合适的算法，来达到最佳性能。<br>
微架构优化。微架构优化主要焦点是如何充分利用好微架构的内置加速器的能力去最大化算子的性能。</p>
<h2 id="图优化">图优化</h2>
<p>图优化主要通过<strong>子图变换</strong>和<strong>算子融合</strong>的方式来达到减少计算量或者其他系统开销（如访存开销），从而达到性能优化的目的。图优化主要是希望在不影响模型的数值特性的基础上，通过图变换达到简化计算、资源开销，提升性能，所以是性能优化时的首选方法之一。</p>
<h3 id="子图变换">子图变换</h3>
<p>子图变换主要是通过数学变换的手段对图进行精简，从而减少计算和调度开销。常见的有常数折叠，公共子表达式折叠以及算术变换。</p>
<h4 id="常数折叠-Constant-Folding">常数折叠 (Constant Folding)</h4>
<p><img src="/20221123170741_370704261/1.png" alt="1"></p>
<p><img src="/20221123170741_370704261/2.png" alt="2"></p>
<h4 id="算数变换">算数变换</h4>
<p><img src="/20221123170741_370704261/3.png" alt="3"></p>
<h4 id="算子融合">算子融合</h4>
<p>在深度学习中，一般来说，计算密集型和访存密集型算子是相伴出现的。这时候我们可以通过 fusion 来实现寄存器计算，从而减少访存密集型算子的访存，减少内存访问延时和带宽压力，提高推理效率。</p>
<p><img src="/20221123170741_370704261/4.png" alt="4"></p>
<p><img src="/20221123170741_370704261/5.png" alt="5"><br>
通过这种方式，减少两次 tensor 的内存读写操作。</p>
<h2 id="模型压缩">模型压缩</h2>
<p>上面的方案都是精度无损的，当这三点都做完了后，如果还需要额外的性能增益，这时候需要考虑模型压缩方案。</p>
<h3 id="模型量化">模型量化</h3>
<p>模型量化主要是通过降低模型中 tensor 和 weights 精度的手段，从而减少计算需求和数据存储与传输需求，来达到加速的目的。例如把权重从 FP32 降低为 FP16。虽然可以加速，但是有一定的精度损失。</p>
<h3 id="模型蒸馏">模型蒸馏</h3>
<p>模型蒸馏采用的是迁移学习的方法，通过采用预先训练好的复杂模型（Teacher Model）的输出作为监督数据，去训练另外一个简单的网络（Student Model），最后把 Student Model 用于推理。有精度损失。</p>
<h2 id="部署优化">部署优化</h2>
<p>部署优化主要通过调整模型在部署时的资源分配和调度的参数来进一步优化性能。如，调整了 NUMA 的参数。</p>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器压力测试客户端</title>
    <url>/20220515214808_6652/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* request = <span class="string">&quot;GET http://localhost/index.html HTTP/1.1\r\nConnection: keep-alive\r\n\r\nxxxxxxxxxxxx&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setnonblocking</span><span class="params">( <span class="type">int</span> fd )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> old_option = <span class="built_in">fcntl</span>( fd, F_GETFL );</span><br><span class="line">    <span class="type">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">    <span class="built_in">fcntl</span>( fd, F_SETFL, new_option );</span><br><span class="line">    <span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addfd</span><span class="params">( <span class="type">int</span> epoll_fd, <span class="type">int</span> fd )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.events = EPOLLOUT | EPOLLET | EPOLLERR;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>( epoll_fd, EPOLL_CTL_ADD, fd, &amp;event );</span><br><span class="line">    <span class="built_in">setnonblocking</span>( fd );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向服务器写len个字节数据</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">write_nbytes</span><span class="params">( <span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">char</span>* buffer, <span class="type">int</span> len )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> bytes_write = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;write out %d bytes to socket %d\n&quot;</span>, len, sockfd );</span><br><span class="line">    <span class="keyword">while</span>( <span class="number">1</span> ) </span><br><span class="line">    &#123;   </span><br><span class="line">        bytes_write = <span class="built_in">send</span>( sockfd, buffer, len, <span class="number">0</span> );</span><br><span class="line">        <span class="keyword">if</span> ( bytes_write == <span class="number">-1</span> )</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( bytes_write == <span class="number">0</span> ) </span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line">        len -= bytes_write;</span><br><span class="line">        buffer = buffer + bytes_write;</span><br><span class="line">        <span class="keyword">if</span> ( len &lt;= <span class="number">0</span> ) </span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从服务器读取数据</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">read_once</span><span class="params">( <span class="type">int</span> sockfd, <span class="type">char</span>* buffer, <span class="type">int</span> len )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> bytes_read = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>( buffer, <span class="string">&#x27;\0&#x27;</span>, len );</span><br><span class="line">    bytes_read = <span class="built_in">recv</span>( sockfd, buffer, len, <span class="number">0</span> );</span><br><span class="line">    <span class="keyword">if</span> ( bytes_read == <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( bytes_read == <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;read in %d bytes from socket %d with content: %s\n&quot;</span>, bytes_read, sockfd, buffer );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向服务器发起num个tcp连接，可以通过num更改压力</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">start_conn</span><span class="params">( <span class="type">int</span> epoll_fd, <span class="type">int</span> num, <span class="type">const</span> <span class="type">char</span>* ip, <span class="type">int</span> port )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;</span><br><span class="line">    <span class="built_in">bzero</span>( &amp;address, <span class="built_in">sizeof</span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>( port );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; num; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sleep</span>( <span class="number">1</span> );</span><br><span class="line">        <span class="type">int</span> sockfd = <span class="built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;create 1 sock\n&quot;</span> );</span><br><span class="line">        <span class="keyword">if</span>( sockfd &lt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (  <span class="built_in">connect</span>( sockfd, ( <span class="keyword">struct</span> sockaddr* )&amp;address, <span class="built_in">sizeof</span>( address ) ) == <span class="number">0</span>  )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>( <span class="string">&quot;build connection %d\n&quot;</span>, i );</span><br><span class="line">            <span class="built_in">addfd</span>( epoll_fd, sockfd );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">close_conn</span><span class="params">( <span class="type">int</span> epoll_fd, <span class="type">int</span> sockfd )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>( epoll_fd, EPOLL_CTL_DEL, sockfd, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">close</span>( sockfd );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( <span class="type">int</span> argc, <span class="type">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>( argc == <span class="number">4</span> );</span><br><span class="line">    <span class="type">int</span> epoll_fd = <span class="built_in">epoll_create</span>( <span class="number">100</span> );</span><br><span class="line">    <span class="built_in">start_conn</span>( epoll_fd, <span class="built_in">atoi</span>( argv[ <span class="number">3</span> ] ), argv[<span class="number">1</span>], <span class="built_in">atoi</span>( argv[<span class="number">2</span>] ) );</span><br><span class="line">    epoll_event events[ <span class="number">10000</span> ];</span><br><span class="line">    <span class="type">char</span> buffer[ <span class="number">2048</span> ];</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> fds = <span class="built_in">epoll_wait</span>( epoll_fd, events, <span class="number">10000</span>, <span class="number">2000</span> );</span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; fds; i++ )</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="type">int</span> sockfd = events[i].data.fd;</span><br><span class="line">            <span class="keyword">if</span> ( events[i].events &amp; EPOLLIN )</span><br><span class="line">            &#123;   </span><br><span class="line">                <span class="keyword">if</span> ( ! <span class="built_in">read_once</span>( sockfd, buffer, <span class="number">2048</span> ) )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">close_conn</span>( epoll_fd, sockfd );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">struct</span> <span class="title class_">epoll_event</span> event;</span><br><span class="line">                event.events = EPOLLOUT | EPOLLET | EPOLLERR; <span class="comment">// 读完之后设置成可写</span></span><br><span class="line">                event.data.fd = sockfd;</span><br><span class="line">                <span class="built_in">epoll_ctl</span>( epoll_fd, EPOLL_CTL_MOD, sockfd, &amp;event );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( events[i].events &amp; EPOLLOUT ) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ( ! <span class="built_in">write_nbytes</span>( sockfd, request, <span class="built_in">strlen</span>( request ) ) )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">close_conn</span>( epoll_fd, sockfd );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">struct</span> <span class="title class_">epoll_event</span> event;</span><br><span class="line">                event.events = EPOLLIN | EPOLLET | EPOLLERR; <span class="comment">// 写完之后设置成可读</span></span><br><span class="line">                event.data.fd = sockfd;</span><br><span class="line">                <span class="built_in">epoll_ctl</span>( epoll_fd, EPOLL_CTL_MOD, sockfd, &amp;event );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( events[i].events &amp; EPOLLERR )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">close_conn</span>( epoll_fd, sockfd );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./clientname &#123;ip&#125; &#123;port&#125; &#123;number&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/20220515214808_6652/1.png" alt="在这里插入图片描述"></p>
<hr>
<p>reference：<br>
Linux高性能服务器编程——游双$P_{329}$</p>
]]></content>
      <categories>
        <category>socket-programming</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组</title>
    <url>/20220709142056_5009/</url>
    <content><![CDATA[<h1>什么是树状数组</h1>
<p>有这样一个问题，给定一个数组，求它的前 $n$ 项和。<br>
<img src="/20220709142056_5009/1.png" alt="1"><br>
最简单粗暴的方式，就是一个个加起来，存到一个大小为 $n$ 的数组里面，时间复杂度为 $O(n)$。<br>
但是有一个数变了,由 $b_1$ 变为了 $b_2$，需要更新上述的数组，那么更改的时间复杂度为 $O(n)$，因为为了维护上述数组的性质，需要在变更的数之后的所有数都给加上这个变化 $b_2 - b_1$。求和的时间复杂度为 $O(1)$，因为拿到前缀和之后数组的结果就是答案了。<br>
如果这个数组要被频繁修改，那这种方式效率就很低下了。有没有更快的方式呢？</p>
<h2 id="树状数组的雏形">树状数组的雏形</h2>
<p>我们可以做以下处理：<br>
<img src="/20220709142056_5009/2.png" alt="2"><br>
首先将每两个数的和都记录下来，那么求和的时候就可以只求 $(n/2)$ 次了。那么再对第二层的数组再做一个两两求和…次数就变为 $(n/4)$ 次了。以此类推。最后就变成上图这个样子了。如果是这样的话，修改一个数，我们只需要更改 $log_2n$个数就可以了！<br>
仔细观察上述数组，我们发现有一些数字是根本用不上的。第 $i$ 层的偶数个数都用不上。那么他就会变成这个样子：<br>
<img src="/20220709142056_5009/3.png" alt="3"><br>
这样空间复杂度就从 $O(n^2)$ 退化为 $O(n)$ 了。这其中的每个数代表一段区间内数字的和。</p>
<h2 id="lowerbits">lowerbits</h2>
<p>在介绍树状数组的操作之前，先引入一个函数，这个函数代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lowerbits</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的作用是将一个数的二进制格式中最低位的1单独拿出来，比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">binary</span>(<span class="number">12</span>) = <span class="number">00001100</span>   (就展示最低的一个字节)</span><br><span class="line"><span class="built_in">lowerbits</span>(<span class="number">12</span>) = <span class="number">00000100</span>  (取最后一个<span class="number">1</span>之后的部分)</span><br></pre></td></tr></table></figure>
<p>这个函数在树状数组中有什么作用呢？$lowerbits(x)$指代的是下标为 $x$ 的树状数组元素所代表的原数组的区间长度。如图：<br>
<img src="/20220709142056_5009/4.png" alt="4"><br>
$lowerbits(12) = 4$ 代表树状数组 $12$ 下标（从 $1$ 开始）所代表的原数组中 $4$ 个数字元素的和。即树状数组元素 $10$ 是原数组 $3,1,2,4$ 的和。</p>
<h2 id="用树状数组的求和">用树状数组的求和</h2>
<p><img src="/20220709142056_5009/5.png" alt="5"><br>
顺着图上的树形结构依次往左上角求和。如图所示。求前 $14$ 项和的值等于 $b[14] + b[12] + b[8]$ 。<br>
代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        res += b[n];</span><br><span class="line">        n -= <span class="built_in">lowerbits</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此可见，利用树状数组求和的时间复杂度是 $O(log_2n)$。</p>
<h2 id="更新树状数组">更新树状数组</h2>
<p><img src="/20220709142056_5009/6.png" alt="6"><br>
更新操作则是把所有包含了新数字的树状数组元素统统更新一遍，如图中红线所示。顺着树形结构向右上角更新。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// delta 是第 i 位数字的变化值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; N) &#123;</span><br><span class="line">        i += delta;</span><br><span class="line">        i += <span class="built_in">lowerbits</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此可见，更新时间复杂度为 $O(log_2n)$，比最开始的方式快了很多。</p>
<h2 id="初始化树状数组">初始化树状数组</h2>
<p>以下表示中 $a[i]$ 为原数组元素，$b[i]$ 为树状数组元素。</p>
<h3 id="直接初始化为0，并且对每个点调用add。">直接初始化为0，并且对每个点调用add。</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="built_in">add</span>(i, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度 $O(nlog_2n)$。</p>
<hr>
<h3 id="使用前缀和辅助数组">使用前缀和辅助数组</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">        pre[i] = pre[i - <span class="number">1</span>] + a[i];</span><br><span class="line">        b[i] = pre[i] - pre[i - <span class="built_in">lowerbits</span>(i)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式时间复杂度为 $O(n)$，但是要占用额外的空间。</p>
]]></content>
      <categories>
        <category>data-structure</category>
      </categories>
      <tags>
        <tag>data-structure</tag>
      </tags>
  </entry>
  <entry>
    <title>父子进程信号量</title>
    <url>/20220316211246_20228/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">semun</span> &#123;                   <span class="comment">// 此结构体为semctl系统调用的第四个参数的推荐格式，由sys/sem.h给出</span></span><br><span class="line">    <span class="type">int</span> val;                    <span class="comment">// 用于SETVAL命令</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">semid_ds</span>* buf;       <span class="comment">// 用于IPC_STAT和IPC_SET命令</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span>* array;  <span class="comment">// 用于GETALL和SETALL命令</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">seminfo</span>* __buf;      <span class="comment">// 用于IPC_INFO命令</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pv</span><span class="params">(<span class="type">int</span> sem_id, <span class="type">int</span> op)</span> </span>&#123; <span class="comment">// 此函数用于操作sem_id信号集的信号量，对其做出 +op 的操作</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sembuf</span> sem_b;      <span class="comment">// 每一个sembuf结构体都对应一个信号量操作</span></span><br><span class="line">    sem_b.sem_num = <span class="number">0</span>;        <span class="comment">// 信号集中信号量的编号，0表示信号集中第0个信号量</span></span><br><span class="line">    sem_b.sem_op = op;</span><br><span class="line">    sem_b.sem_flg = SEM_UNDO; <span class="comment">// 该标志意思为，当进程退出时取消正在进行的semop操作</span></span><br><span class="line">    <span class="built_in">semop</span>(sem_id, &amp;sem_b, <span class="number">1</span>); <span class="comment">// 失败时 数组内所有操作都不执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sem_id = <span class="built_in">semget</span>(IPC_PRIVATE, <span class="number">1</span>, <span class="number">0666</span>); <span class="comment">// 无论信号量是否已经存在，都会创建一个 新 的信号量。IPC_NEW这个名字更合适</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> <span class="title class_">semun</span> sem_un;</span><br><span class="line">    sem_un.val = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">semctl</span>(sem_id, <span class="number">0</span>, SETVAL, sem_un);         <span class="comment">// 第0个信号，执行SETVAL命令，参数为sum_un</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> id = fork();</span><br><span class="line">    <span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id == <span class="number">0</span>) &#123; <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child try to get binary sem\n&quot;</span>);</span><br><span class="line">        <span class="built_in">pv</span>(sem_id, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child get the sem and would release it after 5 seconds\n&quot;</span>);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">pv</span>(sem_id, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent try to get binary sem\n&quot;</span>);</span><br><span class="line">        <span class="built_in">pv</span>(sem_id, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent get the sem and would release it after 5 seconds\n&quot;</span>);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">pv</span>(sem_id, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">waitpid</span>(id, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">// 父进程等待子进程结束</span></span><br><span class="line">    <span class="built_in">semctl</span>(sem_id, <span class="number">0</span>, IPC_RMID, sem_un); <span class="comment">// remove id 删除信号量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/20220316211246_20228/1.png" alt="在这里插入图片描述"></p>
<hr>
<p>reference: linux高性能服务器编程——游双</p>
]]></content>
      <categories>
        <category>concurrent-programming</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>用SIGURG检测带外数据是否到达</title>
    <url>/20220228164437_11610/</url>
    <content><![CDATA[<h2 id="带外数据">带外数据</h2>
<p>带外数据用于迅速告知对方本端发生的重要的事件。它比普通的数据（带内数据）拥有更高的优先级，不论发送缓冲区中是否有排队等待发送的数据，它总是被立即发送。带外数据的传输可以使用一条独立的传输层连接，也可以映射到传输普通数据的连接中。</p>
<h2 id="SIGURG信号的作用">SIGURG信号的作用</h2>
<p>在linux环境下，内核通知应用程序带外数据到达的方式有两种：</p>
<ol>
<li>一种就是利用I/Ｏ复用技术的系统调用（如select）在接受到带外数据时将返回，并向应用程序报告socket上的异常事件。</li>
<li>另一种方法就是使用SIGURG信号。（下面代码）</li>
</ol>
<h2 id="代码：">代码：</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> connfd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sig_urg</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> save_errno = errno;</span><br><span class="line">    <span class="type">char</span> buffer[BUF_SIZE];</span><br><span class="line">    <span class="built_in">memset</span>(buffer, <span class="string">&#x27;\0&#x27;</span>, BUF_SIZE);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">recv</span>(connfd, buffer, BUF_SIZE - <span class="number">1</span>, MSG_OOB); <span class="comment">// 接收带外数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;got %d bytes of oob data &#x27;%s\n&#x27; &quot;</span>, ret, buffer);</span><br><span class="line">    errno = save_errno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addsig</span> <span class="params">(<span class="type">int</span> sig, <span class="type">void</span> (* sig_handler) (<span class="type">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> sa;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;sa, <span class="string">&#x27;\0&#x27;</span>, <span class="built_in">sizeof</span>(sa));</span><br><span class="line">    sa.sa_handler = sig_handler;</span><br><span class="line">    sa.sa_flags |= SA_RESTART;</span><br><span class="line">    <span class="built_in">sigfillset</span>(&amp;sa.sa_mask);</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">sigaction</span>(sig, &amp;sa, <span class="literal">NULL</span>) != <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt;= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="built_in">basename</span>(argv[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = <span class="built_in">atoi</span>(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;address, <span class="built_in">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert</span>(socket &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(sock, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="built_in">sizeof</span>(address));</span><br><span class="line">    <span class="built_in">assert</span>(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">listen</span>(sock, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">assert</span>(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client;</span><br><span class="line">    <span class="type">socklen_t</span> client_addrlength = <span class="built_in">sizeof</span>(client);</span><br><span class="line">    connfd = <span class="built_in">accept</span>(sock, (<span class="keyword">struct</span> sockaddr*)&amp;client, &amp;client_addrlength);</span><br><span class="line">    <span class="keyword">if</span> (connfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;errno is: %d\n&quot;</span>, errno);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">addsig</span>(SIGURG, sig_urg);</span><br><span class="line">        <span class="built_in">fcntl</span>(connfd, F_SETOWN, <span class="built_in">getpid</span>()); <span class="comment">// 设置SIGURG信号之前，我们必须设置socket的宿主进程或进程组</span></span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> buffer[BUF_SIZE];</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(buffer, <span class="string">&#x27;\0&#x27;</span>, BUF_SIZE);</span><br><span class="line">            ret = <span class="built_in">recv</span>(connfd, buffer, BUF_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;got %d bytes of normal data &#x27;%s\n&quot;</span>, ret, buffer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>客户端（本机模拟发送SIGURG）<br>
<img src="/20220228164437_11610/1.png" alt="1"></p>
<hr>
<p>服务端反应<br>
<img src="/20220228164437_11610/2.png" alt="2"></p>
<hr>
<p>reference：<br>
linux高性能服务器编程——游双</p>
]]></content>
      <categories>
        <category>socket-programming</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵快速幂</title>
    <url>/20220226151634_25991/</url>
    <content><![CDATA[<p>关于什么是快速幂：<a href="/20220226095439_17254/" title="快速幂cpp代码">快速幂代码</a><br>
现在回想下问题斐波那契数列：$f(1) = 1, f(2) = 1$。在$n &gt; 2$时， $f(n) = f(n - 1) + f (n - 2)$。求$f(n)$。<br>
朴素动态规划解法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> dp[n];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>, dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在考虑$F_{n}$是由$F_{n-1}$和$F_{n-2}$线性变换得出。则有：<br>
$$<br>
[F_{n} \ \ \ F_{n-1}] = [F_{n-1}\ \ \ F_{n-2}] \times \begin{bmatrix} 1 &amp; 1 \ 1 &amp; 0 \end{bmatrix}<br>
$$<br>
设矩阵$\begin{bmatrix} 1 &amp; 1 \ 1 &amp; 0 \end{bmatrix}$为$P$。<br>
则有<br>
$$<br>
[F_{n+1}\ \ \ F_{n}] = [F_{n} \ \ \ F_{n-1}] \times \begin{bmatrix} 1 &amp; 1 \ 1 &amp; 0 \end{bmatrix} =  [F_{n-1}\ \ \ F_{n-2}] \times\begin{bmatrix} 1 &amp; 1 \ 1 &amp; 0 \end{bmatrix}^2 = [F_{n-1}\ \ \ F_{n-2}] \times P^2<br>
$$<br>
因为矩阵乘法满足结合律，所以我们可以直接用矩阵$P$的幂来得到$F_n$的值。而求矩阵$P^n$的时间复杂度为$O(log(n))$。<br>
C++代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">int</span> v[maxn][maxn];</span><br><span class="line">    <span class="built_in">Matrix</span>(<span class="type">int</span> n, <span class="type">int</span> m) : <span class="built_in">n</span>(n), <span class="built_in">m</span>(m) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="built_in">sizeof</span>(v));  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Matrix <span class="keyword">operator</span>* (<span class="type">const</span> Matrix B) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="function">Matrix <span class="title">ans</span><span class="params">(n, B.m)</span></span>; <span class="comment">// for ans</span></span><br><span class="line">        ans.<span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; B.m; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; m; k++) &#123;</span><br><span class="line">                    ans.v[i][j] = ans.v[i][j] + v[i][k] * B.v[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                cout &lt;&lt; v[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">q_pow</span> <span class="params">(Matrix&amp; A, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="function">Matrix <span class="title">ret</span><span class="params">(A.n, A.m)</span></span>;</span><br><span class="line"></span><br><span class="line">    ret.<span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ret.n; i++) &#123; <span class="comment">// 初始化E</span></span><br><span class="line">        ret.v[i][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            ret = ret * A;</span><br><span class="line">        &#125;</span><br><span class="line">        A = A * A;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">int</span> v[maxn][maxn];</span><br><span class="line">    <span class="built_in">Matrix</span>(<span class="type">int</span> n, <span class="type">int</span> m) : <span class="built_in">n</span>(n), <span class="built_in">m</span>(m) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="built_in">sizeof</span>(v));  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Matrix <span class="keyword">operator</span>* (<span class="type">const</span> Matrix B) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="function">Matrix <span class="title">ans</span><span class="params">(n, B.m)</span></span>; <span class="comment">// for ans</span></span><br><span class="line">        ans.<span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; B.m; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; m; k++) &#123;</span><br><span class="line">                    ans.v[i][j] = ans.v[i][j] + v[i][k] * B.v[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                cout &lt;&lt; v[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">q_pow</span> <span class="params">(Matrix&amp; A, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="function">Matrix <span class="title">ret</span><span class="params">(A.n, A.m)</span></span>;</span><br><span class="line"></span><br><span class="line">    ret.<span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ret.n; i++) &#123; <span class="comment">// 初始化E</span></span><br><span class="line">        ret.v[i][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            ret = ret * A;</span><br><span class="line">        &#125;</span><br><span class="line">        A = A * A;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> dp[n];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>, dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">44</span>;</span><br><span class="line">    <span class="type">clock_t</span> startTime, endTime;</span><br><span class="line">    startTime = <span class="built_in">clock</span>(); <span class="comment">// cpu clock time</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">fib</span>(n) &lt;&lt; endl;</span><br><span class="line">    endTime = <span class="built_in">clock</span>();</span><br><span class="line">    cout &lt;&lt; (endTime - startTime) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// [F(n)  F(n - 1)] = [F(n - 1)  F(n - 2)] * [1 1]</span></span><br><span class="line">    <span class="comment">//                                           [1 0]</span></span><br><span class="line">    Matrix start = <span class="built_in">Matrix</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    start.v[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    start.v[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    Matrix P = <span class="built_in">Matrix</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    P.v[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    P.v[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    P.v[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    P.v[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    startTime = <span class="built_in">clock</span>(); <span class="comment">// cpu clock time</span></span><br><span class="line">    Matrix ret = start * <span class="built_in">q_pow</span>(P, n - <span class="number">1</span>);</span><br><span class="line">    endTime = <span class="built_in">clock</span>();</span><br><span class="line">    cout &lt;&lt; (endTime - startTime) &lt;&lt; endl;</span><br><span class="line">    ret.<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里暂且不考虑溢出问题。当$n$足够大的时候，可以看到快速幂需要的时钟周期明显缩短。</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>用c实现cpp三大特性</title>
    <url>/20230412003055_25523/</url>
    <content><![CDATA[<h1>Cpp的三大特性：封装，继承，多态</h1>
<h2 id="封装">封装</h2>
<ul>
<li>类是数据封装的工具，对象是数据封装的实现。在封装中，还提供了一种对数据访问的控制机制，使得一些数据被隐藏在封装体内。封装体与外界进行信息交换是通过操作接口进行的。</li>
<li>封装性实际上是由编译器去识别 public，private，protected 来实现的。只有类体内的成员函数才能访问私有成员，在类体外的函数不能访问。公有成员是封装体与外界的一个接口，类体外的函数可以访问公有成员，保护成员只有该类的派生类可以访问。</li>
<li>类是一种复杂的数据类型，他将不同类型的数据和相关操作封在一起的集合体。因此类具有对数据的抽象性，隐蔽性和封装性。</li>
<li>封装目的是为了增加代码的健壮性，减少写代码时出错的概率。只要编译可以通过，在 C++ 中无论是 public，private，protect，生成的汇编代码都是一样的。</li>
</ul>
<h2 id="继承">继承</h2>
<ul>
<li>C++ 允许单继承和多继承。</li>
<li>继承机制的目的时为了可以重复使用程序资源。</li>
<li>继承有两个方面，一是可以拥有父类的所有<strong>成员变量</strong>，第二子类也拥有父类的所有<strong>成员函数</strong>。</li>
</ul>
<h2 id="多态">多态</h2>
<ul>
<li>多态是指，对不同类对象发出相同消息，会有<strong>不同的</strong>实现。多态是指发出同样的消息被不同的数据类型的对象接受后导致不同的行为。</li>
<li>C++ 多态表现为：</li>
</ul>
<ol>
<li>允许函数重载和运算符重载。</li>
<li>通过定义虚函数来支持动态联编。</li>
</ol>
<ul>
<li>多态特性增加了一些数据存储和执行指令开销，能不用就不用。</li>
</ul>
<h1>C代码实现</h1>
<h2 id="定义函数指针">定义函数指针</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义函数指针</span></span><br><span class="line"><span class="type">int</span> (*padd)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line">padd = add;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用typedef重命名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*PADD)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line">PADD padd;</span><br><span class="line">padd = add;</span><br></pre></td></tr></table></figure>
<h2 id="继承和多态代码">继承和多态代码</h2>
<p>简单实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//C语言模拟C++的继承与多态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*FUN)</span><span class="params">()</span>;      <span class="comment">//定义一个函数指针来实现对成员函数的继承</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">A</span> &#123;</span>  <span class="comment">//父类</span></span><br><span class="line">    FUN _fun;   <span class="comment">//由于C语言中结构体不能包含函数，故只能用函数指针在外面实现</span></span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">&#125; _A;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">B</span> &#123;</span>  <span class="comment">//子类</span></span><br><span class="line">    _A _a_;     <span class="comment">//在子类中定义一个基类的对象即可实现对父类的继承</span></span><br><span class="line">    <span class="type">int</span> _b;</span><br><span class="line">&#125; _B;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _fA() &#123;  <span class="comment">//父类的同名函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;_A:_fun()\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> _fB() &#123;  <span class="comment">//子类的同名函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;_B:_fun()\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//C语言模拟继承与多态的测试</span></span><br><span class="line">    _A _a;    <span class="comment">//定义一个父类对象_a</span></span><br><span class="line">    _B _b;    <span class="comment">//定义一个子类对象_b</span></span><br><span class="line">    _a._fun = _fA;        <span class="comment">//父类的对象调用父类的同名函数</span></span><br><span class="line">    _b._a_._fun = _fB;    <span class="comment">//子类的对象调用子类的同名函数</span></span><br><span class="line"></span><br><span class="line">    _A* p2 = &amp;_a;   <span class="comment">//定义一个父类指针指向父类的对象</span></span><br><span class="line">    p2-&gt;_fun();     <span class="comment">//调用父类的同名函数</span></span><br><span class="line">    p2 = (_A*)&amp;_b;  <span class="comment">//让父类指针指向子类的对象,由于类型不匹配所以要进行强转</span></span><br><span class="line">    p2-&gt;_fun();     <span class="comment">//调用子类的同名函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@└────&gt; # ./a.out</span><br><span class="line">_A:_fun()</span><br><span class="line">_B:_fun()</span><br></pre></td></tr></table></figure>
<p>虚函数表实现方式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(*funcP)</span><span class="params">(<span class="type">void</span>*)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span>*(*virTabPointer)[<span class="number">2</span>];  <span class="comment">//这是一个指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line">    <span class="comment">//指向虚函数表的指针</span></span><br><span class="line">    virTabPointer m_virPointer;</span><br><span class="line">    <span class="type">char</span> m_name[<span class="number">20</span>];</span><br><span class="line">&#125; Animal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Tiger</span> &#123;</span></span><br><span class="line">    Animal m_base;  <span class="comment">// 继承基类</span></span><br><span class="line">    <span class="type">int</span> m_age;</span><br><span class="line">&#125; Tiger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Bull</span> &#123;</span></span><br><span class="line">    Animal m_base;  <span class="comment">// 继承基类</span></span><br><span class="line">    <span class="type">char</span> m_sex[<span class="number">6</span>];</span><br><span class="line">&#125; Bull;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SayName</span><span class="params">(<span class="type">void</span>* this)</span> &#123;</span><br><span class="line">    Animal* thisA = (Animal*)(this);  <span class="comment">// 强转为基类</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我的名字是:%s\n&quot;</span>, thisA-&gt;m_name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TigerEat</span><span class="params">(<span class="type">void</span>* this)</span> &#123;  <span class="comment">// Tiger成员函数</span></span><br><span class="line">    Animal* thisA = (Animal*)(this);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我的名字是:%s,&quot;</span>, thisA-&gt;m_name);</span><br><span class="line">    Tiger* thisTiger = (Tiger*)(this);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;今年%d岁，我吃肉\n&quot;</span>, thisTiger-&gt;m_age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BullEat</span><span class="params">(<span class="type">void</span>* this)</span> &#123;  <span class="comment">// Bull成员函数</span></span><br><span class="line">    Animal* thisA = (Animal*)(this);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我的名字是:%s,&quot;</span>, thisA-&gt;m_name);</span><br><span class="line">    Bull* thisBull = (Bull*)(this);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我的性别是:%s,我吃草\n&quot;</span>, thisBull-&gt;m_sex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TemplateFunc</span><span class="params">(Animal* obj)</span> &#123; <span class="comment">// 此函数用于调用子类的特有函数</span></span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">    <span class="type">void</span>** tempIntPointer = (<span class="type">void</span>**)(obj); <span class="comment">// 取首地址</span></span><br><span class="line">    virTabPointer tempVTab = (virTabPointer)(*tempIntPointer); <span class="comment">// 取虚表地址</span></span><br><span class="line">    funcP tempFuncAddress = (funcP)((*tempVTab)[<span class="number">1</span>]);</span><br><span class="line">    tempFuncAddress(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针的数组，数组中的所有元素都是指针，是个数组</span></span><br><span class="line"><span class="type">void</span>* animalVirTab[<span class="number">2</span>] = &#123;(<span class="type">void</span>*)&amp;SayName, <span class="literal">NULL</span>&#125;;</span><br><span class="line"><span class="type">void</span>* tigerVirTab[<span class="number">2</span>] = &#123;(<span class="type">void</span>*)&amp;SayName, (<span class="type">void</span>*)&amp;TigerEat&#125;;  <span class="comment">// 有几个虚函数元素长度就是几</span></span><br><span class="line"><span class="type">void</span>* bullVirTab[<span class="number">2</span>] = &#123;(<span class="type">void</span>*)&amp;SayName, (<span class="type">void</span>*)&amp;BullEat&#125;;  <span class="comment">// 有几个虚函数元素长度就是几</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Animal* basePointer = <span class="literal">NULL</span>;  <span class="comment">//基类的指针</span></span><br><span class="line">    <span class="comment">// Tiger多态</span></span><br><span class="line">    Tiger tigerA;</span><br><span class="line">    basePointer = (Animal*)&amp;tigerA;</span><br><span class="line">    <span class="built_in">strcpy</span>(basePointer-&gt;m_name, <span class="string">&quot;老虎&quot;</span>);</span><br><span class="line">    basePointer-&gt;m_virPointer = &amp;tigerVirTab;</span><br><span class="line">    tigerA.m_age = <span class="number">5</span>;</span><br><span class="line">    TemplateFunc(basePointer);</span><br><span class="line">    <span class="comment">// Bull多态</span></span><br><span class="line">    Bull bullA;</span><br><span class="line">    basePointer = (Animal*)&amp;bullA;</span><br><span class="line">    <span class="built_in">strcpy</span>(basePointer-&gt;m_name, <span class="string">&quot;牛&quot;</span>);</span><br><span class="line">    basePointer-&gt;m_virPointer = &amp;bullVirTab;</span><br><span class="line">    <span class="built_in">strcpy</span>(bullA.m_sex, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">    TemplateFunc(basePointer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@└────&gt; # ./a.out</span><br><span class="line">我的名字是:老虎,今年5岁，我吃肉</span><br><span class="line">我的名字是:牛,我的性别是:男,我吃草</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>调用者保存寄存器和非调用者保存寄存器</title>
    <url>/20220215093634_43852/</url>
    <content><![CDATA[<h1>定义</h1>
<p>假设有如下场景：函数 A 调用了函数 B。寄存器 %rbx 需要在调用 B 函数前后保持一致。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func A:</span><br><span class="line">    ...</span><br><span class="line">    call func B</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">func B:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>$\color{red}{调用者保存寄存器：}$</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func A:</span><br><span class="line">    ...</span><br><span class="line">    save register %rbx</span><br><span class="line">    call func B</span><br><span class="line">    restore register %rbx</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">func B:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>如上图所示，寄存器 %rbx 是由函数 B 的调用者，即函数 func A 来保存并且恢复的。函数 B 感知不到这个情况，可以尽情使用寄存器 %rbx。</p>
<p>$\color{red}{被调用者保存寄存器：}$</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func A:</span><br><span class="line">    ...</span><br><span class="line">    call func B</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">func B:</span><br><span class="line">    save register %rbx</span><br><span class="line">    ...</span><br><span class="line">    restore register %rbx</span><br></pre></td></tr></table></figure>
<p>如图所示，寄存器 %rbx 是由被调用函数，即函数 B 来保存并回复的。函数 A 感知不到这个情况。</p>
<h1>寄存器分类</h1>
<p>不同的寄存器有不同的保存策略。<br>
$\color{red}{callee \ saved(被调用者保存）：}$</p>
<blockquote>
<p>%rbx ，%rbp，%r12，%r13，%r14，%r15</p>
</blockquote>
<p>$\color{red}{caller \ saved(调用者保存)：}$</p>
<blockquote>
<p>%rax，%rdi，%rsi，%rdx，%rcx，%8，%r9，%r10，%r11</p>
</blockquote>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>线程同步机制包装类</title>
    <url>/20220419213038_19941/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LOCKER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOCKER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sem</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">sem</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sem_init</span>(&amp;m_sem, <span class="number">0</span>, <span class="number">0</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">sem</span>() &#123;</span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;m_sem);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">wait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sem_wait</span>(&amp;m_sem) == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">post</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sem_post</span>(&amp;m_sem) == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">sem_t</span> m_sem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">locker</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">locker</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pthread_mutex_init</span>(&amp;m_mutex, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">locker</span>() &#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;m_mutex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pthread_mutex_lock</span>(&amp;m_mutex) == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pthread_mutex_unlock</span>(&amp;m_mutex) == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">pthread_mutex_t</span> m_mutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装条件变量的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cond</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">cond</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pthread_mutex_init</span>(&amp;m_mutex, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pthread_cond_init</span>(&amp;m_cond, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">pthread_mutex_destroy</span>(&amp;m_mutex); </span><br><span class="line">      <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">cond</span>() &#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;m_mutex);</span><br><span class="line">    <span class="built_in">pthread_cond_destroy</span>(&amp;m_cond);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">wait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;m_mutex);</span><br><span class="line">    ret = <span class="built_in">pthread_cond_wait</span>(&amp;m_cond, &amp;m_mutex);</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;m_mutex);</span><br><span class="line">    <span class="keyword">return</span> ret == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pthread_cond_signal</span>(&amp;m_cond) == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">pthread_mutex_t</span> m_mutex;</span><br><span class="line">  <span class="type">pthread_cond_t</span> m_cond;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>充分复用代码供后续使用。</p>
<hr>
<p>reference：高性能服务器编程——游双$P_{280}$</p>
]]></content>
      <categories>
        <category>concurrent-programming</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>费马小定理</title>
    <url>/20220214012513_19332/</url>
    <content><![CDATA[<p><strong>定理内容：</strong><br>
$a$为自然数，$p$为一个质数。则有<br>
$$<br>
a^p \equiv a\ (mod\ p)<br>
$$<br>
其中 $\equiv$ 是同模符号，表示左右的数字对于p来说取模，是相等的。<br>
<strong>证明：</strong><br>
数学归纳法</p>
<ol>
<li>当$a = 1$时， 显然成立。</li>
<li>当$a = a$时，设 $p|(a^p - a)$，即$p$为$a^p - a$的约数。</li>
<li>则当$a = a + 1$时， 尝试证明 $p | ((a + 1)^p - (a + 1))$。<br>
证明如下：<br>
根据二项式定理，展开该项：<br>
$$<br>
\begin{aligned}<br>
(a + 1)^p - (a + 1) &amp;= \sum_{k=0}^{p}C_p^ka^k1^{p-k} -a - 1 \<br>
&amp;= C_p^0a^01^p + \sum_{k=1}^{p-1}C_p^ka^k1^{p-k} + C_p^pa^p1^0 - a - 1 \<br>
&amp;= 1 + \sum_{k=1}^{p-1}C_p^ka^k1^{p-k}  +  a^p - a - 1 \<br>
&amp;= \sum_{k=1}^{p-1}C_p^ka^k1^{p-k}  +  a^p - a<br>
\end{aligned}<br>
$$<br>
因为$C_p^k = \frac{p!}{k!(p - k)!}$并且$p$为质数，所以$p$为$\sum_{k=1}^{p-1}C_p^ka^k1^{p-k}$的因数，即 $p\  | \sum_{k=1}^{p-1}C_p^ka^k1^{p-k}$。<br>
又因为由假设2可知$p$为$a^p - a$的因数。所以$p$为$\sum_{k=1}^{p-1}C_p^ka^k1^{p-k}  +  a^p - a$的因数，即为$(a + 1)^p - (a + 1)$的因数。证毕。</li>
</ol>
<p><strong>应用：</strong><br>
如果$a$不是$p$的倍数，那么还有<br>
$$<br>
a^{p - 1} \equiv 1\ (mod\ p)<br>
$$<br>
所以可以用上式解决一些问题，如计算$2^{100}$模13。<br>
因为2不是13的倍数，则$2^{13 - 1} \equiv 1 (mod \ 13)$。<br>
$$<br>
\begin{aligned}<br>
2^{100} &amp;= 2^{12 * 8 + 4} \ (mod \ 13)\<br>
&amp;= (2^{12})^8 * 2^4\ (mod \ 13)\<br>
&amp;= 1^8 * 2^4\ (mod \ 13)\<br>
&amp;= 16\ (mod\ 13)\<br>
&amp;= 3<br>
\end{aligned}<br>
$$<br>
<strong>reference:</strong></p>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/87611586">https://zhuanlan.zhihu.com/p/87611586</a></li>
<li><a href="https://www.cnblogs.com/-citywall123/p/10673191.html">https://www.cnblogs.com/-citywall123/p/10673191.html</a></li>
</ol>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>递归转迭代</title>
    <url>/20230517171931_2797536300/</url>
    <content><![CDATA[<h2 id="函数调用时发生了什么">函数调用时发生了什么</h2>
<p>在 C 语言中，函数调用在底层汇编究竟发生了什么呢？示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">9</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">11</span>;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">add</span>(a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对上面这个文件编译的结果进行反汇编，这两个函数的反汇编结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@└────&gt; # objdump -d a.out</span><br><span class="line"></span><br><span class="line">0000000000400536 &lt;add&gt;:</span><br><span class="line">  400536:       55                      push   %rbp              // rbp 是被调用者保存，把上一个函数的栈基址保存</span><br><span class="line">  400537:       48 89 e5                mov    %rsp,%rbp         // 将栈顶设为新的栈基址，至此本函数的栈已经初始化好了</span><br><span class="line">  40053a:       89 7d fc                mov    %edi,-0x4(%rbp)   // 将局部变量 a 放在栈上</span><br><span class="line">  40053d:       89 75 f8                mov    %esi,-0x8(%rbp)   // 将局部变量 b 放在栈上</span><br><span class="line">  400540:       8b 55 fc                mov    -0x4(%rbp),%edx</span><br><span class="line">  400543:       8b 45 f8                mov    -0x8(%rbp),%eax</span><br><span class="line">  400546:       01 d0                   add    %edx,%eax         // 相加两个数，并将返回值放在 eax</span><br><span class="line">  400548:       5d                      pop    %rbp              // 恢复 上一个函数的栈基址</span><br><span class="line">  400549:       c3                      retq                     // 恢复 rip 寄存器，返回调用该函数的下一条指令地址</span><br><span class="line"></span><br><span class="line">000000000040054a &lt;main&gt;:</span><br><span class="line">  40054a:       55                      push   %rbp</span><br><span class="line">  40054b:       48 89 e5                mov    %rsp,%rbp         // 同上，栈初始化</span><br><span class="line">  40054e:       48 83 ec 10             sub    $0x10,%rsp        // 栈的空间先摆好</span><br><span class="line">  400552:       c7 45 fc 09 00 00 00    movl   $0x9,-0x4(%rbp)   // a 初始化</span><br><span class="line">  400559:       c7 45 f8 0a 00 00 00    movl   $0xa,-0x8(%rbp)   // b 初始化</span><br><span class="line">  400560:       c7 45 f4 0b 00 00 00    movl   $0xb,-0xc(%rbp)   // c 初始化</span><br><span class="line">  400567:       8b 55 f8                mov    -0x8(%rbp),%edx</span><br><span class="line">  40056a:       8b 45 fc                mov    -0x4(%rbp),%eax</span><br><span class="line">  40056d:       89 d6                   mov    %edx,%esi         // 第二个入参，因为从右往左放入</span><br><span class="line">  40056f:       89 c7                   mov    %eax,%edi         // 第一个入参</span><br><span class="line">  400571:       e8 c0 ff ff ff          callq  400536 &lt;add&gt;</span><br><span class="line">  400576:       89 45 f0                mov    %eax,-0x10(%rbp)  // 返回值放入 d</span><br><span class="line">  400579:       b8 00 00 00 00          mov    $0x0,%eax         // return 0</span><br><span class="line">  40057e:       c9                      leaveq </span><br><span class="line">  40057f:       c3                      retq</span><br></pre></td></tr></table></figure>
<p>可以看到，在函数调用时，发生了不同函数栈的切换。其中涉及到一些相关汇编指令。</p>
<h2 id="汇编指令中的-push-pop-call-和-ret">汇编指令中的 push pop call 和 ret</h2>
<h3 id="push-和-pop">push 和 pop</h3>
<p><img src="/20230517171931_2797536300/1.png" alt="1"></p>
<p>如上图所示，%rbp 寄存器和 %rsp 寄存器表示这一个栈的 “基址” 和 “栈顶”。因为栈是从高向低生长的，所以基址在栈顶上面。push 操作相当于，先将栈顶向下移动（因为存数据是向 %rsp 指向的位置写数据，而 %rsp 指向的是目前已有的栈顶数据），再将数据写入。pop 操作则相反。通过这两个寄存器，可以维护一个栈的存在。调用函数设计到栈的切换，所以就是通过改变这两个寄存器的值来达到切换的。</p>
<h3 id="call-和-ret">call 和 ret</h3>
<p><img src="/20230517171931_2797536300/2.png" alt="2"></p>
<p>如上图所示，调用函数涉及到执行指令的切换。将要执行的下一条指令又由 %rip 寄存器指出。</p>
<p>call 指令可以改变 %rip 寄存器的值：将 call 汇编指令的下一条指令地址 push 到栈中，之后改变 %rip 为 call 的指令地址。</p>
<p>ret 指令也可以改变 %rip 寄存器的值：将栈顶元素 pop 给 %rip，将其改为之前 call 时存的下一条要执行的指令地址。</p>
<h2 id="二叉树遍历示例">二叉树遍历示例</h2>
<p>那么操作系统这一系列操作对于我们将递归算法转换为迭代算法有什么启发吗？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">helper</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">helper</span>(root-&gt;left);</span><br><span class="line">    ret.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    <span class="built_in">helper</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    ret.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">helper</span>(root);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是二叉树中序遍历的递归写法，非常简洁。其中可以看到在递归函数 helper 中，又调用了两次 helper。我们知道每次调用 helper，都有它自己的调用栈。那么我们向迭代转换时，就要注意不能让他们的调用栈互相冲突。那么我们可以自己定义一个状态变量，用来存储当前执行的函数栈。除此之外，还要知道当前栈执行到本次函数的哪个位置（%rip)。两次 helper 的执行，可以将整个调用结构分为三部分：</p>
<ol>
<li>执行 helper(root-&gt;left) 之前</li>
<li>执行 helper(root-&gt;left) 之后，执行 helper(root-&gt;right) 之前</li>
<li>执行 helper(root-&gt;right) 之后</li>
</ol>
<p>我们定义一个 state 结构体，用于充当存储函数局部变量和执行位置。改写后函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">state</span> &#123;</span><br><span class="line">    TreeNode* node;</span><br><span class="line">    <span class="type">int</span> stage;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    stack&lt;state&gt; s;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">    s.<span class="built_in">push</span>(&#123;root, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        state top = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (top.stage == <span class="number">0</span>) &#123;                  <span class="comment">// 状态 1</span></span><br><span class="line">            <span class="keyword">if</span> (top.node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">push</span>(&#123;top.node, <span class="number">1</span>&#125;);             <span class="comment">// 将本次调用栈状态修改为 1 再推回去（其实就不应该出栈）</span></span><br><span class="line">            s.<span class="built_in">push</span>(&#123;top.node-&gt;left, <span class="number">0</span>&#125;);       <span class="comment">// 新开的函数调用栈 helper(root-&gt;left)</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (top.stage == <span class="number">1</span>) &#123;           <span class="comment">// 状态 2</span></span><br><span class="line">            s.<span class="built_in">push</span>(&#123;top.node, <span class="number">2</span>&#125;);             <span class="comment">// 将本次调用栈状态修改为 2 再推回去（其实就不应该出栈）</span></span><br><span class="line">            ret.<span class="built_in">push_back</span>(top.node-&gt;val);</span><br><span class="line">            s.<span class="built_in">push</span>(&#123;top.node-&gt;right, <span class="number">0</span>&#125;);      <span class="comment">// 新开的函数调用栈 helper(root-&gt;right)</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (top.stage == <span class="number">2</span>) &#123;           <span class="comment">// 状态 3</span></span><br><span class="line">            <span class="comment">// do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
        <category>os</category>
      </categories>
      <tags>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>零拷贝</title>
    <url>/20220726200509_1857813313/</url>
    <content><![CDATA[<h1>为什么要零拷贝</h1>
<p>传统的 IO 拷贝在计算机中拷贝次数太多，速度太慢，零拷贝可以减少拷贝次数，增加系统性能。另外，零拷贝并不是指没有进行文件的拷贝，只是减少了拷贝的次数。</p>
<h2 id="DMA">DMA</h2>
<p>直接内存访问（Direct Memory Access）是一种执行 I/O 的工作方式。在这种方式中，DMA 控制器从 CPU 完全接管对总线的控制。这意味着数据交换不经过 CPU，而直接在内存和 I/O 设备之间进行 。DMA 方式一般用于高速传送成组数据。DMA 控制器将向内存发出地址和控制信号，修改地址，对传送的字的个数计数，并且以中断方式向 CPU 报告传送操作的结束。</p>
<p>DMA 方式的主要优点是速度快。由于 CPU 根本不参加传送操作，因此就省去了 CPU 取指令、取数、送数等操作。在数据传送过程中，没有保存现场、恢复现场之类的工作。内存地址修改、传送字个数的计数等等，也不是由软件实现，而是用硬件线路直接实现的。所以 DMA 方式能满足高速 I/O 设备的要求，也有利于 CPU 效率的发挥。</p>
<h2 id="用户态和内核态">用户态和内核态</h2>
<p>在 Linux 系统中，有的程序权限很高，可以访问计算机的任何资源，但是有的程序权限就低，只能访问部分资源。这两个类型的程序，就可以映射为用户态和内核态。内核态是计算机的核心，可以访问计算机的任何资源，如网卡、硬盘。为了安全，CPU 不能让用户程序肆无忌惮的访问计算机的任何资源，这样如果用户程序不稳定可能会造成系统崩溃，因此才有的用户态。</p>
<ul>
<li>内核态：可以访问内存的所有数据，包括外围设备，例如硬盘，网卡，cpu 也可以将自己从一个程序切换到另一个程序。</li>
<li>用户态：只能受限的访问内存，且不允许访问外围设备，占用 cpu 的能力被剥夺，cpu 资源可以被其他程序获取。</li>
</ul>
<p>综上所述，在 CPU 想要读取硬盘文件的时候，需要从用户态切换为内核态，才有权限。读取完成之后，为了程序安全，需要从内核态切换为用户态。</p>
<h1>普通拷贝</h1>
<p><img src="/20220726200509_1857813313/1.png" alt="1"><br>
<img src="/20220726200509_1857813313/1-1.png" alt="1-1"></p>
<p>在普通的拷贝时，流程如下：</p>
<ol>
<li>切换到内核态，先到内核态查询内核缓冲区，如果内核缓冲区有数据，则可以直接拷贝到用户空间中。如果内核缓冲区没有，则 CPU 会让 DMA 加载到内核空间中。这里就会有一次 DMA 拷贝。</li>
<li>拷贝到内核缓冲区之后，CPU 将会从内核缓冲区拷贝走。这是一次 CPU 拷贝。拷贝完成切换到用户态。</li>
<li>写数据的时候，再次切换到内核态。切换完成之后，写到 socket 缓冲区。写完之后，切换到用户态。</li>
<li>DMA 通过异步的方式将 socket 缓冲区的数据通过网卡发送到对端。</li>
</ol>
<p>这种普通的IO。总共有 4 次 CPU 切换（上图蓝色）。分别是：读 2 次、写 2 次。</p>
<p>4 次文件拷贝，分别是：</p>
<ol>
<li>文件从硬盘到内核空间</li>
<li>内核空间到 CPU</li>
<li>CPU 到 socket 缓冲区</li>
<li>socket 缓冲区到网卡。</li>
</ol>
<h1>零拷贝</h1>
<h2 id="mmap">mmap</h2>
<p><img src="/20220726200509_1857813313/2.png" alt="2"><br>
mmap 是零拷贝的一种方式通过虚拟内存的方式实现。也就是说用户空间和内核空间使用同一个物理地址。这样，文件就不在需要经过用户空间。可以从内核缓冲区直接复制到 socket 缓冲区。减少了一次文件拷贝。流程如下：</p>
<ol>
<li>调用 mmap，将一块用户空间映射到内核空间。此时进入内核态。DMA 把数据加载到内核空间，这是一次 DMA 拷贝。</li>
<li>切换回用户态。</li>
<li>调用 write，向用户空间写数据。数据直接从内核缓冲区写入到 socket 缓冲区。这是一次 CPU 拷贝。</li>
<li>返回用户态。DMA 异步的将 socket 缓冲区内容通过网卡发送到对端。</li>
</ol>
<p>共计 3 次内存拷贝，4 次用户内核态切换。</p>
<h2 id="sendfile">sendfile</h2>
<p><img src="/20220726200509_1857813313/3.png" alt="3"><br>
<img src="/20220726200509_1857813313/3-1.png" alt="3-1"><br>
sendfile 函数可以在两个文件描述符之间传递数据（完全在内核中操作），从而避免了内核缓冲区和用户缓冲区之间的数据拷贝。流程如下：</p>
<ol>
<li>系统调用 sendfile() 通过 DMA 把硬盘数据拷贝到内核缓冲区，这是一次 DMA 拷贝。</li>
<li>然后数据被内核拷贝到另外一个与 socket 相关的 socket 缓冲区。这里<strong>没有用户态和核心态之间</strong>的切换，在内核中直接完成了从一个缓冲区到另一个缓冲区的拷贝。这里虽说是写了 cpu 复制，但是如果网卡支持 scatter-gather ，并没有直接复制内容，而是复制了一些 offset 和 length 之类的数据到 socket 缓冲区。如下图：<br>
<img src="/20220726200509_1857813313/3-2.png" alt="3-2"></li>
<li>DMA 异步将 socket 缓冲区内容发送给对端，是一次 DMA 拷贝。如果网卡支持 scatter-gather，那么就直接从内核缓冲区直接 DMA 拷贝到网卡驱动。</li>
</ol>
<p>共计 3 次或 2 次内存拷贝，2 次用户内核态切换。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>进程代码段地址空间随机加载</title>
    <url>/20230526103802_4041215688/</url>
    <content><![CDATA[<h2 id="问题">问题</h2>
<p>今天调试代码的时候看到地址的时候突然感到奇怪：我记得我之前看到的代码地址空间好多都是 0x400xxx 开头的，怎么这次的地址空间是 0x5562b845axxx 呢？是什么导致了这个差异？</p>
<p>我换了地址空间为 0x400xxx 开头的机器，准备了相同的代码，在两台不同的机器上编译：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, main);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个简单的程序可以打出 main 函数的地址。经测试，在不同的机上打出的结果有很大差异。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@└────&gt; # ./a.out </span><br><span class="line">0x5562b845a649</span><br><span class="line"></span><br><span class="line">@└────&gt; # ./b.out </span><br><span class="line">0x400596</span><br></pre></td></tr></table></figure>
<h2 id="答案">答案</h2>
<p>经查阅资料，这个问题是 Linux 的 ASLR （Address Space Layout Randomization）导致的。这项技术会在装载时，装载到随机地址，防止黑客利用固定地址注入恶意代码。对于 b.out，没有使用该技术。所以 b.out 的代码段虚拟地址一直是 0x400000 开头。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@└────&gt; # readelf -h b.out </span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2&#x27;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              EXEC (Executable file)        // 这里是 EXEC</span><br><span class="line">  Machine:                           Advanced Micro Devices X86-64</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x4004b0                      // 这里是 _start 的绝对地址</span><br><span class="line">  Start of program headers:          64 (bytes into file)</span><br><span class="line">  Start of section headers:          15608 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           56 (bytes)</span><br><span class="line">  Number of program headers:         9</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         30</span><br><span class="line">  Section header string table index: 29</span><br></pre></td></tr></table></figure>
<p>可以看到，对于 b.out，他的文件类型是 Executable file，_start 的地址是 0x400xxx 开头。这种就是没有使用 ASLR 技术的。而对于 a.out，结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@└────&gt; # readelf -h a.out </span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2&#x27;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              DYN (Shared object file)      // 这里是 DYN</span><br><span class="line">  Machine:                           Advanced Micro Devices X86-64</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x560                         // 这里是 _start 的相对地址</span><br><span class="line">  Start of program headers:          64 (bytes into file)</span><br><span class="line">  Start of section headers:          12744 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           56 (bytes)</span><br><span class="line">  Number of program headers:         9</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         31</span><br><span class="line">  Section header string table index: 30</span><br></pre></td></tr></table></figure>
<p>对于 a.out，文件类型为 Shared object file，而且 _start 的地址是个相对地址。就是这个导致的这个差异。每次装载 a.out 时，代码会被加载到随机的位置。可以看到，每次运行，得到的地址都不同。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@└────&gt; # ./a.out </span><br><span class="line">0x559536d9d649</span><br><span class="line">@└────&gt; # ./a.out </span><br><span class="line">0x559a7a6df649</span><br><span class="line">@└────&gt; # ./a.out </span><br><span class="line">0x55ca5dbd4649</span><br></pre></td></tr></table></figure>
<h2 id="发生根因">发生根因</h2>
<p>之所以发生这个原因，是因为操作系统版本导致的。低版本操作系统默认不使用 ASLR。想要在不同的操作系统上复现这两个方式也很简单：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@└────&gt; # gcc 1.c -fPIC -pie</span><br></pre></td></tr></table></figure>
<p>这种方式编译出来的就是使用了 ASLR 技术的。其中 -pie 的意思是 position-independent executable，位置无关的可执行文件。编译时还需要加上 -fPIC （Position-Independent Code）生成位置无关代码。而</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@└────&gt; # gcc 1.c -no-pie</span><br></pre></td></tr></table></figure>
<p>方式编出来的就是固定地址。有些工具必须使用 -no-pie 才可以使用。这样固定的情况也比较好调试，因为虚拟地址固定。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
</search>
